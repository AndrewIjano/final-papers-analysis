SAUL ARA√öJO ANDRADE

IMPLEMENTA√á√ÉO E AVALIA√á√ÉO DE
UM CLUSTER DE BEAGLEBOARDS
AMBIENTADAS EM LINUX
UTILIZANDO MPI

Trabalho de Conclus√£o de Curso
apresentado √† Escola de Engenharia de S√£o
Carlos, da Universidade de S√£o Paulo
Curso de Engenharia de Computa√ß√£o
ORIENTADOR: Professor Doutor Carlos Dias Maciel

S√£o Carlos
2010

AUTORIZO A REPRODU√á√ÉO E DIVULGA√á√ÉO TOTAL OU PARCIAL DESTE
TRABALHO, POR QUALQUER MEIO CONVENCIONAL OU ELETR√îNICO,
PARA FINS DE ESTUDO E PESQUISA, DESDE QUE CITADA A FONTE.

Ficha catalogr√°fica preparada pela Se√ß√£o de Tratamento
da Informa√ß√£o do Servi√ßo de Biblioteca ‚Äì EESC/USP

A553i

Andrade, Saul Ara√∫jo
Implementa√ß√£o e avalia√ß√£o de um cluster de
beagleboards ambientadas em LINUX utilizando MPI / Saul
Ara√∫jo Andrade ; orientador Carlos Dias Maciel. ‚Äì- S√£o
Carlos, 2010.

Trabalho de Conclus√£o de Curso (Gradua√ß√£o em
Engenharia de Computa√ß√£o) -- Escola de Engenharia de S√£o
Carlos da Universidade de S√£o Paulo, 2010.

1. Microprocessadores. 2. Beagle. 3. OMAP.
4. Cluster. 5. MPI. 6.ARM. I. T√≠tulo.

Aos meus pais, Claudionor Medeiros de Andrade e Maria Auxiliadora Ara√∫jo Andrade, pela paci√™ncia que
tiveram e continuam a ter comigo, e por acreditarem que eu conseguiria vencer esta fase da vida mesmo estando
t√£o longe deles. . .
E aos meus irm√£os, Jos√© Ramos de Ara√∫jo Neto e Lorena Ara√∫jo Andrade, por se preocuparem comigo e
terem lembrado de me ligar em todos os meus anivers√°rios quando n√£o puderam estar comigo. Este trabalho √©
dedicado a voc√™s.

Agrade√ßo a todos os que me apoiaram desde o in√≠cio do curso: aos amigos que sempre tive e aos novos
que conheci, e que por diversas vezes me deram for√ßa para continuar (espero t√™-los ajudado de alguma forma
tamb√©m); ao meu orientador Prof. Dr. Carlos Dias Maciel, pela incr√≠vel conan√ßa que depositou em mim
durante este projeto e, em especial; √† Giovana Milanetto, que se tornou uma pessoa muito importante na minha
vida e nunca deixou de insistir para que eu dormisse mais de 3 horas por noite. . .
√Ä todos voc√™s, muito obrigado.

Sum√°rio

1

Introdu√ß√£o

1.1
2

Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

Fundamenta√ß√£o Te√≥rica

2.1
2.2

2.3

Beagle Board e a Arquitetura ARMV7-A . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

Sobre Sistemas Operacionais e Outros Conceitos . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.2.1

Kernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2.2.2

Sistemas de arquivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

Cluster . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.3.1

MPI e MPICH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

M√©todos

24

3.1

Kit de energia (Fonte de Alimenta√ß√£o) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

3.2

Distribui√ß√£o LINUX Utilizada . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

3.3

Plataforma de Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

3.4

3.3.1

Confec√ß√£o dos Cabos Seriais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

3.3.2

Processo de BOOT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

Ajuste Fino . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.4.1

Utilizando o OpenEmbedded (OE) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

3.4.2

Compilando o Kernel e Drivers Separadamente . . . . . . . . . . . . . . . . . . . . . . . . 31

3.5

Escolha da Implementa√ß√£o MPI e Montagem do Cluster . . . . . . . . . . . . . . . . . . . . . . . 32

3.6

Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.6.1

4

11

Arquitetura de Computadores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1.1

3

9

Cluster Heterog√™neo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

Conclus√µes

36

Refer√™ncias Bibliogr√°cas

52

3

Lista de Figuras
2.1

A cl√°ssica arquitetura de Von Neumann - uma CPU e uma unidade de mem√≥ria principal interligadas por um caminho √∫nico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

2.2

Beagle Board e suas dimens√µes inacredit√°velmente reduzidas: 3 x 3

. . . . . . . . . . . . . . . 13

2.3

RS-232 conector DB-25 apresentando na totalidade os sinais de comunica√ß√£o denidos pelo padr√£o
em quest√£o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.4

Cabo Ethernet RJ-45 e Modelo de camadas OSI . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

2.5

USB-OTG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

2.6

Cross-Compiling. Gera√ß√£o de bin√°rios atrav√©s de um compilador instalado em uma m√°quina de
arquitetura diferente da arquitetura alvo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

2.7

Kernel - camada de abstra√ß√£o mais baixa que prov√™ acesso aos recursos de hardware mais essencias
para aplica√ß√µes de mais alto n√≠vel. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2.8

Cluster da Universidade de Boise, claramente um cluster local. . . . . . . . . . . . . . . . . . . . 22

2.9

Exemplo de Grid com computadores espalhados ao redor do mundo trabalhando juntos. . . . . . 22

3.1

Regi√µes da Beagle Board trabalhadas durante este projeto . . . . . . . . . . . . . . . . . . . . . . 24

3.2

kit de energia e seus componentes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

3.3

Esquema de montagem do kit de energia ilustrando como devem estar dispostos os componentes

3.4

Cart√£o de mem√≥ria onde o sistema de arquivos ser√° acomodado . . . . . . . . . . . . . . . . . . . 26

3.5

Cabo serial montado pelo aluno para primeira intera√ß√£o com a BB . . . . . . . . . . . . . . . . . 27

3.6

HUB USB com conector trocado para o padr√£o miniUSB . . . . . . . . . . . . . . . . . . . . . . 28

3.7

Beagle Board conectada ao computador do laborat√≥rio via o cabo serial montado pelo aluno. . . 29

3.8

Imagem do software minicom exibindo o console serial da BB executando o u-boot . . . . . . . . 29

3.9

Beagle Board rodando o gerenciador gr√°co enlightenment . . . . . . . . . . . . . . . . . . . . . . 30

25

3.10 Adaptador USB/Ethernet com chipset correspondente ao m√≥dulo linux dm9601 . . . . . . . . . . 31
3.11 HUB Ethernet com elevada taxa de comunica√ß√£o. Utilizado para amenizar a lat√™ncia da rede. . . 33
3.12 Kit DSP L137 para o qual o MPICH foi portado tamb√©m. . . . . . . . . . . . . . . . . . . . . . . 33

4

5

LISTA DE FIGURAS

3.13 Plataforma de trabalho em sua forma nal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.14 Cluster Heterog√™neo formado pelo computador do laborat√≥rio, duas BB's e dois kits DSP . . . . 35
3.15 Imagem do MPI executando o programa de c√°lculo paralelo de PI

. . . . . . . . . . . . . . . . . 35

4.1

C√≥digo fonte utilizado nos testes dos cluster's . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

4.2

Congurando o minicom para acesso √† BB

4.3

Tela da BB j√° no segundo est√°gio de inicializa√ß√£o (u-boot) . . . . . . . . . . . . . . . . . . . . . . 48

4.4

Aplica√ß√£o do CI LM7805 como regulador de tens√£o. . . . . . . . . . . . . . . . . . . . . . . . . . 51

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

Lista de Tabelas
2.1

ARM Cortex e Algumas de suas aplica√ß√µes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

4.1

Especica√ß√µes da Beagle Board e do OMAP3530 . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

4.2

Evolu√ß√£o dos processadores ARM

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

6

Resumo
Quando se fala em supercomputa√ß√£o, uma abordagem muito comum √© dada pelos ditos Cluster. Um cluster,
nada mais √© que a associa√ß√£o de v√°rios computadores processando um mesmo problema. Apesar de parecer a
solu√ß√£o mais l√≥gica para a resolu√ß√£o de grandes quest√µes, imagine um problema t√£o complexo que exija 100
computadores para ser resolvido dentro de um tempo razo√°vel. Cada computador gasta uma determinada
quantia de energia, e a energia de 100 computadores √© aceit√°vel. No entanto, se o n√∫mero de computadores
simplesmente crescer com a complexidade do problema a ser resolvido, um limite ser√° eventualmente atingido.
Este trabalho tem como inten√ß√£o otimizar o uso da energia dispon√≠vel, propondo um cluster constitu√≠do por
OMAP's, um novo micro-processador de baixo consumo desenvolvido pela Texas Instruments detentor de uma
capacidade de processamento signicativa. Para tanto, a Beagle Board (BB), uma plataforma ARM que pode
ser alimentada via USB, foi escolhida como apropriada para o √≠nicio dos experimentos. Ap√≥s algum esfor√ßo
para se obter uma plataforma de trabalho operacional (instala√ß√£o do linux e recompila√ß√£o de alguns drivers),
era hora de decidir como gerenciar o cluster de fato. O MPICH, uma implementa√ß√£o do famoso protocolo de
passagem de mensagens atendia a todas as necessidades do projeto. O √∫ltimo obst√°culo a ser transposto seria
compilar este software para a arquitetura da BB, recentemente realizado.
Como resultado, o cluster de BB's provou-se vi√°vel.

Palavras-Chave: Beagle, OMAP, Cluster, MPI, Supercomputa√ß√£o, Multiprocessamento

7

Abstract
When it comes to the eld of supercomputing a very common approach is a Cluster, many computers
associated to solve a single problem sounds very good to begin with, however, imagine a problem so complex
that it takes 100 computers to be solved within a reasonable time, needless to say these computers spend energy,
hence, the more computers are added to the cluster the more energy is given away. The Question is: Should
more computers be continuosly added to a cluster to keep solving more complex problems?. Assuming there is
no unlimited power source avaiable, a practical limit will eventually be reached.
This work intends to take the most of the current avaiable power by proposing a cluster made of OMAP's,
a new low power micro-processor developed by Texas Instruments capable of signicant accomplishments. For
this purpose, The Beagle Board (BB), a usb powered ARM platform, was chosen as a suitable platform to begin
experimenting on the OMAP. After some eort to get it working (booting linux and tweaking some missing
drivers) it was time to decide how to manage the cluster. MPICH attended to all the needs of the project. The
last matter to be overcome was cross-compiling MPICH, which has been recently achieved.
The outcome reected all the expectations that surrounded it, a BB cluster has been proved viable.

Keywords: Beagle, OMAP, Cluster, MPI, Supercomputing, Multiprocessing

8

Cap√≠tulo 1
Introdu√ß√£o
A curiosidade √© uma caracter√≠stica humana intr√≠nseca, e traz consigo a vontade de investigar. Atrav√©s de uma
observa√ß√£o do que o cerca, o ser humano √© impelido a formular os mais variados questionamentos, de natureza
pr√°tica ou los√≥ca. Aliado ao senso de nitude (proveniente de outra caracter√≠stica inerente √† humanidade, a
mortalidade), a curiosidade move o homem; integrando como pe√ßa importante o motor de id√©ias t√£o presente
nesta esp√©cie. E o que seria a tecnologia sen√£o a formaliza√ß√£o deste motor?
Atrav√©s da tecnologia, quest√µes s√£o respondidas, de fato, mas tamb√©m, novas quest√µes s√£o geradas. Em um
dos ramos tribut√°rios da tecnologia, mais especicamente, na √°rea da computa√ß√£o, m√©todos para se resolver
problemas complexos s√£o constantemente discutidos.
Neste trabalho, foi realizada uma incurs√£o pela √°rea da supercomputa√ß√£o, e investigou-se a viabilidade de
um cluster constitu√≠do por plataformas ARM. Para tanto, escolheu-se uma plataforma chamada Beagle Board
(BB), constru√≠da a partir de um processador da fam√≠lia OMAP3; designou-se a distribui√ß√£o Angstrom Linux

para ser instalada e carregada nas placas atrav√©s de um cart√£o de mem√≥ria SD e, adaptou-se os perif√©ricos
necess√°rios como teclado e mouse para funcionarem a partir de um hub USB conectado as portas USB-OTG
das BB's. Como primeira interface com as placas, uma conex√£o serial foi estabelecida com um computador do
laborat√≥rio, e as vari√°veis de ambiente necess√°rias ao boot e √† exibi√ß√£o do v√≠deo das BB's via sa√≠da digital foram
alteradas com sucesso (o software utilizado para a comunica√ß√£o serial foi o minicom ). Tamb√©m foram montados

kit's de energia que consistem de fontes de 12V DC, capazes de suprir at√© 1A de corrente; CI's LM7805, para
que 2 sa√≠das de 5V DC estejam dispon√≠veis (uma para a BB e outra para o hub USB com alimenta√ß√£o externa
em cada kit ) e um cooler onde os reguladores de tens√£o est√£o xados para uma eciente dissipa√ß√£o de calor
(cada kit tem capacidade de suprir uma BB).
S√≥ ent√£o, com as plataformas de trabalho montadas e sendo capazes de executar em modo stand-alone, o
MPICH teve seu c√≥digo traduzido para a arquitetura ARM. As duas formas de tradu√ß√£o foram testadas: atrav√©s
de cross-compiling e compila√ß√£o nativa, dado o elevado clock do OMAP3530 - 720 MHz.

9

CAP√çTULO 1.

INTRODU√á√ÉO

10

Por m, adquiriu-se 2 adaptadores USB/Ethernet, um switch ethernet de boa qualidade e as BB's puderam
ser dispostas em forma de cluster (utilizando o MPICH). Alguns testes foram realizados, por√©m, devido a
problemas com o driver desta interface USB/ethernet espec√≠ca, n√£o foi poss√≠vel obter medidas para caracterizar
a qualidade do arranjo montado.
No entanto, havia no laborat√≥rio 2 kits de desenvolvimento (de arquiteturas diferentes da BB) que possuiam
sa√≠das ethernet nativas; atrav√©s de cross-compiling foi poss√≠vel traduzir o MPICH tamb√©m para estes dois kits e
oper√°-los em conjunto com as BB's, caracaterizando um cluster heterog√™neo e provando assim o pot√™ncial desta
t√©cnica.

1.1

Objetivos

Buscou-se neste trabalho, investigar a possibilidade de se montar um cluster, cujos n√≥s fossem dados por
plataformas Beagle Board. E atrav√©s disto obter um conhecimento mais aprofundado de arquiteturas ARM
(arquitetura da Beagle Board ) e o novo processador OMAP3530; linux embarcado (tanto customiza√ß√£o de kernel
quanto compila√ß√£o de drivers) e protocolos de comunica√ß√£o (Serial, USB, USB-OTG, entre outros); adquiriu-se
tamb√©m conhecimentos de como realizar compila√ß√£o cruzada (cross-compiling ) bem como da tecnologia que
empregada para gerenciar o cluster em si, MPICH. Dentre os principais desaos estiveram:
¬à A customiza√ß√£o do kernel linux para se adaptar √† BB
¬à Confec√ß√£o de cabos USB e Serial RS232
¬à Adapta√ß√£o nas portas USB-OTG da Beagle Board para induzir a fun√ß√£o de principal (host)
¬à Adapta√ß√µes realizadas em HUB's USB e hardwares que necessitassem de alimenta√ß√£o externa para que
fossem conectados ao kit de energia
¬à Mudar o arquivo congure do MPICH para que permitisse cross-compiling
¬à Fazer o cross-compiling do driver do adaptador USB/Ethernet a partir do seu c√≥digo fonte
Seria omiss√£o deixar de citar que trabalhar em uma m√°quina diferente das usuais tem muitos inconvenientes
em rela√ß√£o √†s usuais por√©m, est√° ocorrendo uma grande mobiliza√ß√£o para promover este tipo de esfor√ßo no meio

Open-Source, com destaque o time de desenvolvimento do Angstrom-Linux que mant√©m um reposit√≥rio atualizado de pacotes j√° compilados para diferentes arquiteturas; al√©m de um gerador de imagens linux customiz√°veis
online (narcissus).

Cap√≠tulo 2
Fundamenta√ß√£o Te√≥rica
A seguir, para a melhor compreens√£o deste trabalho, os conceitos mais importantes introduzidos anteriormente s√£o descritos. Espera-se que ao nal deste cap√≠tulo, a id√©ia principal por tr√°s dos mesmos esteja claricada
de maneira satisfat√≥ria

2.1

Arquitetura de Computadores

Design de computadores √© a arte de produzir um computador de boa performance para um dado conjunto de
especica√ß√µes a um baixo custo. Arquitetura de computadores √© a arte de criar um conjunto de especica√ß√µes
que perdurar√° por gera√ß√µes de tecnologia. (Robert J. B. - Universidade de Iowa)
Arquitetura de computadores √© o projeto do computador por completo, incluindo seu conjunto de instru√ß√µes
(ISA - Instruction-Set Architecture ) e componentes de hardware (HSA - Hardware-System Architecture ). Um
computador √© geralmente visto em termos de seu ISA, que diz respeito a como os programadores de linguagem
de m√°quina interagem com o computador. Em contraste, o HSA lida com os sistemas maiores de hardware, incluindo CPU (central processing unit, ingl√™s para unidade central de processamento), sistema de armazenamento
de dados e sistema de entrada e sa√≠da (I/O - Input/Output)[3]
√â importante citar que computadores de mesmo ISA geralmente ter√£o a habilidade de executar os mesmos
programas, isto leva diretamente √† no√ß√£o de fam√≠lia de computadores. Em suma, fam√≠lia de computadores nada
mais √© que um conjunto de implementa√ß√µes para o mesmo ISA. Na gura 2.1, √© poss√≠vel observar a arquitetura de
Von Neumann (VN) que apresenta uma CPU, um sistema de mem√≥ria principal e sistema de I/O. Nas m√°quinas
VN, instru√ß√µes s√£o carregadas sequencialmente e a CPU executa uma opera√ß√£o de cada vez; existe apenas um
caminho entre o sistema de mem√≥ria principal e a unidade de controle da CPU; o sistema de mem√≥ria principal
det√©m o programa que controla toda a opera√ß√£o do computador, e este pode manipular seu pr√≥prio programa
mais ou menos da mesma forma que qualquer outro dado na mem√≥ria[3]

11

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

12

Figura 2.1: A cl√°ssica arquitetura de Von Neumann - uma CPU e uma unidade de mem√≥ria principal interligadas
por um caminho √∫nico
A no√ß√£o de arquitetura de computadores √© de suma import√¢ncia para a percep√ß√£o do pot√™ncial que este
trabalho carrega, visto que a realiza√ß√£o mais signicativa deste foi fugir da arquitetura do PC convencional
para uma outra cujo ISA √© bem mais simples e o processador muito mais econ√¥mico por√©m, cujo processamento
atingiu um patamar signicativo e tende a crescer ainda mais; trata-se do OMAP3530 que ser√° melhor detalhado
a seguir.

2.1.1

Beagle Board e a Arquitetura ARMV7-A

Para o √≠nico dos experimentos com o OMAP 3530 uma plataforma chamada Beagle Board (BB) foi eleita. A
BB √© um mini-computador de baix√≠ssimo consumo (compar√°vel ao de um celular), com processador da fam√≠lia
OMAP3 de arquitetura ARMv7-A (Se√ß√£o 2.1), otimizado para ambiente Linux, que pode ser alimentado via
USB (universal serial bus, Se√ß√£o 2.1.1.3) com baixa dissipa√ß√£o de pot√™ncia. A fam√≠lia OMAP3 [12]√© formada
por processadores de alto-desempenho projetados para garantir processamento gr√°co de qualidade. Alguns de
seus principais subsistemas s√£o: microprocessador ARM CortexTM-A8 720MHz (ver tabela 4.2 nos anexos),
acelerador gr√°co 2D/3D capaz de renderizar 10 milh√µes de pol√≠gonos por segundo e DSP (Digital Signal
Processor, ingl√™s para processador digital de sinais1 ) com core C64x+ 430MHz, tudo isso garante √† BB uma
performance compar√°vel a de um laptop com um consumo de pico de 2W. Na gura 2.2, pode-se ter uma id√©ia
da apar√™ncia f√≠sica da BB, enquanto que na tabela 4.1 (ver Anexo A), as caracter√≠sticas do OMAP3530 j√° citadas
anteriormente s√£o acrescidas de mais detalhes.
1 Os

DSP's s√£o processadores especiais que executam algumas opera√ß√µes de maneira otimizada, tendo como prop√≥sito o trata-

mento de sinais como √°udio e v√≠deo.

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

13

Figura 2.2: Beagle Board e suas dimens√µes inacredit√°velmente reduzidas: 3 x 3
A BB mede apenas 3" x 3" e possui sa√≠da de v√≠deo digital. A corrente m√°xima drenada pela plataforma
sozinha √© de 350mA, sendo que sua tens√£o de alimenta√ß√£o √© de 5V (padr√£o USB, ver 2.1.1.3), o que a torna um
excelente ponto de partida para uma nova gera√ß√£o de port√°teis de baixo consumo e portanto, maior autonomia.
Quanto ao processamento de sinais, s√£o innd√°veis as aplica√ß√µes m√©dicas que o OMAP35x poderia oferecer,
um exemplo seria aumentar o grau de intelig√™ncia de algoritmos para detec√ß√£o de QRS durante um eletrocardiograma, garantindo ao m√©dico que operasse tal aparelho uma maior conabilidade em suas leituras. Vale
lembrar que este n√£o √© o est√°gio nal de desenvolvimento desta fam√≠lia de processadores, a Texas Instruments
anunciou recentemente que sua nova vers√£o poder√° superar 1GHz de clock, mantendo o baixo consumo.
Sobre a arquitetura do OMAP (ARMV7-A), ARM √© uma arquitetura de 32-bit com um conjunto reduzido de
instru√ß√µes (ISA - Instruction Set Architecture ) concebida originalmente pela empresa Acorn Computers. Antes
da sigla mais moderna, a arquitetura ARM era conhecida como Acorn RISC (Reduced Instruction Set Computer)

Machine, e s√≥ mais tarde, Advanced RISC Machine 2 . A m√°quina avan√ßada de instru√ß√µes reduzidas foi projetada
como uma arquitetura para PC's, um mercado agora dominado pela fam√≠lia x86 utilizada pela IBM; no entanto,
a relativa simplicidade dos processadores ARM tornou-os apropriados para aplica√ß√µes low-power, isto fez desta
fam√≠lia a dominante no mercado de tecnologias m√≥veis e embarcadas.
A arquitetura ARM √© licenci√°vel e portanto, o desenvolvimento de processadores deste tipo pode ser feito
por outras empresas al√©m da ARM Holdings, o que se mostrou bastante ecaz como t√°tica de populariza√ß√£o da
tecnologia. Algumas das empresas que t√™m ou j√° tiveram esta licensa incluem: Atmel, Broadcom, Freescale, Intel,

LG, Marvell Technology Group, NEC, NVIDIA, NXP (antiga Philips), Samsung, Sharp, Texas Instruments e
Yamaha [13]
A tabela 2.1, abaixo, demonstra o grau de desenvolvimento atingido pela fam√≠lia Cortex-A8 (uma tabela
mais completa que traz a evolu√ß√£o dos processadores ARM pode ser encontrada nos Anexo B).
2A

mudan√ßa na sigla deveu-se a uma

ARM Holdings

joint venture

entre Acorn, Apple e VLSI Tec, que gerou uma empresa conhecida como

que tinha como objetivo investir e desenvolver a tecnologia da Acorn.

CAP√çTULO 2.

14

FUNDAMENTA√á√ÉO TE√ìRICA

Tabela 2.1: ARM Cortex e Algumas de suas aplica√ß√µes.
Fam√≠lia

Arquitetura

ARMv7-A

N√∫cleo

Aplica√ß√£o

Cortex-A5

-

Cortex-A8

Texas Instruments OMAP3xxx series,
SBM7000, Gumstix Overo Earth,
Pandora, Apple iPhone 3GS, Apple
iPod touch (3rd Generation), Apple
iPad (Apple A4 processor), Archos 5,
FreeScale i.MX51-SOC,
BeagleBoard,

Motorola Droid, Palm

Pre, Rockchip RK2806 and RK2808,
Samsung i8910, Book, Nokia N900,
Meizu M9.
Cortex-A9

-

Cortex-A9 MPCore

Texas Instruments OMAP4430/4440,
ST-Ericsson U8500, Nvidia Tegra2

Cortex

ARMv7-R

Cortex-R4(F)

Broadcom , TMS570 from Texas
Instruments

ARMv7-ME

Cortex-M4

-

(Merlin)
ARMv7-M

Cortex-M3

Texas Instruments Stellaris
microcontroller family, Ember's
EM3xx Series, Atmel AT91SAM3,
Europe Technologies EasyBCU,
Energy Micro's EFM32

ARMv6-M

Cortex-M0

NXP Semiconductors NXP LPC1100,

(Swift)

Triad Semiconductor, Melfas,
Chungbuk Technopark, Nuvoton,
austriamicrosystems

Cortex-M1

Actel ProASIC3, ProASIC3L, IGLOO
and Fusion PSC devices, Altera
Cyclone III, other FPGA products are
also supported

CAP√çTULO 2.

2.1.1.1

FUNDAMENTA√á√ÉO TE√ìRICA

15

RS-232

No contexto de trabalho com a BB, o RS232 foi fundamental pois foi ele que permitiu a comunica√ß√£o inicial
com a placa (ainda sem sistema operacional) para que as congura√ß√µes necess√°rias √† inicializa√ß√£o correta da
placa fossem efetuadas.
Amplamente utilizado em portas de computadores, o Recommended Standard 232 √© um padr√£o de comunica√ß√£o serial3 que relaciona o DTE (Data Terminal Equipment ) e o DCE (Data Circuit-terminating Equipment ),
quem envia e recebe dados. No total, o padr√£o recomenda um conector com 25 pinos, conhecido como D-

subminiature 25, e especica 20 diferentes sinais de comunica√ß√£o; por√©m, observa-se uma tend√™ncia ao uso
reduzido deste n√∫mero de sinais, culminando em conectores menores (como o DB-9). Para se ter uma id√©ia da
maleabilidade deste padr√£o, √© poss√≠vel denir uma conex√£o RS-232 m√≠nima com apenas 3 pinos: Rx Tx e GND
(Figura 2.3) e mais, caso a conex√£o seja one way (dados uindo em sentido √∫nico) 2 pinos seriam sucientes.
Apenas quando se deseja um controle do uxo de dados, dois sinais adicionais precisam ser empregados: RTS
e CTS(Figura 2.3) [10].

Figura 2.3: RS-232 conector DB-25 apresentando na totalidade os sinais de comunica√ß√£o denidos pelo padr√£o
em quest√£o
2.1.1.2

Ethernet

Atualmente, conectividade √© um recurso b√°sico; tanto para compartilhar informa√ß√£o quanto para manter-se
atualizado. Do ponto de vista dos sistemas linux (em especial a distribui√ß√£o Angstrom, trabalhada aqui), ter
acesso √† rede signica obter mais f√°cilmente os pacotes necess√°rios ao perfeito funcionamento do sistema que
ser√° montado, e a tecnologia que rege este acesso √© a Ethernet. O padr√£o Ethernet 4 ganhou seu nome do antigo
conceito grego de √©ter (do Latim, √¶ther signica o mais puro ar) que seria a mat√©ria que compunha o universo e
demais coisas misteriosas5 . Ethernet √© uma fam√≠lia de tecnologia de redes baseadas em frame para LAN's (Local
3 comunica√ß√£o serial signica que √© enviado um bit por vez, sequencialmente, atr√°ves de um canal de comunica√ß√£o (um barramento
de computador, por exemplo).

4 Na

verdade, ethernet √© um nome popular que permaneceu mesmo ap√≥s a padroniza√ß√£o da tecnologia pelo IEEE segundo o qual

esta tecnologia seria o padr√£o 802.3[6].

5o

ar que ina o corpo dos mortos era conhecido como √âter de Plut√£o

CAP√çTULO 2.

16

FUNDAMENTA√á√ÉO TE√ìRICA

Area Network, ingl√™s para rede de √°rea local) e dene um n√∫mero de sinais e padr√µes de sinaliza√ß√£o para a
camada f√≠sica do modelo OSI [2](Open System Interconnection. Figura 2.4), bem como um formato comum de
endera√ßamento e MAC6 na camada de data link .

Figura 2.4: Cabo Ethernet RJ-45 e Modelo de camadas OSI
Ao longo dos anos (algo a partir dos anos 80), o padr√£o ethernet vem substituindo padr√µes concorrentes e
rmando posi√ß√£o no meio de telecomunica√ß√µes, sua vers√£o para tecnologias √≥pticas j√° est√° em uso no oriente,
sendo aplicada em rede √≥pticas passivas conhecidas como EPON's e aguarda uma disputa com o padr√£o GMPLS (Generalized Multiprotocol Label Switching 7 ) que, inclusive, deve ser o padr√£o adotado pelo Brasil[4] nos
pr√≥ximos anos.
2.1.1.3

USB - Universal Serial Bus

Atualmente, os principais perif√©ricos acoplados aos computadores utilizam o padr√£o USB como forma de comunica√ß√£o, na BB n√£o poderia ser diferente. Nesta subse√ß√£o tamb√©m √© enfatizado o padr√£o OTG. √â interessante
car atento a esta parte pois ela √© alvo de modica√ß√µes durante os procedimentos pr√°ticos descritos no cap√≠tulo
seguinte. O barramento serial universal come√ßou a ser desenvolvido em 1994 por um grupo de sete empesas:

Compaq, DEC, IBM, Intel, Microsoft, NEC e Nortel. A premissa b√°sica do USB seria tornar a conex√£o de
perif√©ricos aos PC's mais f√°cil, substituindo assim a vasta gama de conectores diferentes presentes at√© ent√£o.
Al√©m disso, o USB tamb√©m implementaria uma classe para armazenamento em massa de informa√ß√µes, a USB

mass storage class que encontra nos pen-drives seu maior exemplo.[15]
O USB 1.0 foi introduzido em 1996 e permitia uma taxa de transfer√™ncia de dados de 12Mbps, no entanto,
a vers√£o USB adotada pela priemira vez em larga escala foi a 1.1 (1998). A epsecica√ß√£o USB1.1 dividia os
dispositivos em dois grandes grupo LS (de baixa velocidade:  Low Speed ) e FS (de alta velocidade:  Full

Speed ) e alocava taxas de transfer√™ncia diferentes para eles. Para os dispositivos FS, como discos r√≠gidos, a
taxa de transfer√™ncia manteve-se igual √† do USB1.0, 12Mbps; e para os dispositivos LS como joystics e teclado,
uma taxa menor foi designada, 1.5Mbps.[11]
6 Media Access Control, endere√ßo f√≠sico de um dispositivo
7 √© um padr√£o generalizado para telecomunica√ß√µes bastante

atual.

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

17

Esta gura ilustra como os pap√©is iniciais dos dispositivos s√£o determinados pela orienta√ß√£o do cabo. A partir
disso, eles podem trocar de papel sempre que necess√°rio atrav√©s do HNP (Host-Negotiation-Protocol ).
Figura 2.5: USB-OTG
Em 2001, um esfor√ßo conjunto da Hewlett-Packard, Intel, Lucent Technologies (atual Alcatel-Lucent), NEC

e Philips levou √† padroniza√ß√£o do USB2.0, agora com uma taxa de tranfer√™ncia de 480Mbps8 . E mais recentemente, em 2010, os primeiros produtos que utilizam a tecnologia USB3.0 come√ßaram a ser comercializados. Esta
√∫ltima tecnologia apresenta uma taxa signicativamente maior, 5Gbps em modo superspeed, como resultado
a tecnologia precisou alterar a forma f√≠sica de seus conectores. Os cabos USB passar√£o a apresentar 2 os para
Vcc e GND, 2 os para dados em modo normal, 4 os para dados em modo superspeed e uma blindagem (que
n√£o era necess√°ria nas especica√ß√µes anteriores), por√©m os conectores ser√£o retro-compat√≠veis. Vale destacar
tamb√©m que dispositivos corretamente congurados poder√£o drenar at√© 900mA da porta USB3.0, quase o dobro
das anteriores, 500mA.[15]
Sobre os conectores USB, existem diversos formatos e tipos de conectores para este padr√£o mas, na especica√ß√£o original havia apenas dois padr√µes:
¬à USB-A: este conector foi desenvolvido para ser ligado √† uma porta de downstream do dispositivo principal
(host ). Neste tipo de conex√£o, dados uem e energia √© demandada do host. √â comumente observado em
cabos permanentemente xados a um perf√©rico, tal como teclado ou mouse.
¬à USB-B: neste tipo de conex√£o, embora tamb√©m possa carregar ambos: dados e energia, √© comum ver
dispositivos utilizando a porta USB apenas como fonte de for√ßa.
Somado a tudo isso, uma expans√£o na especica√ß√£o USB introduziu o conceito OTG (on-the-go ) que implica
na utiliza√ß√£o da comunica√ß√£o USB entre dois dispositivos que n√£o s√£o necessariamente host's (como pode ser
visto na gura 2.5) de forma simples, o perif√©rico que est√° com o cabo tipo A acoplado a si √© dito dispositivo-A
e passa a agir como principal (host ) para o outro dispositivo, energizando a interface USB. Um dispositivo com
cabo tipo B acoplado comporta-se como perif√©rico, este √© o comportamento padr√£o assumido por um dispositivo
USB-OTG.[15]
8 dispositivos

que se utilizam desta taxa s√£o ditos HS (

High Speed )

CAP√çTULO 2.

2.1.1.4

FUNDAMENTA√á√ÉO TE√ìRICA

18

Cross-Compilation

Escrever um programa seria uma tarefa consideravelmente mais complexa caso os compiladores n√£o existissem, visto que as m√°quinas s√≥ entendem sua pr√≥pria linguagem, a dita linguagem de m√°quina ou linguagem
bin√°ria; o compilador exerce uma fun√ß√£o crucial (de tradutor) neste sistema, sendo respons√°vel por converter
um texto escrito em uma determinada linguagem de programa√ß√£o para 0's e 1's. Agora, √© comum que c√≥digos
sejam escritos para serem executados em m√°quinas de mesma arquitetura(ver 2.1) e mais comum ainda que
sejam escritos para serem rodados na mesma m√°quina em que s√£o escritos, isto √© dito compila√ß√£o nativa.[5]

Figura 2.6: Cross-Compiling. Gera√ß√£o de bin√°rios atrav√©s de um compilador instalado em uma m√°quina de
arquitetura diferente da arquitetura alvo.
Quando se lida com PC's, a compila√ß√£o nativa √© completamente aceit√°vel, √© algo natural pois, onde mais se
escreveria um programa? e, para que mais sen√£o para rodar no computador? entretanto, quando o foco gira
em torno de dispositivos n√£o t√£o poderosos (em termos de velocidade de processamento) quanto o PC, fazer
compila√ß√£o nativa pode n√£o ser t√£o razo√°vel. Em celulares por exemplo, os smart-phones atuais s√£o capazes
at√© mesmo de rodar sistemas operacionais e apesar do cont√≠nuo aumento no clock de seus processadores (vem
aumentando muito, o pr√≥prio OMAP35x est√° sendo utilizado em celulares), a grande maioria n√£o est√° nem
pr√≥xima da casa dos GHz; como as aplica√ß√µes est√£o cando cada vez mais complexas e at√© mesmo para a
comodidade do programador e econ√¥mia de tempo, √© muito interessante deter a habilidde de gerar bin√°rios para
alvos diferentes com a velocidade de um PC (como ilustrado na gura 2.6). Para a realiza√ß√£o deste feito, √©
necess√°rio possuir um tradutor para a arquitetura de interesse, este √© o Cross-Compiler.
2.1.1.5

OE - OpenEmbedded

O Projeto OpenEmbedded (OE) √© um framework de software criado com o objetivo principal de gerar distribui√ß√µes Linux [9], mas n√£o unicamente para sistemas embarcados. Foi criado originalmente por Chris Larson,
Michael Lauer, e Holger Schurig, combinando os resultados obtidos pelo OpenZaurus com contribui√ß√µes de

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

19

projetos como o Familiar Linux e OpenSIMpad em uma base de c√≥digos comum. O OpenEmbedded englobou
estes projetos e √© atualmente utilizado para gerar qualquer um deles atrav√©s da mesma base de dados. Primariamente, o projeto mant√©m e desenvolve uma cole√ß√£o de BitBake recipes, similar aos ebuilds do Gentoo. Os

bitbakes consistem em uma fonte URL do pacote, depend√™ncias e op√ß√µes de instala√ß√£o e compila√ß√£o. Durante
o processo de constru√ß√£o, eles s√£o utilizados para rastrear depend√™ncias, executar cross-compile (ver 2.1.1.4) e
gerar novos pacotes de acordo com as congura√ß√µes desejadas para uma arquitetura alvo. Tamb√©m √© poss√≠vel
criar imagens completas, consistindo de sistema de arquivos ra√≠z e kernel (ver 2.2.1).
Durante o projeto, o OE foi utilziado diversas vezes, fosse para gerar uma imagem da distribui√ß√£o angstrom
[1] ou algum pacote especicamente.

2.2

Sobre Sistemas Operacionais e Outros Conceitos

√â dicil encontrar uma deni√ß√£o isolada para sistema operacional (S.O.) al√©m de ser um programa que √©
executado em modo kernel, e mesmo isso n√£o √© sempre verdade. Parte do problema √© que os S.O.'s realizam
basicamente duas fun√ß√µes distintas: prover √†queles que programam aplica√ß√µes (e aplica√ß√µes, naturalmente) um
conjunto limpo e abstrato de recursos, ao inv√©s de confusos ambientes de hardware e gerenciar estes mesmos
recursos de hardware.[11]
Sendo um conceito complexo, optou-se por apresentar abaixo pe√ßas fundamentais de um sistema operacional
para que a elucida√ß√£o sobre o mesmo aconte√ßa de maneira mais natural.

2.2.1

Kernel

O kernel √© nada menos que o n√∫cleo, o cerne de um sistema operacional. Trata-se de uma camada de baixo
n√≠vel respons√°vel por controlar e prover acesso9 √† recursos ess√™ncias de hardware como mem√≥ria, dispositivos
presentes e processsador (como pode ser visto na gura 2.7)[11].

Figura 2.7: Kernel - camada de abstra√ß√£o mais baixa que prov√™ acesso aos recursos de hardware mais essencias
para aplica√ß√µes de mais alto n√≠vel.
9 isto

√© geralmente feito atrav√©s de mec√¢nismos de comunica√ß√£o inter-processos e System Calls

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

20

¬à Kernel monol√≠tico: todos os servi√ßos do Sistema Operacional (S.O.) rodam no contexto principal de execu√ß√£o e residem na mesma regi√£o de mem√≥ria. Alguns programadores defendem o modelo como facilmente
implement√°vel, no entanto, se um acionador de dispositivo (device driver ) estiver mal escrito pode derrubar
o sistem inteiro.[11]
¬à MicroKernel: este estilo prop√µe implementar um kernel apenas com as funcionalidades mais b√°sicas como:
gerenciamento de mem√≥ria, multi-tarefas e comunica√ß√£o inter-processos. O restanto das funcionalidades
devem ser implementados no espa√ßo do usu√°rio, como resultado, este tipo de kernel √© mais f√°cilmente
mantido que o monol√≠tico. Por√©m, o grande n√∫mero de System Calls e mudan√ßa de contexto podem
deixar o sistema mais lento. O microKernel permite a implementa√ß√£o de grande parte do sistema como
um programa qualquer, escrito em uma linguagem de alto n√≠vel; permite tamb√©m que um outro S.O. seja
utilizado sobre o mesmo kernel inalterado.[11]
¬à Kernel H√≠brido: um meio-termo entre o kernel micro e monol√≠tico prop√µe que alguns servi√ßos sejam
mantido no contexto do kernel para aumentar a performance de execu√ß√£o.[11]
¬à NanoKernel: um kernel deste tipo delega ainda mais fun√ß√µes que o Microkernel, inclusive as mais b√°sicas
como gerenciamento de mem√≥ria.
¬à ExoKernel: este tipo de kernel n√£o abstrai o hardware em modelos te√≥ricos. Ao inv√©s disso, aloca recursos
f√≠sicos (tais como tempo de processamento, p√°ginas de mem√≥ria e blocos de disco) para programas diferentes. Uma aplica√ß√£o sendo executado sobre um exoKernel pode fazer refer√™ncia a um sistema operacional
biblioteca, este por sua vez simula as abstra√ß√µes de S.O.'s bem conhecidos, ou permite o desenvolvimento de
novas. Isto √© bastante interessante em termos de otimiza√ß√£o de c√≥digo, visto que abstra√ß√µes desnecess√°rias
podem ser ignoradas.[11]

2.2.2

Sistemas de arquivos

Agora que o n√∫cleo de um S.O. foi explicado, √© imposs√≠vel n√£o mencionar sistemas de arquivos, anal, quando
um usu√°rio √© inquirido sobre o dom√≠nio que ele possui sobre um determinado sistema como Windows as resposta
normalmente s√£o relativas ao sistema de arquivos: copiar arquivos, renome√°-los, mov√™-los e uma s√©rie de outras
opera√ß√µes comuns.
Toda aplica√ß√£o de computador necessita armazenar e recuperar informa√ß√µes. enquanto um processo est√°
rodando, ele pode armazenar uma quantidade limitada de informa√ß√£o dentro do seu espa√ßo de endere√ßamento.
Um segundo problema em manter informa√ß√µes dentro de um processo √© que quando este processo termina, a
informa√ß√£o se perde. Vale citar tamb√©m que quando h√° muitos processos rodando eles frequentemente precisam
acessar a informa√ß√£o (ou partes dela) ao mesmo tempo [11].

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

21

A maneira de resolver todos esses inconvenientes √© tornar a informa√ß√£o independente em si, independente
de qualquer processo.
Arquivos s√£o um mecanismo de abstra√ß√£o que prov√™em formas de armazenar informa√ß√µes no disco r√≠gido e
depois recuper√°-las. Mais formalmente, arquivos s√£o unidades l√≥gicas de informa√ß√£o criadas por processos, um
disco pode conter milhares ou at√© mesmo milh√µes delas. Se cada arquivo fosse pensado como um tipo de espa√ßo
de endere√ßamento n√£o se estaria muito longe da verdade, exceto que eles s√£o usados para modelar o disco ao
inv√©s da mem√≥ria principal (RAM). [11]
Os arquivos s√£o gerenciados pelo sistema operacional. Como eles s√£o estruturados, nomeados, acessados,
usados, protegidos e implementados s√£o detalhes important√≠ssimos a serem denidos quando um S.O. √© implmentado, e a parte do sistema operacional que lida com arquivos √© conhecida como sistema de arquivos.
[11]
Neste trabalho dois sistemas de arquivos s√£o empregados do come√ßo ao m dos experimentos, s√£o eles FAT
e EXT3, que s√£o melhor explicados abaixo:
¬à FAT - ou tabela de aloca√ß√£o de arquivos (File Allocation Table ), neste modelo, uma tabela que cont√©m
os endere√ßos de cada bloco que comp√µe o disco e informa√ß√µes sobre os arquivos √© guardada na mem√≥ria
principal. O fato de ser uma tabela de tamanho xo benecia o acesso rand√¥mico a qualquer um dos
blocos do disco, e estes blocos n√£o precisam se preocupar em armazenar informa√ß√µes extra, mantendo seu
tamanho original.[11]
¬à EXT3 - de forma bastante suscinta, o ext3 √© um sistema de arquivos cuja estrutura base a qual um
arquivo est√° associado chama-se i-node, que lista todas as caracter√≠sticas, atributos e endere√ßos de disco
dos blocos que comp√µem um arquivo. A principal vantagem dos i-nodes em rela√ß√£o √† FAT √© que o i-node
precisa apenas estar na mem√≥ria principal quando o arquivo ao qual ele corresponde est√° em uso. O
EXT3 tamb√©m implementa um journaling le system, uma esp√©cie de di√°rio atualizado continuamente
de qualquer mudan√ßa que venha a ocorrer no sistema; assim, quando ocorre um falha, os dados podem
ser recuperados tornando o sistema mais robusto.[11]

2.3

Cluster

Um cluster [11] √© basicamente um conjunto de computadores interconectados (atrav√©s de uma rede eth-

ernet, por exemplo. Ver 2.1.1.2), que se conhecem e compartilham informa√ß√µes e tarefas (processamento de
dados) obedecendo uma plataforma pr√©-denida (sistema distribu√≠do). Existem diversas arquiteturas de cluster,
numa das mais comuns, Beowulf, existe uma √∫nica m√°quina (mestra) que gerencia os n√≥s escravos. Algumas
categorias de cluster s√£o descritas a seguir:

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

22

¬à Compute Cluster - Trata-se da id√©ia mais natural de cluster, esta associa√ß√£o de computadores √© utilizada
para processamento de tarefas e n√£o opera√ß√µes orientadas a I/O, como servi√ßos web. Aqui, os n√≥s est√£o
muito proximamente conectados e h√° uma grande quantidade de tarefas interdependentes, ou seja, a
comunica√ß√£o entre os n√≥s √© frequ√™nte. Exemplos comuns de aplica√ß√£o deste modelo s√£o simula√ß√µes de
clima e simula√ß√µes de batidas de ve√≠culos.

Figura 2.8: Cluster da Universidade de Boise, claramente um cluster local.
¬à Grid Computing - Os grids encontram-se no outro extremo em rela√ß√£o ao tipo de cluster anteriormente
descrito, as m√°quinas pertencentes ao grid, geralmente, est√£o dispostas em locais geogr√°camente diferentes e n√£o necessariamente pertencem √† mesma arquitetura (ver 2.1), fazendo com que estes possam
atingir dimens√µes elevad√≠ssimas em termos de n√∫mero de m√°quinas (clusters que apresentam m√°quinas
de arquiteturas diferentes s√£o conhecidos como heterog√™neos). Portanto, √© imprescind√≠vel que a tarefas
sejam altamente coesas (contidas em si pr√≥prias) para que n√£o haja uma condi√ß√£o de estrangulamento
em algum ponto do arranjo. Exemplos de grid s√£o: o projeto Folding@home que analiza dados utilizados
por pesquisadores na busca da cura para doen√ßas como c√¢ncer e Alzheimer; e o projeto SETI@home, este
faz uso de mais de tr√™s milh√µes de m√°quinas, espalhadas pelo mundo, para analizar dados colhidos pelo
radiotelesc√≥pio do observat√≥rio de Arecibo em busca de evid√™ncias de vida extraterrestre.[8]

Figura 2.9: Exemplo de Grid com computadores espalhados ao redor do mundo trabalhando juntos.

CAP√çTULO 2.

FUNDAMENTA√á√ÉO TE√ìRICA

23

Este √© o ponto crucial do projeto proposto pelo aluno, associar m√°quinas como a BB para executar multiprocessamento de dados. Na subse√ß√£o seguinte, a escolha da tecnologia que sustentar√° o cluster de Beagle

Boards, MPICH, ser√° justicada.

2.3.1

MPI e MPICH

O protocolo de passagem de mensagens, em ingl√™s message passing interface (MPI), √© um protocolo de
comunica√ß√£o bastante utlizado na programa√ß√£o de m√°quinas em ambiente paralelo; suas principais metas s√£o,
al√©m da performance: escalabilidade e portabilidade[14]. A interface MPI deve prover uma topologia virtual
ess√™ncial (sincroniza√ß√£o e comunica√ß√£o) entre um conjunto de processos que foram mapeados para as m√°quinas
integrantes do cluster. O MPI tamb√©m dene thread safe interfaces que ajudam a evitar a manipula√ß√£o err√¥nea
de algum estado dos processos dentro dos programas (a designa√ß√£o de qual processo ser√° encaminhado a qual
n√≥ √© tomada em tempo de execu√ß√£o).
MPICH foi a implementa√ß√£o MPI adotada por este trabalho e dene-se pelo padr√£o MPI-1.1. Durante o
processo de escolha, o MPICH2 (que se baseia no padr√£o MPI-2.0) tamb√©m foi considerado, e descartado por
ainda n√£o suportar tradu√ß√£o de dados entre arquiteturas de hardware diferentes[14].

Cap√≠tulo 3
M√©todos
As BB's foram obtidas por interm√©dio da Universidade de S√£o Paulo que efetuou a importa√ß√£o das mesmas
de uma empresa norte-americana chamada Digikey. Rec√©m chegados, os pacotes continham apenas as placas
BB, sem nenhum perif√©rico para comunica√ß√£o ou fonte para energiz√°-las. Um dos atrativos da BB √© exatamente
no que diz respeito √† alimenta√ß√£o, a BB pode ser energizada via USB, no entanto, como a inten√ß√£o era rodar
a BB em modo stand-alone (sem depender de alguma outra m√°quina diretamente) e era de interesse reservar
esta porta USB para comunica√ß√£o com demais perif√©ricos,um kit de alimenta√ß√£o externa foi criado.
A gura abaixo retrata uma vista superior da Beagle Board e ser√° frequentemente referenciada durante este
cap√≠tulo para illustrar insterven√ß√µes realizadas pelo aluno.

1
2
3/4
5
6

entrada de energia
USB-OTG
Audio - in/out
V√≠deo - sa√≠da anal√≥gica
Serial RS-232

7
8
9
10
11

V√≠deo - sa√≠da digital
TFP410 - convers√£o de v√≠deo
Leitor de cart√£o multimedia
Reset
bot√£o especial USR

Figura 3.1: Regi√µes da Beagle Board trabalhadas durante este projeto

24

CAP√çTULO 3.

3.1

25

M√âTODOS

Kit de energia (Fonte de Alimenta√ß√£o)

Como j√° mencionado, √© de interesse reservar a porta USB-OTG (ver 2.1.1.3) para comunica√ß√£o com perif√©ricos ao inv√©s de alimenta√ß√£o. Na gura 3.1, a regi√£o de n√∫mero 1 exp√µe um conector de energia que pode ser
utilizado para este m.
Para a montagem de um kit, como pode ser observado na gura 3.2,foram utilizados:
¬à 2 CI's LM7805 - reguladores de tens√£o para 5V
¬à 1 placa de wire-up (placa de cobre com furos)
¬à 1 cooler de alimenta√ß√£o 12V DC comum
¬à 1 dissipador de calor
¬à 1 fonte de tens√£o 12V DC, centro positivo, comum

Figura 3.2: kit de energia e seus componentes
Primeiramente, um peda√ßo de placa wire-up, suciente para acomodar os reguladores de tens√£o foi cortado
e devidamente trilhado com solda (para a montagem do circuito regulador de tens√£o, utilizou-se o modelo
proposto pelo datasheet do LM7805 que pode ser vercado no Anexo G). Em seguida, a partir da fonte de
tens√£o, foram postos em paralelo, o cooler, um 7805 e depois o outro (como no esquema da gura 3.3).

Figura 3.3: Esquema de montagem do kit de energia ilustrando como devem estar dispostos os componentes

CAP√çTULO 3.

M√âTODOS

26

Finalmente, os reguladores de tens√£o foram parafusados ao dissipador de calor para evitar qualquer anomalia
de corrente que venha a causar seu mau funcionamento. Segundo as especica√ß√£o do LM7805 [7], os circuito
integrado deve funcionar bem com at√© 400mA de corrente, mais que isso ele esquentar√° demais. Isto completa
a montagem do kit para fornecimento de energia da BB.

3.2

Distribui√ß√£o LINUX Utilizada

O pr√≥ximo passo na montagem da plataforma de trabalho foi designar uma distribui√ß√£o linux compat√≠vel
com a arquitetura do OMAP3530. Felizmente, o Angstrom linux j√° estava preparado para dar suporte √† BB, e
de seu website [1] foi poss√≠vel obter arquivos extremamente √∫teis para um primeiro teste como:
¬à um kernel linux j√° compilado
¬à o u-boot, ou bootloader universal (uma ferramenta que prov√™ o b√°sico para a intera√ß√£o prim√°ria com
diversos dispositivos, neste caso, a BB)
¬à uma imagem do sistema operacional (inclusive com X-windows instalado)
¬à x-loader (√© executado durante o boot da BB, normalmente j√° est√° guardado na mem√≥ria NAND da BB,
mas em alguns casos √© necess√°rio atualiz√°-lo)
A partir de ent√£o, um cart√£o SD (gura 3.4) foi adquirido pelo laborat√≥rio e teve sua geometria alterada para
imitar a de um disco r√≠gido comum, ou seja, 255 cabe√ßas e 63 setores de 512Mb cada. No Anexo F, √© poss√≠vel
vericar como a ferramenta fdisk foi utilizada para realizar esta altera√ß√£o. √â importante lembrar que, todos
estes procedimentos relativos ao cart√£o SD est√£o sendo realizados no computador do laborat√≥rio atrav√©s de um
leitor de cart√£o presente na m√°quina. Por √∫ltimo, o cart√£o de mem√≥ria foi particionado em dois: uma parti√ß√£o
FAT (ver 2.2.2) menor que auxilia no boot do sistema e, uma parti√ß√£o EXT3 (ver 2.2.2) maior que acomoda o
sistema de arquivos em si.

Figura 3.4: Cart√£o de mem√≥ria onde o sistema de arquivos ser√° acomodado

CAP√çTULO 3.

M√âTODOS

27

O pr√≥ximo passo foi copiar para dentro da parti√ß√£o FAT um arquivo bin√°rio chamado MLO que auxiliar√°
no processo de boot (este processo ser√° explicado melhor em 3.3), √© importante que este bin√°rio seja a primeira
coisa a ser movida para dentro cart√£o, ocupando assim o primeiro setor dele; copiou-se tamb√©m para esta
parti√ß√£o o Kernel Linux e um outro arquivo bin√°rio u-boot (tamb√©m requerido pelo processo de boot ). J√° na
parti√ß√£o EXT3, a imagem do sistema de arquivos foi extra√≠da. Isto conclui todas os opera√ß√µes relativas ao
cart√£o multimedia.

3.3

Plataforma de Trabalho

At√© aqui, j√° estava a disposi√ß√£o do aluno uma kit de energia, e um cart√£o SD devidamente alterado e
preparado com a distribui√ß√£o Angstrom Linux. Restava congurar as vari√°veis de ambiente corretas na BB
para que a inicializa√ß√£o do sistema operacional fosse realizada a partir do cart√£o SD e que a sa√≠da de v√≠deo
digital fosse utilizada, bem como acoplar os perif√©ricos √† porta USB da BB. Os textos seguintes cuidam destes
√∫ltimos entraves.

3.3.1

Confec√ß√£o dos Cabos Seriais

O primeiro contato com a placa BB foi realizado atrav√©s de comunica√ß√£o serial RS-232, como indicado na
gura 3.1 pela regi√£o 6. foram adquiridos ent√£o, dois conectores de 9 pinos e um cabo at (10 os) que foram
utilizados para montar o cabo mostrado na gura 3.5(o padr√£o do conector DB-9 foi seguido e tamb√©m pode
ser observado nesta gura).

Figura 3.5: Cabo serial montado pelo aluno para primeira intera√ß√£o com a BB
√â v√°lido notar que apenas 9 pinos s√£o utilizados na conex√£o serial, portanto o pino 10 do conector serial da
BB deve ser ignorado (pode ser dobrado ou mesmo cortado).
Tamb√©m foi necess√°rio fazer uma pequena adapta√ß√£o do conector USB no hub adquirido pelo laborat√≥rio
para o padr√£o miniUSB. A interven√ß√£o foi bem simples1 . Em um cabo USB qualquer (excluindo o padr√£o 3.0)
1 apesar

de ter levado um tempo consider√°vel dada a falta de experi√™ncia do aluno com soldagem.

CAP√çTULO 3.

28

M√âTODOS

existem 4 os, 2 para alimenta√ß√£o da interface e 2 para troca efetiva de dados; ao observar a gura 2.5, v√™-se a
adi√ß√£o de mais um o, o id que encontra-se interrompido do lado do perif√©rico e portanto, id√™ntico a um USB
padr√£o. Efetuou-se ent√£o a troca do conector USB padr√£o do hub por um conector miniUSB tipo B como se
pode ver na gura 3.6 (todas as soldagens foram isoladas com termo-retr√°til ou refor√ßadas com cola de silicone
quando conveniente).

Figura 3.6: HUB USB com conector trocado para o padr√£o miniUSB
Por √∫ltimo, para reservar denitivamente √† USB-OTG sua fun√ß√£o como host, uma gota de solda foi utilizada
para curto-circuitar as trilhas 4 e 5 deste conector indicado na gura 3.1 pela regi√£o 2, curto-circuitando assim
os sinais correspondentes a id gnd na gura 2.5 e denindo portanto, um dispositivo tipo A.

3.3.2

Processo de

BOOT

Chegou a hora de nalmente fazer um primeiro contato com a BB, mas primeiramente √© importante entender
a fun√ß√£o de cada um dos objetos presentes no cart√£o de mem√≥ria:
¬à x-loader - √© dito um bootloader de primeiro est√°gio e sua fun√ß√£o √© preparar o sistema para rodar o
est√°gio seguinte e transferir o controle para ele, que seria o u-boot. O x-loader √© compacto e cabe na
mem√≥ria interna ROM do OMAP, ele ativa o controle da mem√≥ria externa para poder carregar o u-boot,
que demanda mais espa√ßo. O x-loader √© normalmente transferido via serial por√©m, na BB, um arquivo
diferente √© utilizado: o MLO.
¬à MLO - quando n√£o h√° resposta aos pulsos emitidos pelo OMAP na porta serial, ele busca automaticamente
no cart√£o de mem√≥ria por um arquivo especial, o MLO, que √© na verdade um x-loader com um cabe√ßalho
indicando uma posi√ß√£o de mem√≥ria onde este deve ser carregado e tamb√©m seu tamanho).
¬à u-boot - √© um bootloader de segundo est√°gio que tem como fun√ß√£o carregar o kernel tamb√©m presente na
parti√ß√£o FAT do cart√£o SD para nalmente tornar dispon√≠vel todos os recursos de hardware, inclusive a

CAP√çTULO 3.

M√âTODOS

29

mem√≥ria RAM e possibilitar o boot do linux. O u-boot √© transferido para a mem√≥ria principal pelo MLO
e em seguida tem o controle passado para si.
sabendo disto, o cabo serial montado em 3.3.1 √© utilizado, em conjunto com um conector DB9FxDB9F para
conectar a BB ao computador do laborat√≥rio (gura 3.7.

Figura 3.7: Beagle Board conectada ao computador do laborat√≥rio via o cabo serial montado pelo aluno.
Bastou congurar o software minicom para uma comunica√ß√£o de serial 115200 baud/s, 8 bits, sem paridade
e 1 stop-bit (maiores detalhes podem ser encontrados no Anexo E) e o console serial da BB, rodando o u-boot
fez-se dispon√≠vel (gura 3.8).

Figura 3.8: Imagem do software minicom exibindo o console serial da BB executando o u-boot
Trocou-se ent√£o as var√°veis de ambiente de interesse bootargs e bootcmd que correspondem aos argumentos e ao comando de boot respectivamente ( nos Anexo E, as linhas de c√≥digo necess√°rias a isto est√£o
explicitadas).

CAP√çTULO 3.

M√âTODOS

30

Figura 3.9: Beagle Board rodando o gerenciador gr√°co enlightenment
Finalmente todo o ajuste b√°sico estava completo, ap√≥s o reinicio do sistema, o boot passou a ser efetuado
pelo cart√£o SD, eliminando a necessidade da conex√£o serial com o computador. Na gura 3.9, pode-se ver a BB
rodando o Angstrom Linux com Enligthenment como gerenciador gr√°co.

3.4

Ajuste Fino

Em teoria, a partir deste ponto, faltaria apenas repetir o mesmo procedimento para a outra placa BB.
No entanto, deve-se lembrar que todo o material utilizado, em termos de software, vieram de um exemplo
fornecido pelo time de desenvolvimento do Angstrom Linux e portanto, possuia muito mais pacotes que os
realmente necess√°rios, o kernel n√£o estava t√£o atualizado quanto poderia e assim alguns m√≥dulos poderiam
estar tamb√©m desatualizados. Para corrigir estes detalhes, uma peregrina√ß√£o de n√≠vel muito mais baixo foi
tra√ßada, envolvendo desde a obten√ß√£o do c√≥digo fonte do kernel at√© a compila√ß√£o assistida do driver para o
adaptador USB/Ethernet que foi utilizado para prover conectividade √† BB.

3.4.1

Utilizando o OpenEmbedded (OE)

Ap√≥s navegar em diversas listas de desenvolvimento, esta ferramenta, OE, chamou bastante aten√ß√£o, como
explicado em 2.1.1.5, o OE se utiliza de arquivos chamado recipes e um cross-compiler (ver 2.1.1.4) para criar
distribui√ß√µes linux inteiras ou pacotes separados. Em diversas situa√ß√µes foi feito uso do OE, o caso de maior
sucesso foi para gerar distribui√ß√µes linux sem servidor X, ou seja, console-only ; outra tentativa diz respeito a
escrever uma recipe para o MPICH que n√£o est√° inclu√≠da no trabalho dado seu fracasso.

CAP√çTULO 3.

M√âTODOS

31

O OpenEmbedded foi obtido atrav√©s de um reposit√≥tio GIT (ferramenta de versionamento) clonado para
o computador do laborat√≥rio, foi ent√£o instalada sua principal ferramenta: bitbake, que √© respons√°vel pela
interpreta√ß√£o e execu√ß√£o das recipes (maiores detalhes sobre a instala√ß√£o e uso do OE podem ser encontradas
no Anexo D deste trabalho); nalmente, um perl (ver Anexo D) descrevendo a arquitetura alvo para a qual
todo pacote deveria ser compilado foi denido e carregado sempre que se desejou utilizar o OE.
O OE foi ser utilizado tamb√©m para construir as ferramentas de boot como o u-boot a partir de fontes mais
atualizados.

3.4.2

Compilando o Kernel e Drivers Separadamente

Uma das grandes diculdades encontradas no trabalho foi como dar suporte ao adaptador USB/Ethernet
(gura 3.10), por uma infelicidade, o kernel em sua vers√£o 2.6.26 (que foi herdado dos arquivos de exemplo
do time de desenvolvimento do Angstrom Linux) n√£o suportava o chipset do adaptador que correspondia ao
m√≥dulo de nome dm9601. Durante este projeto, diferentes solu√ß√µes para este problema foram encontradas
por√©m, nenhuma denitiva.
A primeira corre√ß√£o tentada foi obter o c√≥digo fonte do kernel linux, j√° modicado para o OMAP3 (este
tam√©m encontra-se em um reposit√≥rio GIT e como qualquer processo que envolva linhas de c√≥digo, est√° descrito
nos Anexo D deste trabalho); obter o c√≥digo fonte do m√≥dulo dm9601 e efetuar algumas modica√ß√µes em seu
interior para dar suporte ao adaptador em quest√£o. Feito isso, incluiu-se o fonte alterado na respectiva pasta
de m√≥dulos do kernel OMAP e atrav√©s da linha de comando, foi ordenado que apenas os m√≥dulos fossem
recontru√≠dos de maneira independente (ou seja, n√£o acoplados ao kernel linux). Assim, ao nal do processo, um
arquivo bin√°rio referente ao m√≥dulo em quest√£o estava dispon√≠vel na pasta do kernel e foi prontamente copiado
e incluido no cart√£o de mem√≥ria onde p√¥de ser carregado atrav√©s do comando modprobe.

Figura 3.10: Adaptador USB/Ethernet com chipset correspondente ao m√≥dulo linux dm9601
Apesar do OE j√° apresentar um cross-compiler, um outro chamado CodeSoucery (que possui otimiza√ß√µes
para o Cortex-A8) foi instalado devido a diculdade de se trabalhar com o cross-compiler do OE fora da sua
√°rvore de diret√≥rios.

CAP√çTULO 3.

32

M√âTODOS

Algum tempo depois, a partir do kernel 2.6.27, o m√≥dulo correspondente ao adaptador presente no laborat√≥rio
passou a ter suporte do kernel, e as imagens podiam ser geradas no OE sem o contratempo de precisar recompilar
este m√≥dulo separadamente.
Como √∫ltima alternativa, o time do angstrom (sempre muito a frente no que diz respeito a BB) criou uma
casca online dentro de seu site, onde se podia utilizar o OE de uma forma bem simples e intuitiva, este √© o
projeto Narcissus: ao m de uma congura√ß√£o feita via checkbox's, o narcissus disponibilizava para download
tanto a imagem linux personalizada e a recipe utilizada para ger√°-la, quanto uma imagem de cart√£o SD pronta
para ser grava em um dispositivo deste tipo.
Em todos os casos, o driver n√£o funcionou bem e apresentou problemas relacionados ao tamanho dos pacotes
recebidos e, mesmo tendo seu MTU (congura√ß√£o do tamanho dos pacotes de dados recebidos atrav√©s da interface
de rede) alterado para um padr√£o ethernet (1492 ou 1500) o mesmo continuou a quebrar (em ingl√™s utiliza-se
o termo crash ) ap√≥s um uso prolongado da conex√£o.
Da√≠ a vantagem de se ter o m√≥dulo constru√≠do separado do kernel, quando ocorreram crash 's, bastou remover
o m√≥dulo com o comando rmmod e carreg√°-lo novamente; agora, nas situa√ß√µes em que o m√≥dulo foi contru√≠do

built-in (junto com o kernel), um crash no m√≥dulo signicou por v√°rias vezes um crash no kernel. E isto tem um
nome bastante temido entre os que trabalham com linux, chama-se kernel panic e a √∫nica forma de resolv√™-lo √©
recarregando o kernel (ou seja, reiniciando a m√°quina).
A √∫nica raz√£o para insistir no uso do mesmo adaptador USB ethernet √© que, no Brasil, todos os chipsets
dos adaptadores vendidos (encontrados pelo aluno) eram os mesmos e por consequ√™ncia, utilizavam o mesmo
m√≥dulo.

3.5

Escolha da Implementa√ß√£o MPI e Montagem do Cluster

Foram testadas diversas implementa√ß√µes MPI, destaca-se o OpenMPI por j√° ser familiar a alguns alunos
do laborat√≥rio, o que atenuaria bastante a curva de aprendizado da ferramenta. Infelizmente, ap√≥s diversas
tentativas, n√£o foi poss√≠vel traduzir o OpenMPI para a arquitetura ARMv7-A nem atrav√©s de cross-compiling,
nem atrav√©s de compila√ß√£o nativa (ver 2.1.1.4).
Tamb√©m foi avaliado o MPICH2 que se baseia no padr√£o MPI 2.0 (ver 2.3.1) que tamb√©m foi descartado
pela impossibilidade de adapta√ß√£o √† arquitetura alvo.
Finalmente, o MPICH 1.2.27 foi pass√≠vel de tradu√ß√£o. A compila√ß√£o nativa √© mais facilmente realiz√°vel
pois o processo de instala√ß√£o da ferramenta2 executa testes, e quando se tenta executar bin√°rios em de outra
arquitetura a instala√ß√£o obviamente falha pois os testes falham; logo para se executar um compila√ß√£o cruzada,
2 padr√£o

linux: primeiro executa-se um script de congura√ß√£o, que checa se todas as depend√™ncias necess√°rias ao pacote est√£o

dispon√≠veis e cria

Makeles ;

depois o comando

make

executa os

Makeles

copia os bin√°rios e demais arquivos para a √°rvore linux em quest√£o

para gerar bin√°rios; por m, o comando

make install

CAP√çTULO 3.

M√âTODOS

33

√© necess√°rio alterar os scripts de congura√ß√£o do MPICH para que ignorem estes testes (scripts com algo em
torno de 16000 linhas). Os dois m√©todos foram provados vi√°veis.
O MPICH √© interessante do ponto de vista de cross-compiling. Enquanto o OpenMPI utiliza um bin√°rio
chamada mpicc para compilar c√≥digos que utilizem o padr√£o MPI, o mpicc do MPICH √© apenas um script que
indica como o que um compilador comum deve fazer para traduzir um c√≥digo MPI para bin√°rio. De posse desta
informa√ß√£o, bastou indicar neste script que o cross-compiler deve ser usado para se obter bin√°rios relativos a
uma outra arquitetura.
Por m, as plataformas de trabalho Beagle Board, tiveram o adaptador USB/Ethernet conectados a si
atrav√©s do hub USB (pela porta USB-OTG) e em seguidas foram conectadas √† uma rede comum. Depois foi
utilizado um hub ethernet de 100 Mbps para conectar as plataformas at√© que se pudesse obter um hub ethernet
de qualidade com taxas de comunica√ß√£o Gigabit (visto na gura 3.11).

Figura 3.11: HUB Ethernet com elevada taxa de comunica√ß√£o. Utilizado para amenizar a lat√™ncia da rede.
Tamb√©m foi obtido um porte do MPICH para a arquitetura ARMv5-TE, referente a um kit de desevolvimento
DSP (gura 3.12) presente no laborat√≥rio.

Figura 3.12: Kit DSP L137 para o qual o MPICH foi portado tamb√©m.

3.6

Resultados

Foram obtidos desde o in√≠cio do trabalho:
¬à Duas plataforma de trabalho compostas (cada uma) por: uma BB com porta USB-OTG devidamente

CAP√çTULO 3.

M√âTODOS

34

modicada para exercer o papel de host; um kit de energia composto por cooler, dissipador de calor e dois
reguladores de tens√£o de 5V e uma fonte de 12V DC; um hub USB com alimenta√ß√£o externa (vinda do kit
de energia). As BB's foram conguradas para que a sa√≠da de v√≠deo digital fosse utilizada3 (mais detalhes
no Anexo E), portanto, podem ser ligadas a qualquer monitor compat√≠vel. Na gura 3.13, pode-se ver a
forma nal da plataforma de trabalho BB.

Figura 3.13: Plataforma de trabalho em sua forma nal
¬à Vers√µes pr√©-compiladas do MPICH para x86, ARMv7-A e ARMv5TE.
¬à Dois cart√µes de mem√≥ria SD com distribui√ß√£o Angstrom linux customizada.
¬à As habilidades necess√°rias para associar as plataformas de trabalho para que funcionem em paralelo,
gra√ßas ao MPICH.
¬à Foram compilados e executados alguns testes bem simples apenas para esclarecer qualquer d√∫vida de que o
MPICH havia sido portado corretamente para a BB. Um dos candidatos escolhidos para este prop√≥sito foi
uma implementa√ß√£o paralela de c√°lculo do Pi (c√≥digo fonte dispon√≠vel no Anexo C) que foi corretamente
executada.

3.6.1

Cluster Heterog√™neo

Em certo ponto do trabalho, j√° tendo portado o MPICH para a arquitetura ARMv7-A, decidiu-se checar
tamb√©m a possibilidade de traduzi-lo para a arquitetura ARMv5-TE (ver 3.5) isto porque, no laborat√≥rio, havia
dois kits DSP cujas arquiteturas correspondiam a esta. A gura 3.14, retrata uma congura√ß√£o atingida com
os kits DSP, as duas plataformas BB e o computador do laborat√≥rio.
3 na

gura 3.1, a regi√£o 8 indica um componente bastante interessante, o TFP410. Este componente √© capaz de receber os

dados em formato RGB e convert√™-los para o padr√£o de v√≠deo HDMI, presente nos monitores de alta deni√ß√£o.

CAP√çTULO 3.

M√âTODOS

35

Figura 3.14: Cluster Heterog√™neo formado pelo computador do laborat√≥rio, duas BB's e dois kits DSP
Apesar da baixa capacidade de processamento de dados (quando o uso do DSP n√£o √© feito), a implementa√ß√£o
desta associa√ß√£o foi um sucesso e uma aplica√ß√£o sendo executada por ela pode ser vista na gura 3.15.

Figura 3.15: Imagem do MPI executando o programa de c√°lculo paralelo de PI

Cap√≠tulo 4
Conclus√µes
O projeto foi em todos os aspectos, bastante inovador, e apresentou grau de diculdade m√©dio para o aluno,
visto que o mesmo n√£o possuia conhecimentos anteriores nem de linux, nem de sistemas embarcados. Al√©m
disso, devido ao OMAP3530 ser um processador recente, as informa√ß√µes sobre este (na internet sobretudo) s√£o
escassas e, em sua maioria, pouco organizadas.
A confec√ß√£o do cabo DB9 (ver gura 3.5), adapta√ß√£o do conector do hub USB de padr√£o para mini e a
compila√ß√£o cruzada de um driver (realizada manualmente) tamb√©m merecem destaque, pois zeram com que
um aprofundamento signicativo em linux embarcado fosse atingido. O contato com a ferramente OE foi um
dos pontos fortes do projeto, pois √© largamente empregada na √°rea de tecnologia embarcada e tem potencial
para poupar o desenvolvedor de muito trabalho. Por exemplo, atrav√©s do bitbake o OE baixa automaticamente
o c√≥digo fonte do kernel desejado, aplica todos os patchs necess√°rios a uma arquitetura alvo e ainda executa
toda a parte de cross compile.
√â indispens√°vel citar tamb√©m a revis√£o conceitos abordados pelo projeto, tais como: arquitetura de computadores, tecnologias de comuni√ß√£o (serial, usb) e sistema operacional.
Como dito em 3.5, em um primeiro caso, quando as placas estavam conectadas √† rede do Departamento de
Engenharia El√©trica, a lat√™ncia inuiu muito nos resutados. Mais tarde, com o hub de 100Mbps, esta lat√™ncia
diminuiu, por√©m, ainda era mais r√°pido executar o programa localmente em apenas um dos n√≥s. S√≥ com o hub
GigaBit √© que foi poss√≠vel se ter id√©ia da eci√™ncia do cluster. Devido aos problemas encontrados com o chipset
do adaptador USB/Ethernet (ver 3.4.2) n√£o foi poss√≠vel obter medidas para caracterizar de forma satisfat√≥ria
o desempenho do cluster.
Em um determinado ponto, um cluster heterog√™neo (ver 2.3) composto por, al√©m da BB, mais dois kits
de DSP de arquitetura ARMv5TE e o computador do laborat√≥rio (x86) esteve dispon√≠vel. Apesar do porte
do MPICH ter sido um sucesso, a baixa capacidade de processamento dos kits quando n√£o fazem uso do DSP
mostrou-se um inconveniente (300 MHz), no entanto, isto prova o potencial deste projeto.

36

Anexo A

Tabela 4.1: Especica√ß√µes da Beagle Board e do OMAP3530
Beagle Board

Processador
(OMAP3530)

¬à 720MHz Cortex-A8
¬à 430MHz DSP
¬à On-Chip L1/SRAM - 112 KB (DSP),32 KB (ARM Cortex-A8)
¬à On-Chip L2/SRAM - 96 KB (DSP),256 KB (ARM Cortex-A8)
¬à RAM 64 KB
¬à ROM - 16 KB (DSP),32 KB (ARM Cortex-A8)
¬à EMIF - 1 32-Bit SDRC,1 16-Bit GPMC
¬à External Memory Type Supported - LPDDR,NOR Flash,NAND
ash,OneNAND,Asynch SRAM
¬à DMA - 64-Ch EDMA,32-Bit Channel SDMA
¬à Video Port (Congurable) - 1 sa√≠da dedicada, 1 entrada dedidaca
¬à Acelerador Gr√°co - Sim
¬à MMC/SD - 3
¬à McBSP - 5
¬à Pinos/encapsulamento - 423FCBGA, 515POP-FCBGA
¬à POP Interface - Sim
¬à I2C - 3
¬à McSPI - 4
¬à HDQ/1-Wire - 1
¬à UART - 3
¬à USB - 2
¬à Timers - 12 32-Bit GP,2 32-Bit WD
¬à Core Supply (Volts) - 0.8 V to 1.35 V
¬à IO Supply (Volts) - 1.8 V,3.0 V (MMC1 apenas)
¬à Operating Temperature Range (¬∞C) - 0 to 90,-40 to 105

Mem√≥ria RAM
Mem√≥ria NAND
Consumo de Pico

128MB
256MB
2W

37

Anexo B
Tabela 4.2: Evolu√ß√£o dos processadores ARM
Fam√≠lia

Arquitetura

N√∫cleo

Aplica√ß√£o

ARM1

ARM1

ARM1

segundo processador da BBC Micro

ARM2

Acorn Archimedes, Chessmachine

ARM250

Acorn Archimedes

ARM2a

Acorn Archimedes

ARM60

3DO Interactive Multiplayer, Zarlink

(obsoleto)
ARM2

ARMv2
(obsoleto)
ARMv2a
(obsoleto)

ARM3

ARMv2a
(obsoleto)

GPS Receiver
ARM6

ARMv3

ARM600

-

ARM610

Acorn Risc PC 600, Apple Newton 100

(obsoleto)
series

ARM7

ARMv3

ARM700

Acorn Risc PC prototype CPU card

ARM710

Acorn Risc PC 700

ARM710a

Acorn Risc PC 700, Apple eMate 300

ARM7100

Psion Series 5

ARM7500

Acorn A7000

ARM7500FE

Acorn A7000+ Network Computer

(obsoleto)

38

CAP√çTULO 4.

39

CONCLUS√ïES

ARM7TDMI(-S)

Game Boy Advance, Nintendo DS,
Apple iPod, Lego NXT, Atmel
AT91SAM7, Juice Box, NXP
Semiconductors LPC2000 and
LH754xx

ARMv4T

ARM710T

Psion Series 5mx, Psion Revo/Revo
Plus/Diamond Mako

ARM7TDMI

ARM720T

Psion Series 5mx, Psion Revo/Revo
Plus/Diamond Mako

ARMv5TEJ

ARM740T

-

ARM7EJ-S

-

SA-110

Apple Newton 2x00 series, Acorn Risc
PC, Rebel/Corel Netwinder, Chalice
CATS

StrongARM

ARMv4

SA-1100

Psion netBook

SA-1110

LART (computer), Intel Assabet, Ipaq
H36x0, Balloon2, Zaurus SL-5x00, HP
Jornada 7xx, Jornada 560 series,
Palm Zire 31

ARM8
ARM9TDMI

ARMv4
ARMv4T

ARM810

Acorn Risc PC prototype CPU card

ARM9TDMI

-

ARM920T

Armadillo, Atmel AT91SAM9, GP32,
GP2X (rst core), Tapwave Zodiac
(Motorola i. MX1), Hewlet Packard
HP-49/50 Calculators, Sun SPOT,
Cirrus Logic EP9302, EP9307,
EP9312, EP9315, Samsung S3C2442
(HTC TyTN, FIC Neo FreeRunner),
Samsung S3C2410 (TomTom
navigation devices)

ARM922T

NXP Semiconductors LH7A40x

CAP√çTULO 4.

40

CONCLUS√ïES

ARM9TDMI

ARMv4T

ARM940T

GP2X (second core), Meizu M6 Mini
Player

ARM946E-S

Nintendo DS, Nokia N-Gage,

Canon PowerShot A470, Canon EOS
5D Mark II, Conexant 802.11 chips,
Samsung S5L2010
ARMv5TE
ARM9E

ARMv5TEJ

ARM966E-S

ST Micro STR91xF, includes Ethernet

ARM968E-S

NXP Semiconductors LPC2900

ARM926EJ-S

Mobile phones: Sony Ericsson (K, W
series); Siemens and Benq (x65 series
and newer); LG Arena; OMAP-L137,
OMAP-L138; Freescale i.MX21,
i.MX27, Atmel AT91SAM9, NXP
Semiconductors; Bualo TeraStation
Live (NAS); Telechips TCC7801,
TCC7901;ZiiLABS' ZMS-05 system on
a chip; Western Digital MyBook I
World Edition.

ARMv5TE

ARM996HS

-

ARMv5TE

ARM1020E

-

ARM1022E

-

ARM1026EJ-S

Western Digital MyBook II World

ARM10E
ARMv5TEJ

Edition;Conexant so4610 and so4615
ADSL SoC
80200/IOP310/

-

IOP315
XScale

80219

Thecus N2100

IOP321

Iyonix

IOP33x

-

IOP34x

-

PXA210/PXA250

Zaurus SL-5600, iPAQ H3900, Sony
CLI√â NX60, NX70V, NZ90

CAP√çTULO 4.

41

CONCLUS√ïES

PXA255

Gumstix basix & connex, Palm
Tungsten E2, Zaurus SL-C860, Mentor
Ranger & Stryder, iRex ILiad

XScale

ARMv5TE

PXA263

Sony CLI√â NX73V, NX80V

PXA26x

Palm Tungsten T3

PXA27x

Gumstix verdex, Trizeps-Modules,
PXA270 COM, HTC Universal, HP
hx4700, Zaurus SL-C1000, 3000, 3100,
Rokr E6, Fujitsu Siemens LOOX
N560, Toshiba Port√©g√© G500, Treo
650-755p, Zipit Z2, HP iPaq 614c
Business Navigator.

PXA800(E)F

-

PXA3XX

Samsung Omnia

("Monahans")
PXA900

Blackberry 8700, Blackberry Pearl
(8100)

ARMv6

IXC1100

-

IXP2400/IXP2800

-

IXP2850

-

IXP2325/IXP2350

-

IXP42x

NSLU2 IXP460/IXP465

ARM1136J(F)-S

Texas Instruments OMAP2420 (Nokia
E90, Nokia N93, Nokia N95, Nokia
N82)

ARM11

ARMv6T2

ARM1156T2(F)-S

ARMv6KZ

ARM1176JZ(F)-S

Apple iPhone

(original and 3G),

Apple iPod touch

(1st and 2nd

Generation), Conexant CX2427X,
Motorola RIZR Z8, NVIDIA GoForce
6100; Telechips TCC9101, TCC9201
ARMv6K

ARM11 MPCore

Nvidia APX 2500

CAP√çTULO 4.

42

CONCLUS√ïES

ARMv7-A

Cortex-A5

-

Cortex-A8

Texas Instruments OMAP3xxx series,
SBM7000, Gumstix Overo Earth,
Pandora, Apple iPhone 3GS, Apple
iPod touch (3rd Generation), Apple
iPad (Apple A4 processor), Archos 5,
FreeScale i.MX51-SOC,
BeagleBoard,

Motorola Droid, Palm

Pre, Rockchip RK2806 and RK2808,
Samsung i8910, Book, Nokia N900,
Meizu M9.
Cortex-A9

-

Cortex-A9 MPCore

Texas Instruments OMAP4430/4440,
ST-Ericsson U8500, Nvidia Tegra2

Cortex

ARMv7-R

Cortex-R4(F)

Broadcom , TMS570 from Texas
Instruments

ARMv7-ME

Cortex-M4

-

(Merlin)
ARMv7-M

Cortex-M3

Texas Instruments Stellaris
microcontroller family, Ember's
EM3xx Series, Atmel AT91SAM3,
Europe Technologies EasyBCU,
Energy Micro's EFM32

ARMv6-M

Cortex-M0

NXP Semiconductors NXP LPC1100,

(Swift)

Triad Semiconductor, Melfas,
Chungbuk Technopark, Nuvoton,
austriamicrosystems

Cortex-M1

Actel ProASIC3, ProASIC3L, IGLOO
and Fusion PSC devices, Altera
Cyclone III, other FPGA products are
also supported

Anexo C
[CPI.C]

43

CAP√çTULO 4.

CONCLUS√ïES

Figura 4.1: C√≥digo fonte utilizado nos testes dos cluster's

44

Anexo D
¬à Kernel adaptado para OMAP:
Comandos para efetuar a clonagem do reposit√≥rio
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6.git
$git checkout 58cf2f1 \\para ir ao ramo correspondente ao kernel 2.6.29 (outros podem ser selecionados,
inclusive mais recentes)
$ make ARCH=arm CROSS-COMPILE=arm-none-guineabi- dist clean \\limpa qualquer congura√ß√£o pr√©via
$ make CROSS_COMPILE=arm-none-linux-gnueabi- omap3_beagle_defcong \\congura o kernel para
se adaptar `a BB
$ make CROSS_COMPILE=arm-none-linux-gnueabi- menucong \\pode ser usado para alterar as confgura√ß√µes padr√£o (inclusive como se deseja construir os m√≥dulos (built-in ou n√£o)
$ make CROSS_COMPILE=arm-none-linux-gnueabi- uImage modules \\gera o kernel na pasta arch/arm/boot/
directory e tamb√©m constr√≥i os m√≥dulos

$ make ARCH=arm CROSS-COMPILE=arm-none-guineabi- INSTALL_MOD_PATH=/segunda/parti√ß√£o/do/cartao_S
modules_install \\instala os m√≥dulos no cart√£o SD
¬à OpenEmbedded
Procedimentos para instala√ß√£o:
$ apt-get install ccache sed wget cvs subversion git-core coreutils unzip texi2html texinfo libsdl1.2-dev
docbook-utils gawk help2man distat gtk-doc-tools le g++ python-psyco minicom build-essential libncurses5dev python-dev python-pysqlite2 quilt mkimage
$ git clone git://git.openembedded.net/openembedded
$ cd openembedded
$ git checkout origin/stable/2009 -b stable/2009
$ git pull \\atualiza o reposit√≥rio git
O arquivo de perl da BB: home/oe/beagleboard/beagleboard/Prole.sh:

45

CAP√çTULO 4.

CONCLUS√ïES

46

export OE_HOME=$HOME/oe
export MY_OE_CONF="beagleboard"

export BBPATH=$OE_HOME/beagleboard/:$OE_HOME/beagleboard/$MY_OE_CONF:$OE_HOME/openembedd
export BBFILES="$OE_HOME/openembedded.org/openembedded/recipes/*/*.bb"
export BB_ENV_EXTRAWHITE="MACHINE DISTRO ANGSTROM_MODE ANGSTROMLIBC OE_HOME"
export PATH=$OE_HOME/openembedded.org/openembedded/bitbake/bin:$PATH
export CVS_TARBALL_STASH="http://oesources.org/sources/current/"
if [ "$PS1" ]; then
if [ "$BASH" ]; then
export PS1="\[\033[01;32m\]OE:$MY_OE_CONF\[\033[00m\] ${PS1}"

 home/oe/beagleboard/beagleboard/conf/local.conf: DISTRO = "angstrom-2008.1"
BBFILES = "/home/saul/oe/openembedded.org/openembedded/recipes/*/*.bb"
TMPDIR = "/home/saul/oe/tmp"
MACHINE = "beagleboard" ENABLE_BINARY_LOCALE_GENERATION = "0"
Obtendo uma imagem linux com o OE:

$ source prole.sh \\ativa as congura√ß√µes relativas √† beagleboard
$ bitbake -b console-image

Anexo E
Congura√ß√£o da porta serial (Serial Port Setup):
$ minicom -s

Figura 4.2: Congurando o minicom para acesso √† BB
ttySX diz respeito a que porta serial est√° conctada a BB (X=0,1...) no caso de adaptadores USB-SERIAL
costuma-se utilizar ttyUSB0.

47

CAP√çTULO 4.

CONCLUS√ïES

48

Ao ligar a BB, a seguinte tela deve ser exibida:

Figura 4.3: Tela da BB j√° no segundo est√°gio de inicializa√ß√£o (u-boot)
Os comando abaixo, s√£o referentes √†s congura√ß√µes necess√°rias ao boot ser dado pelo cart√£o
SD e congura√ß√µes de v√≠deo:

# setenv bootargs 'console=ttyS2,115200n8 console=tty0 root=/dev/mmcblk0p2 rw rootfstype=ext3 rootwait omapfb.video_mode=1024x768MR-16@60'
# setenv bootcmd 'mmcinit; fatload mmc 0 0x80300000 uImage; bootm 0x80300000'
# saveenv
¬à # mmcinit - viabiliza o acesso ao cart√£o SD (dependendo da vers√£o do u-boot pode ser encontrado o
comando mmc init).
¬à # fatload mmc 0 0x80300000 uImage - traz para a posi√ß√£o de mem√≥ria livre 0x80300000 da beagle board
o arquivo uImage localizado no cart√£o de mem√≥ria.
¬à # bootm 0x80300000 - inicializa o sistema operacional que utiliza o cart√£o SD atrav√©s do micro Kernel
copiado para a mem√≥ria da beagle board.
O primeiro boot demorou mais de 15 minutos, provavelmente por algumas alter√ß√µes efetuadas no micro kernel,
al√©m de, claro, ocorrer a descompacta√ß√£o do pr√≥prio micro kernel.

Anexo F
Formatando o Cart√£o SD atrav√©s da ferramenta fdisk

Primeiro foi necess√°rio descobrir qual dispositivo estava relacionado com o cart√£o SD, tarefa simples com o
uso do comando: $ dmesg | tail
sa√≠da:
...
[ 6854.215650] sd 7:0:0:0: [sdc] Mode Sense: 0b 00 00 08
[ 6854.215653] sd 7:0:0:0: [sdc] Assuming drive cache: write
through
[ 6854.215659] sdc: sdc1
[ 6854.218079] sd 7:0:0:0: [sdc] Attached SCSI removable disk
[ 6854.218135] sd 7:0:0:0: Attached scsi generic sg2 type 0
...
$ sudo fdisk /dev/sdc
Deleta-se a parti√ß√£o atual

Command (m for help): [d]
Entra-se no modo expert

Command (m for help): [x]
Altera-se o n√∫mero de cabe√ßas

Expert Command (m for help): [h]
Number of heads (1-256, default xxx): [255]
Altera-se o n√∫mero de setores

Expert Command (m for help): [s]
Number of sectors (1-63, default xxx): [63]
o n√∫mero de cilindros foi obtdio da seguinte maneira:  capacidade do SD (em bytes)/255/63/512
(truncado)

Expert Command (m for help): [c]

49

CAP√çTULO 4.

CONCLUS√ïES

Number of cylinders (1-256, default xxx): [245]
Deixa-se o modo expert

Expert Command (m for help): [r]
Cria-se uma nova parti√ß√£o

Command (m for help): [n]
Command action e extended p primary partition (1-4)
[p]
Partition number (1-4): [1]
First cylinder (1-245, default 1): [<pressione enter>]
Last cylinder or +size or +sizeM or +sizeK (1-245, default 245): [+50]
Marca-se a parti√ß√£o com compatibilidade para DOS

Command (m for help): [t]
Hex code (type L to list codes): [c]
Marca-se a parti√ß√£o como boot√°vel

Command (m for help): [a]
Partition number (1-4): [1]
Cria-se a parti√ß√£o do sistema de arquivos

Command (m for help): [n]
Command action e extended p primary partition (1-4) [p]
Partition number (1-4): [2] First cylinder (52-245, default 52): [<Pressione Enter>]
Last cylinder or +size or +sizeM or +sizeK (52-245, default 245): [<Pressione Enter>]
Command (m for help): [w]
j√° fora do fdisk, formata-se cada uma das pati√ß√µes:

$ sudo mkfs.vfat -n LABEL1 /dev/sdc1
$ sudo mkfs.ext3 -L LABEL2 /dev/sdc2

50

Anexo G

Figura 4.4: Aplica√ß√£o do CI LM7805 como regulador de tens√£o.

51

Refer√™ncias Bibliogr√°cas
[1] Angstrom-Linux (2010). <http://www.angstrom-linux.org> acesso em: 15/05/2010.
[2] Axelson, J. (2003). Embedded ETHERNET and INTERNET Complete Designing and Programming Small

Devices for Networking. Lakeview Research LLC.
[3] Baron, R. J. and Higbie, L. (1992). Computer Architecture. Addilson-Wesley Publishing Company.
[4] CPQD (2010).

<http://www.cpqd.com.br/joomladev/pad-e-inovacao/4530-tecnologias-para-rede-optica-

convergente.html> acesso em: 15/05/2010.
[5] Hennessy, J. L. and Patterson, D. A. (2003). Computer Architecture, 3ed. Morgan Kaufmann Publishers.
[6] IEEE (2005). INSTITUTE OF ELECTRICAL AND ELECTRONIC ENGINEERING - Standard 802.3.
[7] LM7805 (2010). Datasheet <http://www.fairchildsemi.com/ds/lmacesso em: 12/05/2010.
[8] Minoli, D. (2005). A Networking Approach to GRID Computing. John Wiley and Sons.
[9] OpenEmbedded (2010). <http://www.openembedded.org> acesso em: 15/05/2010.
[10] Tanenbaum, A. S. (1996). Computer Networks, 3ed. Prentice Hall.
[11] Tanenbaum, A. S. (2008). Modern Operating Systems. Pearson Prentice Hall.
[12] TexasInstruments (2010). Omap3 <http://focus.ti.com/docs/prod/folders/print/omap3530.html> acesso
em: 15/05/2010.
[13] Wikipedia (2010a). Arm <http://en.wikipedia.org/wiki/arm_architecture> acesso em: 15/05/2010.
[14] Wikipedia (2010b).

Mpi <http://en.wikipedia.org/wiki/message_passing_interface> acesso em:

10/05/2010.
[15] Wikipedia (2010c). Usb <http://en.wikipedia.org/wiki/universal_serial_bus> acesso em: 15/05/2010.

52

