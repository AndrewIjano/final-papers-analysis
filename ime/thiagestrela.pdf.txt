Universidade de SÃ£o Paulo
Instituto de MatemÃ¡tica e EstatÃ­stica
Bacharelado em CiÃªncia da ComputaÃ§Ã£o

Emparelhamentos estÃ¡veis
em grafos de preferÃªncias

Thiago Estrela Montenegro

Monografia Final
mac 499 â€” Trabalho de
Formatura Supervisionado

Supervisor: Prof. Dr. Carlos Eduardo Ferreira

SÃ£o Paulo
20 de novembro de 2019

Resumo
Thiago Estrela Montenegro. Emparelhamentos estÃ¡veis em grafos de preferÃªncias. Monografia (Bacharelado). Instituto de MatemÃ¡tica e EstatÃ­stica, Universidade de SÃ£o Paulo, SÃ£o
Paulo, 2019.

Emparelhamentos em grafos Ã© um tema muito abordado em ciÃªncia da computaÃ§Ã£o, sobretudo
pela sua riqueza em modelar uma grande variedade de problemas de natureza prÃ¡tica. Quando
consideramos que cada vÃ©rtice ordena os seus vizinhos segundo uma ordem de preferÃªncia, dÃ¡se origem ao conceito de um grafo de preferÃªncias. Nesse pano de fundo, em vÃ¡rios problemas,
emparelhamentos com a propriedade que existam dois vÃ©rtices que prefiram a si prÃ³prios
do que os seus parceiros sÃ£o indesejÃ¡veis, jÃ¡ que eles seriam instÃ¡veis em um certo sentido.
Assim, surge o conceito de emparelhamento estÃ¡vel, que Ã© um emparelhamento que nÃ£o
apresenta essa propriedade. O presente trabalho consiste de um estudo de natureza algorÃ­tmica
e matemÃ¡tica da classe dos emparelhamentos estÃ¡veis. No primeiro capÃ­tulo, nos restringimos
a grafo de preferÃªncias bipartidos. Nele, descrevemos o algoritmo de Gale-Shapley que em
tempo linear encontra um emparelhamento estÃ¡vel e, alÃ©m disso, abordamos outros conceitos
que julgamos essenciais. No capÃ­tulo seguinte, abordamos o algoritmo de Irving que decide,
em tempo linear, a existÃªncia de um emparelhamento estÃ¡vel e devolve um em caso positivo.
Palavras-chave: emparelhamentos estÃ¡veis, grafos de preferÃªncias, Gale-Shapley, Irving.

iii

SumÃ¡rio
1 IntroduÃ§Ã£o
1.1 MotivaÃ§Ã£o . . . . . . . .
1.2 NoÃ§Ãµes preliminares . . .
1.2.1 ConvenÃ§Ãµes . . .
1.2.2 Teoria dos Grafos

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

1
1
2
2
2

2 Emparelhamentos EstÃ¡veis em Grafos Bipartidos
2.1 Algoritmo de Gale-Shapley . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 Exemplo de execuÃ§Ã£o do algoritmo . . . . . . . . . . . . . . . . .
2.1.2 Corretude do algoritmo . . . . . . . . . . . . . . . . . . . . . . .
2.1.3 Consumo de tempo do algoritmo . . . . . . . . . . . . . . . . . .
2.2 Emparelhamentos A-Ã³timos . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.1 Algoritmo estendido de Gale-Shapley . . . . . . . . . . . . . . . .
2.3 Teorema dos hospitais rurais . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Estrutura AlgÃ©brica dos Emparelhamentos EstÃ¡veis . . . . . . . . . . . .
2.4.1 Terminologia bÃ¡sica de teoria da ordem . . . . . . . . . . . . . .
2.4.2 O conjunto dos emparelhamentos estÃ¡veis Ã© um reticulado distributivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

20

3 Emparelhamentos EstÃ¡veis em Grafos Quaisquer
3.1 Algoritmo de Irving . . . . . . . . . . . . . . . . . . .
3.1.1 Primeira etapa . . . . . . . . . . . . . . . . .
3.1.2 Teorema dos hospitais rurais generalizado . .
3.1.3 Preliminares para a segunda etapa . . . . . .
3.1.4 Segunda etapa . . . . . . . . . . . . . . . . . .
3.1.5 Exemplo de execuÃ§Ã£o do algoritmo de Irving .

25
26
26
30
31
35
36

4 ConclusÃ£o

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

5
6
7
8
9
10
12
14
19
19

41

iv

ApÃªndices
Anexos

ReferÃªncias

43

1

CapÃ­tulo 1
IntroduÃ§Ã£o
1.1

MotivaÃ§Ã£o

A motivaÃ§Ã£o para o presente trabalho advÃ©m dos dois seguintes problemas.
1. O Problema do Casamento EstÃ¡vel. O problema consiste em parear cada um de
ğ‘› homens com cada uma de ğ‘› mulheres de modo que nÃ£o haja um homem e uma
mulher que preferem um ao outro do que os seus parceiros. Posteriormente, veremos
que esse problema pode ser visto como o de achar um emparelhamento estÃ¡vel em
um grafo de preferÃªncias bipartido. Gale e Shapley [4] provaram que esse problema
sempre possui soluÃ§Ã£o e descreveram um algoritmo que o resolve. Tal algoritmo
passou a ser conhecido por algoritmo de Gale-Shapley.
2. O Problema dos Colegas de Quarto. Temos ğ‘› quartos e 2ğ‘› pessoas. Cada quarto
acomoda no mÃ¡ximo 2 pessoas. O Problema consiste em acomodar as 2ğ‘› pessoas
nesses ğ‘› quartos de modo que nÃ£o existam duas pessoas acomodadas em quartos diferentes que prefiram um ao outro aos seus parceiros. Tal problema pode ser encarado
como o de achar um emparelhamento estÃ¡vel em um grafo de preferÃªncias arbitrÃ¡rio.
Diferente do caso do problema anterior, tal emparelhamento nem sempre existe.
Irving [5] formulou um algoritmo que determina a existÃªncia de um emparelhamento
estÃ¡vel e, caso exista, devolve um.
Apesar de, a primeira vista, parecerem modelar problemas muito especÃ­ficos, tais
problemas modelam muitas outras situaÃ§Ãµes de natureza prÃ¡tica. Dentre elas, podemos
citar: processos seletivos de admissÃ£o Ã  universidades, seleÃ§Ã£o de residentes por hospitais
e alocaÃ§Ã£o de doadores de Ã³rgÃ£os a pacientes necessitando de um transplante.
AlÃ©m da riqueza de aplicaÃ§Ãµes prÃ¡ticas, hÃ¡ algoritmos lineares para resoluÃ§Ã£o de ambos
os problemas que, embora sofisticados, se utilizam de conceitos elementares normalmente
encontrados no currÃ­culo de uma graduaÃ§Ã£o em CiÃªncia da ComputaÃ§Ã£o. Isso torna o
presente material uma Ã³tima oportunidade para graduandos testarem e aprofundarem os
seus conhecimentos na Ã¡rea de Algoritmos.
O presente trabalho consiste de um estudo de natureza puramente matemÃ¡tica. Buscouse definir os conceitos matemÃ¡ticos e terminologias na medida em que sÃ£o necessÃ¡rios.

2
1 | INTRODUÃ‡ÃƒO

Isso evita sobrecarregar o inÃ­cio do texto com conteÃºdo que, muitas vezes, sÃ³ seria referido
num momento bem posterior.
No primeiro capÃ­tulo, introduzimos os conceitos de grafo de preferÃªncias e de emparelhamento estÃ¡vel. Em seguida, descrevemos o chamado algoritmo de Gale-Shapley que dado
um grafo de preferÃªncias bipartido, devolve um emparelhamento estÃ¡vel e, prosseguimos,
provando sua corretude e analisando o seu consumo de tempo. Na seÃ§Ã£o seguinte, provamos
que o emparelhamento devolvido pelo algoritmo possui algumas propriedades especiais
e, aproveitamos, para descrever uma versÃ£o "estendida"do algoritmo de Gale-Shapley.
Posteriormente, provamos de modo rigoroso um resultado importante para Ã¡rea, o teorema
dos hospitais rurais. Encerramos o capÃ­tulo, provando que o conjunto dos emparelhamentos
estÃ¡veis de um grafo de preferÃªncias forma um reticulado distributivo.
No segundo capÃ­tulo, estamos interessados em resolver o problema de encontrar um
emparelhamento estÃ¡vel em um grafo de preferÃªncias arbitrÃ¡rio (nÃ£o necessariamente
bipartido). Mostramos que, diferentemente do caso bipartido, existem instÃ¢ncias que nÃ£o
apresentam emparelhamentos estÃ¡veis. Prosseguimos descrevendo o chamado algoritmo
de Irving, que decide em tempo linear se um grafo de preferÃªncias apresenta um emparelhamento (e devolve um, em caso positivo). Encerramos o capÃ­tulo, providenciando uma
prova completa e detalhada de sua corretude.

1.2
1.2.1

NoÃ§Ãµes preliminares
ConvenÃ§Ãµes

â€¢ ğ´ â§µ ğµ refere-se ao conjunto {ğ‘¥ âˆˆ ğ´ âˆ¶ ğ‘¥ âˆ‰ ğµ }.
â€¢ ğ´ Ã— ğµ Ã© o produto cartesiano de ğ´ por ğµ.
â€¢ |ğ´| Ã© a cardinalidade do conjunto ğ´.
â€¢ Um ğ‘˜-conjunto Ã© um conjunto de cardinalidade ğ‘˜. Similarmente, um ğ‘˜-subconjunto
de um conjunto ğ´ Ã© um subconjunto de ğ´ de cardinalidade ğ‘˜.

1.2.2

Teoria dos Grafos

Esta seÃ§Ã£o contÃ©m o prÃ©-requisito essencial de Teoria dos Grafos para o entendimento
do presente texto. Para os leitores em busca de uma referÃªncia mais completa, recomenda-se
[1].
Um grafo (nÃ£o-direcionado) Ã© um par ordenado ğº = (ğ‘‰ , ğ¸) onde ğ‘‰ (ğº) âˆ¶= ğ‘‰ Ã© um conjunto nÃ£o-vazio enumerÃ¡vel e ğ¸(ğº) âˆ¶= ğ¸ Ã© um conjunto cujos elementos sÃ£o 2-subconjuntos
de ğ‘‰ . Os elementos de ğ‘‰ sÃ£o denominados de vÃ©rtices e os elementos de ğ¸ sÃ£o chamados
de arestas.
Seja ğ‘’ = {ğ‘, ğ‘} uma aresta de um grafo ğº. Denotamos ğ‘’ por ğ‘ğ‘ (= ğ‘ğ‘). Nesse caso,
dizemos que ğ‘ e ğ‘ sÃ£o extremos de ğ‘’ e que ğ‘ e ğ‘ sÃ£o vÃ©rtices adjacentes ou vizinhos.
Um grafo direcionado Ã© um par ordenado ğº = (ğ‘‰ , ğ¸) onde ğ‘‰ (ğº) âˆ¶= ğ‘‰ Ã© um conjunto
nÃ£o-vazio enumerÃ¡vel e ğ¸(ğº) âˆ¶= ğ¸ Ã© um conjunto de pares ordenados de elementos distin-

3
1.2 | NOÃ‡Ã•ES PRELIMINARES

tos de ğ‘‰ . Os elementos de ğ‘‰ sÃ£o denominados nÃ³s e os elementos de ğ¸ sÃ£o denominados
de arcos.
Seja ğ‘’ = (ğ‘, ğ‘) um arco de um grafo direcionado ğº. Denotamos ğ‘’ por ğ‘ğ‘. Nesse caso,
dizemos que ğ‘ Ã© adjacente ou vizinho a ğ‘. Note que, diferentemente do caso nÃ£o-direcionado,
nÃ£o necessariamente temos que ğ‘ Ã© adjacente a ğ‘, jÃ¡ que (ğ‘, ğ‘) â‰  (ğ‘, ğ‘).
Seja ğº um grafo que pode ser direcionado ou nÃ£o. Um passeio de comprimento
ğ‘˜ â‰¥ 0 em ğº Ã© uma sequÃªncia finita ğ‘ƒ âˆ¶= (ğ‘£0 , ğ‘’1 , ğ‘£1 , ğ‘’2 , ..., ğ‘’ğ‘˜ , ğ‘£ğ‘˜ ) onde ğ‘£ğ‘– âˆˆ ğ‘‰ (ğº) para todo
ğ‘– âˆˆ {0, ..., ğ‘˜} e ğ‘’ğ‘– âˆˆ ğ¸(ğº) Ã© tal que ğ‘’ğ‘– = ğ‘£ğ‘–âˆ’1 ğ‘£ğ‘– para todo ğ‘– âˆˆ {1, ..., ğ‘˜}. Quando ğ‘£0 = ğ‘£ğ‘˜
dizemos que ğ‘ƒ Ã© fechado. No caso em que os ğ‘’ğ‘– â€™s sÃ£o distintos dois a dois, dizemos que ğ‘ƒ
Ã© uma trilha. Quando os ğ‘£ğ‘– â€™s sÃ£o distintos dois a dois, dizemos que ğ‘ƒ Ã© um caminho. Ã‰
fÃ¡cil ver que todo caminho Ã© uma trilha. Finalmente, dizemos que ğ‘ƒ Ã© um circuito quando
Ã© uma trilha fechada e os vÃ©rtices diferentes de ğ‘£0 e ğ‘£ğ‘˜ sÃ£o distintos dois a dois. Em geral,
escrevemos a sequÃªncia de vÃ©rtices (ou nÃ³s) (ğ‘£0 , ..., ğ‘£ğ‘˜ ) para indicar ğ‘ƒ, jÃ¡ que a sequÃªncia
de vÃ©rtices (ou nÃ³s) determina unicamente ğ‘ƒ.
Seja ğº = (ğ‘‰ , ğ¸) um grafo e ğ´ um conjunto de arestas. Denotamos por ğº âˆ’ ğ´ o grafo
obtido de ğº ao se remover as arestas do conjunto ğ´. Formalmente, ğº â§µ ğ´ Ã© o grafo dado
por ğ‘‰ (ğº â§µ ğ´) âˆ¶= ğ‘‰ (ğº) e ğ¸(ğº â§µ ğ´) âˆ¶= ğ¸(ğº) â§µ ğ´.
Seja ğº um grafo e ğ‘€ um conjunto de arestas de ğº. Dizemos que ğ‘€ Ã© um emparelhamento em ğº quando cada vÃ©rtice ğ‘£ de ğº Ã© extremo de no mÃ¡ximo uma aresta de ğ‘€. Todo
vÃ©rtice ğ‘£ que Ã© extremo de uma aresta de ğ‘€ Ã© dito coberto por ğ‘€.
Uma bipartiÃ§Ã£o de um grafo ğº Ã© um par de conjuntos (ğ´, ğµ) tais que ğ´ âˆª ğµ = ğ‘‰ (ğº)
e ğ´ âˆ© ğµ = âˆ…. Dizemos que ğº Ã© bipartido quando admite uma bipartiÃ§Ã£o. Escrevemos
ğº = (ğ´ âˆª ğµ, ğ¸) para indicar que ğº Ã© um grafo e (ğ´, ğµ) Ã© uma bipartiÃ§Ã£o de ğº.

5

CapÃ­tulo 2
Emparelhamentos EstÃ¡veis em
Grafos Bipartidos
Nosso estudo dos emparelhamentos estÃ¡veis tem como pano de fundo o estudo de
grafos. Note que a estrutura de um grafo nÃ£o Ã© suficiente para modelar os problemas
abordados no CapÃ­tulo 1. Uma parte essencial de tais problemas Ã© a noÃ§Ã£o de preferÃªncia
entre agentes. Portanto, faz-se necessÃ¡rio considerar grafos com uma estrutura adicional,
a qual chamaremos de listas de preferÃªncias.
Seja ğº = (ğ‘‰ , ğ¸) um grafo. Para cada vÃ©rtice ğ‘£, uma lista de preferÃªncias de ğ‘£ Ã© uma
ordenaÃ§Ã£o total ğ¿ğ‘£ das arestas incidentes a ğ‘£. Se todo vÃ©rtice de ğ‘£ possui uma lista de
preferÃªncias, ğº = (ğ‘‰ , ğ¸, ğ¿) Ã© denominado um grafo de preferÃªncias, onde ğ¿ Ã© o conjunto
de todas as listas de preferÃªncias de ğº. Note que uma ordenaÃ§Ã£o total das arestas incidentes
a um vÃ©rtice ğ‘£ corresponde, de modo natural, Ã  uma ordenaÃ§Ã£o dos vizinhos de ğ‘£. De fato,
dado um vÃ©rtice ğ‘£ e dois vÃ©rtices ğ‘, ğ‘ vizinhos de ğ‘£, diremos que ğ‘£ prefere ğ‘ a ğ‘ se ğ‘£ prefere
a aresta ğ‘£ğ‘ Ã  aresta ğ‘£ğ‘ em relaÃ§Ã£o Ã  ordenaÃ§Ã£o total ğ¿ğ‘£ . Se ğ‘£ prefere ğ‘ a ğ‘ em relaÃ§Ã£o a ğ¿ğ‘£ ,
escreveremos que ğ‘ >ğ¿ğ‘£ ğ‘ ou, quando ğ¿ estiver subentendido, ğ‘ >ğ‘£ ğ‘. Finalmente, dado um
vÃ©rtice ğ‘£ de ğº e um vizinho ğ‘ de ğ‘£ em ğº, o ğ‘£-ğ‘ğ‘œğ‘ ğ‘¡ğ‘œ de ğ‘ Ã© a posiÃ§Ã£o que ğ‘ ocupa na lista
de preferÃªncias de ğ‘£. Mais precisamente, o ğ‘£-ğ‘ğ‘œğ‘ ğ‘¡ğ‘œ de ğ‘ Ã© |{ğ‘¥ âˆˆ ğ‘ (ğ‘£); ğ‘¥ >ğ‘£ ğ‘}| + 1. Por
exemplo, se ğ‘ Ã© o vizinho preferido de ğ‘£, seu ğ‘£-ğ‘ğ‘œğ‘ ğ‘¡ğ‘œ Ã© 1.
Sejam ğº = (ğ‘‰ , ğ¸, ğ¿) e ğ» = (ğ‘‰ â€² , ğ¸ â€² , ğ¿â€² ) grafos de preferÃªncias. Dizemos que ğ» Ã© subgrafo
de preferÃªncias de ğº quando:
1. ğ» Ã© subgrafo de ğº.
2. Para quaisquer vÃ©rtices ğ‘¢, ğ‘£, ğ‘¤ âˆˆ ğ‘‰ â€² tem-se que ğ‘¢ <ğ¿â€²ğ‘¤ ğ‘£ âŸº ğ‘¢ <ğ¿ğ‘¤ ğ‘£.
Seja ğ‘€ um emparelhamento de ğº = (ğ‘‰ , ğ¸, ğ¿). Para cada vÃ©rtice ğ‘£ coberto por ğ‘€,
defina ğ‘€(ğ‘£) como o seu parceiro em ğ‘€. Agora considere ğ‘¥ğ‘¦ âˆ‰ ğ‘€. Dizemos que ğ‘¥ğ‘¦ Ã©
uma aresta bloqueadora de ğ‘€ se ğ‘¥ e ğ‘¦ preferem um ao outro do que os seus parceiros
(caso hajam). Formalmente, ğ‘¥ğ‘¦ Ã© uma aresta bloqueadora de ğ‘€ se satisfizer as 3 seguintes
condiÃ§Ãµes:
1. ğ‘¥ğ‘¦ âˆ‰ ğ‘€.

6
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

2. ğ‘¥ nÃ£o Ã© coberto por ğ‘€ ou ğ‘¥ prefere ğ‘¦ a ğ‘€(ğ‘¥).
3. ğ‘¦ nÃ£o Ã© coberto por ğ‘€ ou ğ‘¦ prefere ğ‘¥ a ğ‘€(ğ‘¦).
Seja ğ‘€ um emparelhamento de ğº = (ğ‘‰ , ğ¸, ğ¿). ğ‘€ Ã© chamado de emparelhamento
estÃ¡vel se nenhuma aresta bloqueia ğ‘€. Vale notar que todo emparelhamento estÃ¡vel ğ‘€
Ã© maximal. De fato, se existisse uma aresta que pudesse ser adicionada a ğ‘€ de modo a
tornÃ¡-lo um emparelhamento estÃ¡vel ainda maior, tal aresta bloquearia ğ‘€.
ğ‘1

ğ‘1

ğ‘1 âˆ¶ ğ‘1
ğ‘2 âˆ¶ ğ‘1 ğ‘2

ğ‘2

ğ‘2

ğ‘1 âˆ¶ ğ‘2 ğ‘1
ğ‘2 âˆ¶ ğ‘2

Figura 2.1: Considere o grafo de preferÃªncias definido por meio da figura acima, onde Ã  direita
estÃ£o indicadas as listas de preferÃªncias de cada vÃ©rtice em ordem decrescente de preferÃªncia (por
exemplo, ğ‘2 prefere ğ‘1 a ğ‘2 ). Note que a aresta ğ‘2 ğ‘1 bloqueia ğ‘€1 = {ğ‘1 ğ‘1 , ğ‘2 ğ‘2 } jÃ¡ que ğ‘2 prefere ğ‘1
a ğ‘2 = ğ‘€1 (ğ‘2 ) e ğ‘1 prefere ğ‘2 a ğ‘1 = ğ‘€1 (ğ‘1 ). Por outro lado, embora ğ‘€2 = {ğ‘2 ğ‘1 } nÃ£o cubra nem ğ‘1 e
nem ğ‘2 , ele Ã© um emparelhamento estÃ¡vel. De fato, ğ‘1 prefere ğ‘2 a ğ‘1 e ğ‘2 prefere ğ‘1 a ğ‘2 , de modo
que nem ğ‘1 ğ‘1 e nem ğ‘2 ğ‘2 bloqueiam ğ‘€2 .

Iremos, inicialmente, considerar o caso particular onde as instÃ¢ncias envolvem grafos
bipartidos. Em tais instÃ¢ncias, Gale e Shapley provaram a existÃªncia de ao menos um
emparelhamento estÃ¡vel. Mais do que isso, eles formularam um algoritmo que, dado como
entrada um grafo de preferÃªncias bipartido, devolve um emparelhamento estÃ¡vel [4].
O Problema do Casamento EstÃ¡vel consiste em achar um emparelhamento estÃ¡vel em
um grafo bipartido com lista de preferÃªncias ğº = (ğ´ âˆª ğµ, ğ¸, ğ¿). ğ‘ğ‘ Ã© uma aresta de ğº se ğ‘ e ğ‘
consideram um ao outro como possÃ­veis parceiros (isto Ã©, ğ‘ pertence Ã  lista de preferÃªncias
de ğ‘ e vice-versa). o algoritmo de Gale-Shapley (descrito na seÃ§Ã£o a seguir), em particular,
prova o seguinte teorema.
Teorema 1. Qualquer grafo de preferÃªncias bipartido possui ao menos um emparelhamento
estÃ¡vel.

2.1

Algoritmo de Gale-Shapley

Seja ğº = (ğ´âˆªğµ, ğ¸, ğ¿) um grafo de preferÃªncias bipartido. Podemos descrever o algoritmo
da seguinte forma. Em sequÃªncia, cada vÃ©rtice ğ‘ de ğ´ nÃ£o emparelhado faz um pedido para
se emparelhar com o seu vizinho favorito ğ‘ dentre os vÃ©rtices que ainda nÃ£o rejeitaram ğ‘.
Note que dizemos que um vÃ©rtice ğ‘£ rejeitou um vÃ©rtice ğ‘¤ quando, ou ğ‘£ rejeitou o pedido
de ğ‘¤ para se emparelhar com ele, ou ğ‘£ desfez o emparelhamento com ğ‘¤. Se ğ‘ nÃ£o estÃ¡
emparelhado ou se ğ‘ estÃ¡ emparelhado a um vÃ©rtice ğ‘ mas ğ‘ >ğ‘ ğ‘, ğ‘ aceita o pedido de ğ‘;
Se ğ‘ estava emparelhado a ğ‘, ele rejeita ğ‘ o tornando nÃ£o emparelhado. Em qualquer outro
caso, ğ‘ rejeita a proposta de ğ‘. Tal vÃ©rtice ğ‘ entÃ£o faz um pedido para o seu prÃ³ximo vizinho
preferido. Esse processo para quando, para cada vÃ©rtice ğ‘ de ğº, ou ğ‘ estÃ¡ emparelhado ou
ğ‘ fez pedidos para todos os seus vizinhos.

7
2.1 | ALGORITMO DE GALE-SHAPLEY

O pseudocÃ³digo a seguir formaliza a descriÃ§Ã£o anterior.
Algoritmo 1: Gale-Shapley
Entrada: Um grafo de preferÃªncias bipartido ğº = (ğ‘‰ = ğ´ âˆª ğµ, ğ¸, ğ¿)
SaÃ­da: Um emparelhamento estÃ¡vel ğ‘€ de ğº
1 inÃ­cio
2
FaÃ§a ğ‘€ âˆ¶= âˆ…
3
para cada ğ‘£ âˆˆ ğ‘‰ faÃ§a
4
ğ‘ƒ(ğ‘£) âˆ¶= ğ¿ğ‘£
enquanto existe ğ‘ âˆˆ ğ´ nÃ£o coberto por ğ‘€ tal que ğ‘ƒ(ğ‘) â‰  âˆ… faÃ§a
Seja ğ‘ o vizinho preferido de ğ‘ em ğ‘ƒ(ğ‘)
se ğ‘ nÃ£o Ã© coberto por ğ‘€ entÃ£o
ğ‘€ âˆ¶= ğ‘€ âˆª {ğ‘ğ‘}

5
6
7
8

11

senÃ£o se ğ‘ >ğ‘ ğ‘€(ğ‘) entÃ£o
ğ‘€ âˆ¶= ğ‘€ â§µ {ğ‘€(ğ‘)ğ‘}
ğ‘€ âˆ¶= ğ‘€ âˆª {ğ‘ğ‘}

12

ğ‘ƒ(ğ‘) âˆ¶= ğ‘ƒ(ğ‘) â§µ {ğ‘}

9
10

retorna M

13

2.1.1

Exemplo de execuÃ§Ã£o do algoritmo

Para facilitar a compreensÃ£o, consideremos a execuÃ§Ã£o do algoritmo para alguns
exemplos de entrada. Nos exemplos abaixo, "ğ‘¥ â†’ ğ‘¦"significa que o vÃ©rtice x fez um pedido
para o vÃ©rtice y.
ğ‘1

ğ‘1

ğ‘2

ğ‘2

ğ‘3

ğ‘3

ğ‘4

ğ‘4

ğ‘1
ğ‘2
ğ‘3
ğ‘4

âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘4 ğ‘3 ğ‘1 ğ‘2
ğ‘2 ğ‘3 ğ‘4 ğ‘1
ğ‘4 ğ‘1 ğ‘3 ğ‘2
ğ‘2 ğ‘1 ğ‘4 ğ‘2

ğ‘1
ğ‘2
ğ‘3
ğ‘4

âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘2 ğ‘3 ğ‘4 ğ‘1
ğ‘4 ğ‘2 ğ‘3 ğ‘1
ğ‘2 ğ‘1 ğ‘3 ğ‘4
ğ‘3 ğ‘1 ğ‘2 ğ‘4

Figura 2.2

Exemplo 2.1.1. Se o grafo da figura acima Ã© dado como entrada, uma possÃ­vel execuÃ§Ã£o Ã©
a seguinte:
â€¢ ğ‘1 â†’ ğ‘4 , ğ‘2 â†’ ğ‘2 ; Como ğ‘4 e ğ‘2 nÃ£o estavam emparelhados, cada um deles se
emparelha com o seu respectivo vÃ©rtice.
â€¢ ğ‘3 â†’ ğ‘4 ; Como ğ‘4 prefere ğ‘3 a ğ‘1 , ele rejeita ğ‘1 e se emparelha com ğ‘3 .

8
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

â€¢ ğ‘1 â†’ ğ‘3 ; Como ğ‘3 nÃ£o estava emparelhado, ele se emparelha com ğ‘1 .
â€¢ ğ‘4 â†’ ğ‘2 ; Como ğ‘2 prefere ğ‘4 a ğ‘2 , ele desfaz o seu emparelhamento com ğ‘2 e se
emparelha com ğ‘4 .
â€¢ ğ‘2 â†’ ğ‘3 ; Como ğ‘3 prefere ğ‘2 a ğ‘1 , ele desfaz o seu emparelhamento com ğ‘1 e se
emparelha com ğ‘2 .
â€¢ ğ‘1 â†’ ğ‘1 ; Como ğ‘1 nÃ£o estava emparelhado, ele se emparelha com ğ‘1 .
â€¢ Como todos os vÃ©rtices estÃ£o emparelhados, a execuÃ§Ã£o se encerra devolvendo o
emparelhamento ğ‘€ = {ğ‘1 ğ‘1 , ğ‘2 ğ‘3 , ğ‘3 ğ‘4 , ğ‘4 ğ‘2 } (Ã© possÃ­vel verificar que toda aresta
fora de ğ‘€ nÃ£o Ã© bloqueadora de modo que ğ‘€ Ã© estÃ¡vel).
Exemplo 2.1.2. Consideremos como entrada o grafo da figura acima trocando-se os papÃ©is
de {ğ‘1 , ğ‘2 , ğ‘3 , ğ‘4 } e {ğ‘1 , ğ‘2 , ğ‘3 , ğ‘4 }, de modo que, agora sÃ£o os vÃ©rtices ğ‘ğ‘– â€™s que fazem os
pedidos e os ğ‘ğ‘– â€™s quem recebem (isto Ã©, considere que ğ´ = {ğ‘ğ‘–â€² ğ‘ } e ğµ = {ğ‘ğ‘–â€² ğ‘ }). Nesse caso,
uma possÃ­vel execuÃ§Ã£o seria:
â€¢ ğ‘1 â†’ ğ‘2 , ğ‘2 â†’ ğ‘4 ; Como ğ‘2 e ğ‘4 nÃ£o estavam emparelhados, cada um deles aceita o
seu respectivo pedido.
â€¢ ğ‘3 â†’ ğ‘2 ; Como ğ‘2 prefere ğ‘3 a ğ‘1 , ğ‘2 desfaz o seu emparelhamento com ğ‘1 e se
emparelha com ğ‘3 .
â€¢ ğ‘1 â†’ ğ‘3 ; Como ğ‘3 nÃ£o estava emparelhado, ele se emparelha com ğ‘1 .
â€¢ ğ‘4 â†’ ğ‘3 ; Como ğ‘3 prefere ğ‘4 a ğ‘1 , ele desfaz o seu emparelhamento com ğ‘1 e se
emparelha com ğ‘4 .
â€¢ ğ‘1 â†’ ğ‘4 ; Como ğ‘4 prefere ğ‘2 a ğ‘1 , ele desfaz o seu emparelhamento com ğ‘1 .
â€¢ ğ‘1 â†’ ğ‘1 ; Como ğ‘1 nÃ£o estava emparelhado, ele se emparelha com ğ‘1 .
â€¢ Como todos os vÃ©rtices estÃ£o emparelhados, a execuÃ§Ã£o se encerra devolvendo o
emparelhamento ğ‘€ = {ğ‘1 ğ‘1 , ğ‘2 ğ‘3 , ğ‘3 ğ‘4 , ğ‘4 ğ‘2 } (Ã© possÃ­vel verificar que toda aresta
fora de ğ‘€ nÃ£o Ã© bloqueadora de modo que ğ‘€ Ã© estÃ¡vel).
Note que o emparelhamento obtido neste exemplo Ã© idÃªntico ao obtido no exemplo anterior.
No entanto, isso foi acidental. Como serÃ¡ provado na seÃ§Ã£o 2.2, em geral, o emparelhamento obtido Ã© tal que cada vÃ©rtice de ğ´ estÃ¡ com o seu melhor parceiro possÃ­vel em um
emparelhamento estÃ¡vel e cada vÃ©rtice de ğµ estÃ¡ com o seu pior parceiro possÃ­vel. Usando
esse fato, segue imediatamente que o grafo da figura 2.2 possui um Ãºnico emparelhamento
estÃ¡vel.

2.1.2

Corretude do algoritmo

O passo inicial Ã© provar a corretude do algoritmo.
Teorema 2. O algoritmo de Gale-Shapley termina devolvendo um emparelhamento estÃ¡vel.
DemonstraÃ§Ã£o. Seja ğº = (ğ´ âˆª ğµ, ğ‘‰ , ğ¿) o grafo de preferÃªncias dado como entrada para o
algoritmo de Gale-Shapley. Primeiramente, provemos que o algoritmo termina. De fato,

9
2.1 | ALGORITMO DE GALE-SHAPLEY

cada iteraÃ§Ã£o do bloco enquanto que compreende as linhas 5 Ã  12, remove um elemento
de ğ‘ƒ(ğ‘) para algum vÃ©rtice ğ‘ de ğº. Como, para cada vÃ©rtice ğ‘ de ğº, ğ‘ƒ(ğ‘) foi inicializado
como ğ¿ğ‘ que Ã© um conjunto finito, apÃ³s uma quantidade finita de iteraÃ§Ãµes, a condiÃ§Ã£o do
laÃ§o nÃ£o serÃ¡ mais satisfeita.
Agora, seja ğ‘€ âˆ— o conjunto de arestas devolvido pelo algoritmo quando ğº Ã© dado
como entrada. Note que, ğ‘€ âˆ— Ã© inicializado como o conjunto vazio, que Ã©, trivialmente,
um emparelhamento. Assim, basta provar que se ğ‘€ Ã© um emparelhamento antes de uma
iteraÃ§Ã£o do laÃ§o enquanto, ele serÃ¡ um emparelhamento ao final da iteraÃ§Ã£o. Sejam ğ‘
e ğ‘ definidos conforme o algoritmo nas suas linhas 5 e 6, respectivamente. Se ğ‘ nÃ£o Ã©
coberto por ğ‘€, entÃ£o claramente ğ‘€ âˆª {ğ‘ğ‘} Ã© um emparelhamento, pois ğ‘, por definiÃ§Ã£o,
nÃ£o Ã© coberto por ğ‘€. Se ğ‘ Ã© tal que ğ‘ >ğ‘ ğ‘€(ğ‘), ğ‘€ â§µ {ğ‘€(ğ‘)ğ‘} Ã© um emparelhamento, pois
estamos apenas removendo uma aresta do emparelhamento. Note que ğ‘ nÃ£o Ã© coberto por
ğ‘€ â§µ {ğ‘€(ğ‘)ğ‘}, e assim, por um argumento anÃ¡logo ao do caso anterior, concluÃ­mos que
(ğ‘€ â§µ {ğ‘€(ğ‘)ğ‘}) âˆª {ğ‘ğ‘} Ã© um emparelhamento. Isso prova que ğ‘€ âˆ— Ã© um emparelhamento.
Resta-nos provar que ğ‘€ âˆ— Ã© um emparelhamento estÃ¡vel. Suponha, por absurdo, que
exista uma aresta ğ‘ğ‘ que bloqueia ğ‘€ âˆ— . EntÃ£o, ou existe ğ‘ âˆˆ ğ´ que fez um pedido a ğ‘ durante
o algoritmo tal que ğ‘ >ğ‘ ğ‘ ou ğ‘ nunca recebeu uma proposta de ğ‘. Note que se ğ‘ recebeu
um pedido, Ã© garantido que ele estarÃ¡ emparelhado ao final do algoritmo (isto Ã©, ğ‘ Ã© coberto
por ğ‘€ âˆ— ) e ele sÃ³ rejeitarÃ¡ um pedido em razÃ£o de um pedido melhor. Isso implica que, se ğ‘
recebeu um pedido, entÃ£o ğ‘, ao final do algoritmo, estarÃ¡ emparelhado com um ğ‘‘ âˆˆ ğ´ tal
que ğ‘‘ â‰¥ğ‘ ğ‘ > ğ‘ e, assim, ğ‘ğ‘ nÃ£o Ã© aresta bloqueadora. Suponha entÃ£o que ğ‘ nunca recebeu
uma proposta de ğ‘. Isso sÃ³ pode acontecer se ğ‘, durante o algoritmo, fez um pedido Ã  um
vÃ©rtice ğ‘ âˆˆ ğµ e nÃ£o foi rejeitado. Implicando que ğ‘ğ‘ âˆˆ ğ‘€ âˆ— e, como cada vÃ©rtice de ğ´ faz as
propostas em ordem decrescente de preferÃªncia, ğ‘ >ğ‘ ğ‘, o que contradiz o fato de ğ‘ğ‘ ser
uma aresta bloqueadora. Isso encerra a demonstraÃ§Ã£o.

2.1.3

Consumo de tempo do algoritmo

Para realizarmos uma anÃ¡lise do consumo de tempo do algoritmo de Gale-Shapley,
devemos fazer algumas consideraÃ§Ãµes iniciais. Primeiramente, consideramos que a entrada
do algoritmo de Gale-Shapley serÃ¡ especificada por um vetor ğ¿ğ‘£ para cada vÃ©rtice ğ‘£ do
grafo ğº tal que:
ğ¿ğ‘£ [ğ‘–] = ğ‘¢ âŸº ğ‘¢ ocupa a ğ‘–-Ã©sima posiÃ§Ã£o na lista de preferÃªncias de ğ‘£
Assim, Ã© possÃ­vel construir em tempo ğ‘‚(ğ‘š) o vetor ğ´pos indexado pelas arestas de ğº
tal que, sendo ğ‘ âˆˆ ğ´ e ğ‘ âˆˆ ğµ, vale que:
ğ´pos [ğ‘ğ‘] = ğ‘– âŸº ğ‘ ocupa a ğ‘–-Ã©sima posiÃ§Ã£o na lista de preferÃªncias de ğ‘
Note que, dado um vÃ©rtice ğ‘ âˆˆ ğ´ e dois vÃ©rtices ğ‘, ğ‘ â€² âˆˆ ğ‘ (ğ‘) e obtido o vetor ğ´pos ,
podemos determinar em tempo constante qual Ã© o vÃ©rtice preferido de ğ‘ entre os vÃ©rtices ğ‘ e
ğ‘ â€² . Para isso, basta comparar ğ´pos [ğ‘ğ‘] com ğ´pos [ğ‘ğ‘ â€² ]. O menor dentre os dois corresponderÃ¡
ao vÃ©rtice preferido por ğ‘.

10
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

Consideramos tambÃ©m que o emparelhamento ğ‘€ do algoritmo serÃ¡ especificado por
um vetor ğ‘’ğ‘šğ‘ indexado pelos vÃ©rtices de ğº de tal forma que, dado ğ‘£ âˆˆ ğ‘‰ (ğº):
ğ‘’ğ‘šğ‘[ğ‘£] = ğ‘¤ âŸº ğ‘¤ = ğ‘›ğ‘¢ğ‘™ğ‘™ ou (ğ‘£ Ã© coberto por ğ‘€ e ğ‘¤ = ğ‘€(ğ‘£))
Assim, remover uma aresta ğ‘ğ‘ de ğ‘€ corresponde a fazer ğ‘’ğ‘šğ‘[ğ‘] = ğ‘›ğ‘¢ğ‘™ğ‘™ e ğ‘’ğ‘šğ‘[ğ‘] =
ğ‘›ğ‘¢ğ‘™ğ‘™; adicionar uma aresta ğ‘ğ‘ Ã  ğ‘€ corresponde a fazer ğ‘’ğ‘šğ‘[ğ‘] = ğ‘ e ğ‘’ğ‘šğ‘[ğ‘] = ğ‘. Em
particular, obtemos que as operaÃ§Ãµes de adiÃ§Ã£o e remoÃ§Ã£o de arestas de ğ‘€ consomem
tempo constante.
Um importante requisito para se conseguir uma eficiente implementaÃ§Ã£o do algoritmo
de Gale-Shapley Ã© o de conseguir encontrar em tempo constante um vÃ©rtice de ğ‘ âˆˆ ğ´ nÃ£o
coberto por ğ‘€ tal que ğ‘ƒ(ğ‘) â‰  âˆ… (chamamos tais vÃ©rtices de vÃ©rtices livres). Um modo de
alcanÃ§ar esse objetivo seria usar uma fila que durante o algoritmo armazenaria os vÃ©rtices
livres de ğ´.
Tal fila seria inicializada com todos os vÃ©rtices de ğ´, jÃ¡ que, no inÃ­cio do algoritmo,
todos os vÃ©rtices de ğ´ sÃ£o livres. A cada iteraÃ§Ã£o do bloco enquanto, tomamos como
vÃ©rtice ğ‘ o vÃ©rtice da frente da fila e o removemos da fila. Se o vÃ©rtice ğ‘ preferido de ğ‘
Ã© tal que ğ‘ Ã© coberto por ğ‘€, temos dois casos. Se ğ‘ >ğ‘ ğ‘€(ğ‘), verificamos se ğ‘ƒ(ğ‘€(ğ‘)) â‰  âˆ…
e, caso a resposta seja positiva, ğ‘€(ğ‘) Ã© devolvido para o final da fila. Caso contrÃ¡rio, se
ğ‘ <ğ‘ ğ‘€(ğ‘), ğ‘ Ã© devolvido para o final da fila. Note que cada aresta de ğº corresponde a no
mÃ¡ximo duas operaÃ§Ãµes na fila (uma remoÃ§Ã£o e uma adiÃ§Ã£o), de modo que o nÃºmero de
operaÃ§Ãµes na fila Ã© limitado por 2ğ‘š = ğ‘‚(ğ‘š).
Dado o exposto acima, estamos em condiÃ§Ãµes de provar o seguinte resultado:
Teorema 3. O algoritmo de Gale-Shapley, no pior caso, consome um tempo ğ‘‚(ğ‘š), onde ğ‘š Ã©
o nÃºmero de arestas do grafo dado como entrada.
DemonstraÃ§Ã£o. Note inicialmente que, como cada vÃ©rtice ğ‘ âˆˆ ğ´ sÃ³ faz pedidos a cada
vizinho no mÃ¡ximo uma Ãºnica vez, temos que o nÃºmero de pedidos Ã© limitado por ğ‘š, onde
ğ‘š âˆ¶= |ğ¸|. Como cada iteraÃ§Ã£o do bloco enquanto corresponde a exatamente um pedido (e
vice-versa), temos que o nÃºmero de iteraÃ§Ãµes Ã© ğ‘‚(ğ‘š).
Veja que a execuÃ§Ã£o das linhas de nÃºmeros 2 a 4 consome tempo ğ‘‚(ğ‘š). Assim, resta-nos
provar que cada iteraÃ§Ã£o do bloco enquanto consome tempo constante. De fato, pelas
consideraÃ§Ãµes acima, cada operaÃ§Ã£o no interior do bloco enquanto pode ser executada
em tempo constante.
Irving e Gusfield provaram que nÃ£o pode existir algoritmo que consuma no pior caso
tempo ğ‘œ(ğ‘š) [5] e, portanto, o algoritmo de Gale-Shapley Ã© assintoticamente Ã³timo.

2.2

Emparelhamentos A-Ã³timos

O leitor mais atento pode ter observado que o algoritmo de Gale-Shapley mostrado
anteriormente possui um elemento de nÃ£o-determinismo. A saber, a ordem em que os
vÃ©rtices de ğ´ fazem os pedidos nÃ£o estÃ¡ especificada. Assim, uma pergunta natural que

11
2.2 | EMPARELHAMENTOS A-Ã“TIMOS

surge Ã©: "A ordem das realizaÃ§Ãµes dos pedidos influencia na resposta dada pelo algoritmo?".
Veremos mais a frente, nesta seÃ§Ã£o, que a resposta Ã© negativa. Para responder Ã  pergunta,
lanÃ§aremos mÃ£o de que o emparelhamento estÃ¡vel devolvido por uma execuÃ§Ã£o qualquer
do algoritmo de Gale-Shapley possui uma propriedade especial que implicarÃ¡ na unicidade
do emparelhamento.
Definiremos agora uma terminologia que nos serÃ¡ posteriormente Ãºtil. Seja ğº =
(ğ‘‰ , ğ¸, ğ¿) um grafo de preferÃªncias (nÃ£o necessariamente bipartido). Considere uma aresta
ğ‘ğ‘ âˆˆ ğ¸. Dizemos que ğ‘ğ‘ Ã© uma aresta estÃ¡vel se ela pertence a algum emparelhamento
estÃ¡vel de ğº. Nesse caso, ğ‘ Ã© um parceiro estÃ¡vel de ğ‘ (e vice-versa). Um vÃ©rtice ğ‘£ Ã© dito
vÃ©rtice estÃ¡vel se possui ao menos um parceiro estÃ¡vel. Se (ğ´, ğµ) Ã© uma bipartiÃ§Ã£o de ğº e
ğ‘€ Ã© um emparelhamento estÃ¡vel de ğº dizemos que ğ‘€ Ã© A-Ã³timo se, cada vÃ©rtice ğ‘ âˆˆ ğ´
estÃ¡vel estÃ¡ emparelhado, em ğ‘€, com o seu parceiro estÃ¡vel preferido. Note que, em um
emparelhamento ğ´-Ã³timo podem existir vÃ©rtices de ğ´ nÃ£o emparelhados. Nesse caso, tais
vÃ©rtices devem ser necessariamente nÃ£o estÃ¡veis.
Teorema 4. O emparelhamento estÃ¡vel devolvido pelo algoritmo de Gale-Shapley Ã© A-Ã³timo.
DemonstraÃ§Ã£o. Seja ğº = (ğ´ âˆª ğµ, ğ¸, ğ¿) um grafo de preferÃªncias bipartido e seja ğ‘€ âˆ— o
emparelhamento devolvido pelo algoritmo de Gale-Shapley. Suponha, por absurdo, que ğ‘€ âˆ—
nÃ£o Ã© ğ´-Ã³timo. Isso implica a existÃªncia de um vÃ©rtice ğ‘ âˆˆ ğ´ e um emparelhamento estÃ¡vel
ğ‘€ tal que ğ‘€(ğ‘) >ğ‘ ğ‘€ âˆ— (ğ‘). Isso significa que ğ‘€(ğ‘) rejeitou ğ‘ âˆˆ ğ´ em razÃ£o de um pedido de
um vÃ©rtice ğ‘â€² âˆˆ ğ´ em algum momento da execuÃ§Ã£o do algoritmo (Em particular, ğ‘â€² >ğ‘€(ğ‘) ğ‘
e ğ‘â€² ğ‘€(ğ‘) âˆˆ ğ¸). Podemos supor, sem perda de generalidade, que tal rejeiÃ§Ã£o corresponde
a primeira vez em que um vÃ©rtice rejeitou um parceiro estÃ¡vel. Assim, ğ‘â€² nÃ£o possui um
parceiro estÃ¡vel que ele prefira Ã  ğ‘€(ğ‘) (caso contrÃ¡rio, ğ‘â€² teria sido rejeitado anteriormente
e isso contradiria o fato de ğ‘ ter sido o primeiro vÃ©rtice rejeitado). Logo, ğ‘€(ğ‘) >ğ‘â€² ğ‘€(ğ‘â€² ),
donde ğ‘â€² ğ‘€(ğ‘) Ã© uma aresta bloqueadora de ğ‘€, o que Ã© uma contradiÃ§Ã£o.
O Teorema acima nos conduz a duas conclusÃµes interessantes. Primeiramente, ele
nos garante que toda instÃ¢ncia de um grafo de preferÃªncias bipartido possui um emparelhamento estÃ¡vel ğ´-Ã³timo. Em outras palavras, se para cada vÃ©rtice ğ‘ âˆˆ ğ´ tomarmos a
aresta com um extremo em ğ‘ e outro no seu parceiro estÃ¡vel preferido o resultado Ã© um
emparelhamento estÃ¡vel ğ‘€. No entanto, Ã  primeira vista, nada nos leva a crer que ğ‘€ seja
um emparelhamento, quiÃ§Ã¡ um emparelhamento estÃ¡vel!
A segunda conclusÃ£o decorre diretamente do fato de que sÃ³ existe um Ãºnico emparelhamento ğ´-Ã³timo (como Ã© fÃ¡cil notar). Assim, o Teorema 4 nos mostra que a ordem em que
os pedidos sÃ£o realizados nÃ£o influencia na resposta dada pelo algoritmo de Gale-Shapley.
A saÃ­da do algoritmo Ã© sempre o emparelhamento ğ´-Ã³timo para a instÃ¢ncia dada como
entrada. Isso responde a questÃ£o suscitada no inÃ­cio da seÃ§Ã£o.
Em muitas situaÃ§Ãµes em CiÃªncia da ComputaÃ§Ã£o, geralmente o ganho em relaÃ§Ã£o a
algum aspecto se dÃ¡ Ã  custa da perda em outro aspecto. Nesse contexto, sÃ£o vÃ¡rias as
ocasiÃµes onde um algoritmo resolve um problema de modo Ã³timo no tempo Ã  custa de um
maior consumo de espaÃ§o. Dessa forma, nÃ£o seria de se surpreender se o emparelhamento
devolvido pelo algoritmo de Gale-Shapley fosse sub-Ã³timo em algum sentido em relaÃ§Ã£o
ao conjunto B.

12
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

Teorema 5. No emparelhamento ğ´-Ã³timo, cada vÃ©rtice ğ‘ âˆˆ ğµ estÃ¡vel estÃ¡ emparelhado com
o seu parceiro estÃ¡vel menos preferido.

DemonstraÃ§Ã£o. Suponha que nÃ£o seja o caso. Seja ğ‘€ğ´ o emparelhamento ğ´-Ã³timo. EntÃ£o,
deve existir um vÃ©rtice ğ‘ âˆˆ ğµ estÃ¡vel e um emparelhamento estÃ¡vel ğ‘€ tal que ğ‘€ğ´ (ğ‘) >ğ‘
ğ‘€(ğ‘). Como ğ‘€ Ã© um emparelhamento estÃ¡vel, ğ‘€(ğ‘€ğ´ (ğ‘)) >ğ‘€ğ´ (ğ‘) ğ‘ (Caso contrÃ¡rio, ğ‘€ğ´ (ğ‘)ğ‘
bloquearia ğ‘€). Portanto, ğ‘ nÃ£o Ã© o parceiro estÃ¡vel preferido de ğ‘€ğ´ (ğ‘), o que contradiz o
fato de ğ‘€ğ´ ser um emparelhamento ğ´-Ã³timo.

Motivado pelo Teorema 5, o emparelhamento ğ´-Ã³timo Ã© tambÃ©m chamado de ğµpÃ©ssimo.
Note que se trocarmos os papÃ©is de ğ´ e ğµ no algoritmo de Gale-Shapley (Os vÃ©rtices de
ğµ passam a ser os que fazem os pedidos e os vÃ©rtices de ğ´ passam a ser os que recebem os
pedidos) obtemos que o emparelhamento devolvido pelo algoritmo Ã© ğµ-Ã³timo e ğ´-pÃ©ssimo.
Assim, diz-se que o algoritmo de Gale-Shapley possui duas orientaÃ§Ãµes possÃ­veis, sendo
uma a que os vÃ©rtices de ğ´ fazem os pedidos (e os de ğµ recebem) e a outra a que os
vÃ©rtices de ğµ fazem os pedidos (e os de ğ´ recebem). No primeiro caso o algoritmo de
Gale-Shapley Ã© denominado ğ´-orientado e, no segundo, ğµ-orientado. A menos de menÃ§Ã£o
em contrÃ¡rio, quando escrevemos algoritmo de Gale-Shapley estaremos nos referindo a
versÃ£o ğ´-orientada.

2.2.1

Algoritmo estendido de Gale-Shapley

Considere que, em uma execuÃ§Ã£o arbitrÃ¡ria do algoritmo de Gale-Shapley, um vÃ©rtice
ğ‘ âˆˆ ğµ aceita um pedido proveniente de um vÃ©rtice ğ‘ âˆˆ ğ´. Como um vÃ©rtice de ğµ sÃ³ rejeita
um vÃ©rtice ğ‘£ â€² em favor de um pedido de um vÃ©rtice de ğ‘£ quando ğ‘£ <ğ‘ ğ‘£ â€² e, levando em
conta que o grafo devolvido pelo algoritmo de Gale-Shapley Ã© ğµ-pÃ©ssimo (fato provado na
subseÃ§Ã£o anterior), concluÃ­mos que nÃ£o existem emparelhamentos estÃ¡veis onde o vÃ©rtice
ğ‘ estÃ¡ emparelhado com um vÃ©rtice pior do que ğ‘ âˆˆ ğ´. Isso significa que, se ğ‘â€² âˆˆ ğ´ Ã©
um vÃ©rtice tal que ğ‘â€² <ğ‘ ğ‘, ğ‘â€² ğ‘ nÃ£o bloqueia nenhum emparelhamento estÃ¡vel de ğº e,
portanto, os conjuntos dos emparelhamentos estÃ¡veis de ğº e ğº âˆ’ {ğ‘â€² ğ‘} sÃ£o idÃªnticos. Em
outras palavras, remover a aresta ğ‘â€² ğ‘ nÃ£o conduz a nenhum prejuÃ­zo do ponto de vista de
encontrar emparelhamentos estÃ¡veis.
A simples observaÃ§Ã£o do parÃ¡grafo anterior nos conduz ao chamado algoritmo de

13
2.2 | EMPARELHAMENTOS A-Ã“TIMOS

Gale-Shapley estendido, descrito abaixo.
Algoritmo 2: Gale-Shapley estendido
Entrada: Um grafo de preferÃªncias bipartido ğº = (ğ‘‰ = ğ´ âˆª ğµ, ğ¸, ğ¿)
SaÃ­da: Um subgrafo de preferÃªncias ğº â€² de ğº e um emparelhamento estÃ¡vel ğ‘€ de
ğº
1 inÃ­cio
2
FaÃ§a ğ‘€ âˆ¶= âˆ… e ğº â€² âˆ¶= ğº
3
para cada ğ‘£ âˆˆ ğ‘‰ faÃ§a
4
ğ‘ƒ(ğ‘£) âˆ¶= ğ¿ğ‘£
5
6
7
8
9

enquanto existe ğ‘ âˆˆ ğ´ nÃ£o coberto por ğ‘€ tal que ğ‘ƒ(ğ‘) â‰  âˆ… faÃ§a
Seja ğ‘ o vizinho preferido de ğ‘ em ğ‘ƒ(ğ‘)
se ğ‘ Ã© coberto por ğ‘€ entÃ£o
ğ‘€ âˆ¶= ğ‘€ â§µ {ğ‘€(ğ‘)ğ‘}

11

ğ‘€ âˆ¶= ğ‘€ âˆª {ğ‘ğ‘}
para cada ğ‘â€² âˆˆ ğ´ vizinho de ğ‘ em ğº â€² tal que ğ‘â€² <ğ‘ ğ‘ faÃ§a
ğº â€² âˆ¶= ğº â€² âˆ’ {ğ‘â€² ğ‘}

12

ğ‘ƒ(ğ‘) âˆ¶= ğ‘ƒ(ğ‘) â§µ {ğ‘}

10

13

retorna (ğ‘€, ğº â€² )

Vale notar que, diferentemente do algoritmo de Gale-Shapley, a versÃ£o estendida
devolve um subgrafo de preferÃªncias ğº â€² de ğº alÃ©m de um emparelhamento estÃ¡vel ğ‘€.
Denotaremos ğº â€² por ğºğ´ . AlÃ©m disso, denotaremos por ğºğµ o grafo de preferÃªncias devolvido
pela versÃ£o ğµ-orientada do algoritmo de Gale-Shapley estendido quando um grafo de
preferÃªncias bipartido ğº Ã© dado como entrada.
Vale observar tambÃ©m que a remoÃ§Ã£o das arestas executada na linhas 10-11 garante
apenas que nÃ£o haverÃ¡ mais â€œrejeiÃ§Ãµes imediatasâ€ durante a execuÃ§Ã£o do algoritmo, isto
Ã©, um vÃ©rtice ğ‘ nunca realiza um pedido a um vÃ©rtice ğ‘ tal que ğ‘€(ğ‘) >ğ‘ ğ‘. A partir dessa
observaÃ§Ã£o, Ã© possÃ­vel concluir que o emparelhamento estÃ¡vel devolvido pelo algoritmo de
Gale-Shapley estendido Ã© o mesmo devolvido pela versÃ£o original e, portanto, Ã© o ğ´-Ã³timo
de ğº e, logo, de ğºğ´ (jÃ¡ que ğº e ğºğ´ possuem os mesmos emparelhamentos estÃ¡veis). Analogamente, conclui-se o emparelhamento devolvido pela versÃ£o ğµ-orientada do algoritmo Ã©
o ğµ-Ã³timo de ğº e de ğºğµ .
Agora, denote por ğ‘€ğ´ e ğ‘€ğµ os emparelhamentos ğ´-Ã³timo e ğµ-Ã³timo de um grafo de
preferÃªncias bipartido ğº, respectivamente. Note que ğºğ´ corresponde a ğº apÃ³s a remoÃ§Ã£o
de todas as arestas ğ‘ğ‘ âˆˆ ğ¸(ğº) tais que ğ‘€ğ´ (ğ‘) >ğ‘ ğ‘ e que ğºğµ Ã© ğº sem as arestas ğ‘ğ‘ âˆˆ ğ¸(ğº)
tais que ğ‘€ğµ (ğ‘) >ğ‘ ğ‘ (ğ¼ ). AlÃ©m disso, a observaÃ§Ã£o de que ğº, ğºğ´ e ğºğµ possuem os mesmos
emparelhamentos estÃ¡veis nos conduz a de que o conjunto de emparelhamentos estÃ¡veis
de ğº, ğºğ´ğµ , ğºğµğ´ Ã© o mesmo (ğ¼ ğ¼ ). Assim, segue de (ğ¼ ) e (ğ¼ ğ¼ ), que ğºğ´ğµ e ğºğµğ´ corresponde ao
grafo ğº apÃ³s a remoÃ§Ã£o das arestas ğ‘ğ‘ âˆˆ ğ¸(ğº) tais que ğ‘€ğ´ (ğ‘) >ğ‘ ğ‘ ou ğ‘€ğµ (ğ‘) >ğ‘ ğ‘. Em
particular, ğºğ´ğµ = ğºğµğ´ .
Vamos chamar o grafo de preferÃªncias ğºğ´ğµ (= ğºğµğ´ ) de Gale-Shapley-reduzido ou, mais

14
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

simplesmente, de ğºğ‘†-reduzido. O teorema a seguir resume as propriedades relevantes do
grafo ğºğ‘†-reduzido.
Teorema 6. Seja ğº um grafo de preferÃªncias bipartido. EntÃ£o:
1. todos os emparelhamentos estÃ¡veis de ğº sÃ£o tambÃ©m emparelhamentos estÃ¡veis do
grafo ğºğ‘†-reduzido de ğº.
2. nenhum emparelhamento estÃ¡vel do grafo ğºğ‘†-reduzido Ã© bloqueado por uma aresta de
ğº nÃ£o contida no grafo ğºğ‘†-reduzido.
3. Seja ğ‘€ğ´ (ğ‘€ğµ ) o emparelhamento ğ´-Ã³timo (ğµ-Ã³timo) de ğº. Se ğ‘ âˆˆ ğ´ Ã© coberto por ğ‘€ğ´
(ğ‘€ğµ ) entÃ£o ğ‘€ğ´ (ğ‘) (ğ‘€ğµ (ğ‘)) Ã© o vizinho (menos) preferido de ğ‘ no grafo ğºğ‘†-reduzido e se
ğ‘ âˆˆ ğµ Ã© coberto por ğ‘€ğ´ (ğ‘€ğµ ), entÃ£o ğ‘€ğ´ (ğ‘) (ğ‘€ğµ (ğ‘)) Ã© o vizinho menos (mais) preferido
de ğ‘ no grafo ğºğ‘†-reduzido.
DemonstraÃ§Ã£o.
1. A prova segue diretamente do fato que os conjuntos dos emparelhamentos estÃ¡veis de ğº e do grafo ğºğ‘†-reduzidos sÃ£o os mesmos (demonstrado na
discussÃ£o acima).
2. Seja ğ‘ğ‘ âˆˆ ğ¸(ğº) uma aresta nÃ£o contida no grafo ğºğ‘†-reduzido de ğº e ğ‘€ um emparelhamento estÃ¡vel arbitrÃ¡rio de ğº tal que ğ‘ğ‘ âˆ‰ ğ‘€. Denote por ğ‘€ğ´ , ğ‘€ğµ os emparelhamentos estÃ¡veis ğ´-Ã³timo e ğµ-Ã³timo de ğº, respectivamente. Assim, ğ‘€(ğ‘) â‰¥ğ‘ ğ‘€ğ´ (ğ‘)
(ğ‘€ğ´ Ã© ğµ-pÃ©ssimo) e ğ‘€(ğ‘) â‰¥ğ‘ ğ‘€ğµ (ğ‘) (ğ‘€ğµ Ã© ğ´-pÃ©ssimo) (ğ¼ ). Por outro lado, como ğ‘ğ‘
nÃ£o pertence ao grafo ğºğ‘†-reduzido, segue que ğ‘€ğµ (ğ‘) >ğ‘ ğ‘ ou ğ‘€ğ´ (ğ‘) >ğ‘ ğ‘ (ğ¼ ğ¼ ). De
(ğ¼ ) e (ğ¼ ğ¼ ), vem que ğ‘€(ğ‘) â‰¥ğ‘ ğ‘€ğ´ (ğ‘) >ğ‘ ğ‘ ou ğ‘€(ğ‘) â‰¥ğ‘ ğ‘€ğµ (ğ‘) >ğ‘ ğ‘, donde, ğ‘€(ğ‘) >ğ‘ ğ‘ ou
ğ‘€(ğ‘) >ğ‘ ğ‘, isto Ã©, ğ‘ğ‘ nÃ£o bloqueia ğ‘€.
3. Vamos provar apenas as afirmaÃ§Ãµes referentes a ğ‘€ğ´ , pois a prova das referentes a
ğ‘€ğµ Ã© inteiramente anÃ¡loga. Sejam ğ‘ âˆˆ ğ´ e ğ‘ âˆˆ ğµ. Se ğ‘ğ‘ â€² âˆˆ ğ¸(ğº) Ã© tal que ğ‘€ğ´ (ğ‘) <ğ‘ ğ‘ â€² ,
como ğ‘€ğ´ Ã© estÃ¡vel, tem-se que ğ‘€ğ´ (ğ‘ â€² ) >â€²ğ‘ ğ‘, implicando que ğ‘ğ‘ â€² nÃ£o pertence ao
grafo ğºğ‘†-reduzido. Assim, segue que ğ‘€ğ´ (ğ‘) Ã© o vizinho preferido de ğ‘ no grafo
ğºğ‘†-reduzido. Se ğ‘â€² ğ‘ âˆˆ ğ¸(ğº) Ã© tal que ğ‘€ğ´ (ğ‘) >ğ‘ ğ‘â€² segue diretamente que ğ‘â€² ğ‘ nÃ£o
pertence ao grafo ğºğ‘†-reduzido.

2.3

Teorema dos hospitais rurais

Seja ğº = (ğ´ âˆª ğµ, ğ¸, ğ¿) um grafo de preferÃªncias bipartido e seja ğ‘€ um emparelhamento
estÃ¡vel de ğº. Seja ğ‘ um vÃ©rtice de ğº que nÃ£o Ã© coberto por ğ‘€. SerÃ¡ que existe um outro
emparelhamento estÃ¡vel ğ‘€ â€² de ğº tal que ğ‘ Ã© coberto por ğ‘€ â€² ? Nesta seÃ§Ã£o encontraremos
a resposta para essa questÃ£o.
Como ponto de partida, buscaremos estender a noÃ§Ã£o de preferÃªncia entre vÃ©rtices
de modo que ela se aplique a emparelhamentos. Sejam ğ‘€ e ğ‘€ â€² emparelhamentos (nÃ£o
necessariamente estÃ¡veis) de ğº e ğ‘ um vÃ©rtice de ğº. Dizemos que ğ‘ prefere ğ‘€ a ğ‘€ â€² , e
escrevemos ğ‘€ â€² <ğ‘£ ğ‘€, quando vale uma das seguintes condiÃ§Ãµes:
1. ğ‘ Ã© coberto por ğ‘€ e ğ‘ nÃ£o Ã© coberto por ğ‘€ â€²

15
2.3 | TEOREMA DOS HOSPITAIS RURAIS

2. ğ‘ Ã© coberto por ğ‘€ e por ğ‘€ â€² e ğ‘€ â€² (ğ‘) <ğ‘£ ğ‘€(ğ‘).
Dizemos que ğ‘ Ã© indiferente a ğ‘€ e ğ‘€ â€² , e escrevemos ğ‘€ =ğ‘ ğ‘€ â€² quando, ou nÃ£o Ã© coberto
tanto por ğ‘€ quanto por ğ‘€ â€² , ou quando Ã© coberto por ambos e ğ‘€(ğ‘) = ğ‘€ â€² (ğ‘). Por fim,
escrevemos ğ‘€ â‰¤ğ‘ ğ‘€ â€² quando ğ‘€ =ğ‘ ğ‘€ â€² ou ğ‘€ <ğ‘ ğ‘€ â€² .
Com o exposto acima, estamos em condiÃ§Ãµes de provar um resultado que, embora Ã 
priori pareÃ§a arbitrÃ¡rio, serÃ¡ de fundamental importÃ¢ncia nessa seÃ§Ã£o (na prova do Teorema
dos hospitais rurais) e na seÃ§Ã£o a seguir.
Lema 1. Considere um grafo de preferÃªncias ğº = (ğ‘‰ = ğ´ âˆª ğµ, ğ¸, ğ¿) e dois emparelhamentos
estÃ¡veis ğ‘€ e ğ‘€ â€² . Se ğ‘ âˆˆ ğ´ e ğ‘ âˆˆ ğµ sÃ£o tais que ğ‘€(ğ‘) = ğ‘ e ğ‘ nÃ£o Ã© parceiro de ğ‘ em ğ‘€ â€² , entÃ£o,
um dos dois vÃ©rtices prefere ğ‘€ a ğ‘€ â€² e o outro prefere ğ‘€ â€² a ğ‘€.
DemonstraÃ§Ã£o. Seja ğ´ğ‘€ o conjunto dos vÃ©rtices ğ‘ âˆˆ ğ´ tais que ğ‘€ â€² <ğ‘ ğ‘€ e ğ´ğ‘€ â€² o conjunto
dos vÃ©rtices ğ‘ âˆˆ ğ´ tais que ğ‘€ <ğ‘ ğ‘€ â€² . Defina ğµğ‘€ e ğµğ‘€ â€² de maneira anÃ¡loga. Levando em
conta essas definiÃ§Ãµes, a figura 2.3 ilustra o lema.
Note, inicialmente, que se ğ‘ âˆˆ ğ´ğ‘€ e ğ‘ğ‘ âˆˆ ğ¸, entÃ£o ğ‘ âˆˆ ğµğ‘€ âˆª ğµğ‘€ â€² ou, em outras palavras,
todo vizinho de ğ‘ âˆˆ ğ´ğ‘€ nÃ£o Ã© indiferente a ğ‘€ e ğ‘€ â€² (I) (De fato, se assim o fosse, terÃ­amos,
por definiÃ§Ã£o de indiferenÃ§a, que ğ‘€ â€² (ğ‘) = ğ‘€(ğ‘) = ğ‘, o que, por sua vez, implicaria que ğ‘ Ã©
indiferente a ğ‘€ e ğ‘€ â€² ).
Note que nÃ£o pode haver aresta ğ‘ğ‘ âˆˆ ğ‘€ com ğ‘ âˆˆ ğ´ğ‘€ e ğ‘ âˆˆ ğµğ‘€ (ğ¼ ğ¼ ). Para provar isso,
suponha, por absurdo, que haja tal aresta ğ‘ğ‘. Se ğ‘ nÃ£o fosse coberto por ğ‘€ â€² , ğ‘ nÃ£o seria
coberto por ğ‘€ â€² (pois ğ‘ prefere ğ‘€ a ğ‘€ â€² ), implicando que ğ‘ğ‘ bloqueia ğ‘€ â€² e ğ‘€ â€² nÃ£o Ã© estÃ¡vel.
Logo, ğ‘ Ã© coberto por ğ‘€ â€² , implicando que ğ‘ tambÃ©m Ã© coberto por ğ‘€ â€² . DaÃ­, como ambos
os vÃ©rtices ğ‘ e ğ‘ preferem ğ‘€ a ğ‘€ â€² , segue-se que ğ‘ğ‘ bloqueia ğ‘€ â€² , o que Ã© uma contradiÃ§Ã£o.
De forma inteiramente anÃ¡loga, conclui-se que nÃ£o pode haver aresta ğ‘â€² ğ‘ â€² âˆˆ ğ‘€ â€² tal que
ğ‘â€² âˆˆ ğ´ğ‘€ â€² e ğ‘ â€² âˆˆ ğµğ‘€ â€² (ğ¼ ğ¼ ğ¼ ).
De (ğ¼ ğ¼ ) e por (ğ¼ ), segue que, se ğ‘ğ‘ âˆˆ ğ‘€ e ğ‘ âˆˆ ğ´ğ‘€ , entÃ£o ğ‘ âˆˆ ğµğ‘€ â€² (ğ¼ ğ‘‰ ), donde |ğ´ğ‘€ | â‰¤ |ğµğ‘€ â€² |,
pois ğ‘€ induz uma injeÃ§Ã£o de ğ´ğ‘€ em ğµğ‘€ â€² . De (ğ¼ ğ¼ ğ¼ ), conclui-se, de modo anÃ¡logo, que
|ğµğ‘€ â€² | â‰¤ |ğ´ğ‘€ |. Portanto, |ğ´ğ‘€ | = |ğµğ‘€ â€² | (ğ‘‰ ).
Para encerrar a demonstraÃ§Ã£o, tome uma aresta ğ‘ğ‘ âˆˆ ğ‘€ tal que ğ‘ e ğ‘ nÃ£o sÃ£o parceiros
em ğ‘€ â€² . Se ğ‘ âˆˆ ğ´ğ‘€ , por (ğ‘‰ ), temos que ğ‘ âˆˆ ğµğ‘€ â€² . Resta-nos provar que ğ‘ âˆˆ ğ´ğ‘€ â€² âŸ¹ ğ‘ âˆˆ ğµğ‘€ .
Suponha, por absurdo, que ğ‘ âˆˆ ğ´ğ‘€ â€² e ğ‘ âˆˆ ğµğ‘€ â€² . Assim, por (ğ‘‰ ), vem que ğ‘€ induz uma
bijeÃ§Ã£o de ğ´ğ‘€ para ğµğ‘€ â€² , e portanto, existiria ğ‘â€² âˆˆ ğ´ğ‘€ tal que ğ‘€(ğ‘â€² ) = ğ‘ e ğ‘€ nÃ£o seria um
emparelhamento.

Uma consequÃªncia imediata do lema anterior Ã©:
CorolÃ¡rio 1. Considere um grafo de preferÃªncias ğº = (ğ‘‰ = ğ´ âˆª ğµ, ğ¸, ğ¿) e dois emparelhamentos estÃ¡veis ğ‘€ e ğ‘€ â€² . O nÃºmero de vÃ©rtices que preferem ğ‘€ a ğ‘€ â€² Ã© igual ao nÃºmero de
vÃ©rtices que preferem ğ‘€ â€² a ğ‘€.
Um emparelhamento ğ‘€ tal que, para qualquer outro emparelhamento ğ‘€ â€² , o nÃºmero
de vÃ©rtices que preferem ğ‘€ a ğ‘€ â€² Ã© maior ou igual ao nÃºmero de vÃ©rtices que preferem ğ‘€ â€²

16
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

Caso 1:
ğ´

ğµ
ğµğ‘€

ğ´ğ‘€
ğ‘

ğ‘
ğµğ‘€}

ğ´ğ‘€ â€²
Caso 2:
ğ´
ğ´ğ‘€

ğµ
ğµğ‘€
ğ‘

ğ‘
ğ´ğ‘€ â€²

ğµğ‘€}

Figura 2.3: O Lema 1 nos diz que, dada uma aresta ğ‘ğ‘ âˆˆ ğ‘€ tal que ğ‘ e ğ‘ nÃ£o sÃ£o parceiros em ğ‘€ â€² ,
sÃ³ um dos casos acima pode ocorrer.

a ğ‘€ Ã© denominado emparelhamento popular. Assim, o CorolÃ¡rio 1, implica que todo
emparelhamento estÃ¡vel Ã© popular.
A classe dos emparelhamentos populares Ã© foco de grande estudo devido Ã s suas
aplicaÃ§Ãµes em ciÃªncias aplicadas, tais como a economia. Um emparelhamento ser popular
significa em um certo sentido que ele Ã© Ã³timo globalmente. Se imaginarmos cada vÃ©rtice
como um eleitor e cada emparelhamento como um candidato Ã  presidÃªncia, digamos, um
emparelhamento popular corresponderia a um candidato que nÃ£o perderia uma eleiÃ§Ã£o
numa disputa com qualquer outro candidato.
Agora temos o ferramental necessÃ¡rio para provar o Teorema que dÃ¡ o nome Ã  presente
seÃ§Ã£o e que responde a questÃ£o suscitada no inÃ­cio dela.
Teorema 7 (hospitais rurais). Seja ğº = (ğ´ âˆª ğµ, ğ¸, ğ¿) um grafo de preferÃªncias bipartido e
ğ‘£ um vÃ©rtice de ğº. Se existe um emparelhamento estÃ¡vel que nÃ£o cobre ğ‘£ entÃ£o nenhum
emparelhamento estÃ¡vel cobre ğ‘£.

17
2.3 | TEOREMA DOS HOSPITAIS RURAIS

DemonstraÃ§Ã£o. Seja ğºğ‘€,ğ‘€ â€² o grafo direcionado cujo conjunto de nÃ³s Ã© ğ‘‰ e o conjunto
ğ¸(ğºğ‘€,ğ‘€ â€² ) de arcos Ã© definido da seguinte forma. Para cada vÃ©rtice ğ‘ âˆˆ ğ´ coberto por ğ‘€,
existe um arco de ğ‘ para ğ‘€(ğ‘) e para cada vÃ©rtice de ğ‘ âˆˆ ğµ coberto por ğ‘€ â€² , temos um arco
de ğ‘ para ğ‘€ â€² (ğ‘). A figura a seguir ilustra ğºğ‘€,ğ‘€ â€² . Note que todo nÃ³ de ğºğ‘€,ğ‘€ â€² possui grau de
entrada e de saÃ­da ambos no mÃ¡ximo 1 (ğ¼ ). AlÃ©m disso, o grau de entrada de ğ‘£ em ğºğ‘€,ğ‘€ â€² Ã©
0 (ğ¼ ğ¼ ).
ğºğ‘€,ğ‘€ â€²
ğ´

ğµ

ğ‘1

ğ‘€(ğ‘)

ğ‘€ â€² (ğ‘2 )

ğ‘2

Figura 2.4: As arestas pintadas de azul correspondem as induzidas pelo emparelhamento ğ‘€ e as
pintadas de vermelho sÃ£o as induzidas pelo emparelhamento ğ‘€ â€² .

Suponha, por absurdo, que exista um vÃ©rtice ğ‘£ de ğº e emparelhamentos estÃ¡veis ğ‘€
e ğ‘€ â€² tais que ğ‘£ Ã© coberto por ğ‘€ mas nÃ£o Ã© coberto por ğ‘€ â€² . Podemos supor, sem perda
de generalidade, que ğ‘£ âˆˆ ğ´. Seja ğ‘‡ = (ğ‘£0 , ğ‘£1 , ..., ğ‘£ğ‘Ÿ ) uma trilha mais longa partindo de ğ‘£
em ğºğ‘€,ğ‘€ â€² (isto Ã©, ğ‘£0 = ğ‘£). Tal trilha deve existir pois ğºğ‘€,ğ‘€ â€² Ã© finito. Por (ğ¼ ) e (ğ¼ ğ¼ ), vem
imediatamente que ğ‘£ğ‘– â‰  ğ‘£ğ‘— para todo ğ‘–, ğ‘— âˆˆ {0, ..., ğ‘Ÿ} (ğ¼ ğ¼ ğ¼ ).
Note que ğ‘£0 âˆˆ ğ´ prefere ğ‘€ a ğ‘€ â€² e ğ‘£0 e ğ‘£1 nÃ£o sÃ£o parceiros em ğ‘€ â€² . Assim, pelo Lema
1, ğ‘£1 âˆˆ ğµ prefere ğ‘€ â€² a ğ‘€. Aplicando o Lema 1 novamente, jÃ¡ que ğ‘£1 e ğ‘£2 nÃ£o sÃ£o parceiros
em ğ‘€, obtemos que ğ‘£2 âˆˆ ğ´ prefere ğ‘€ a ğ‘€ â€² . Assim, por um argumento indutivo, Ã© possÃ­vel
concluir que ğ‘£ğ‘– prefere ğ‘€ a ğ‘€ â€² se ğ‘– for par e prefere ğ‘€ â€² a ğ‘€ se ğ‘– for Ã­mpar.
Finalmente, se ğ‘Ÿ for Ã­mpar, ğ‘£ğ‘Ÿ prefere ğ‘€ â€² a ğ‘€ e ğ‘£ğ‘Ÿ âˆˆ ğµ. Note que ğ‘€(ğ‘£ğ‘Ÿâˆ’1 ) = ğ‘£ğ‘Ÿ . Assim, ğ‘£ğ‘Ÿ
Ã© coberto por ğ‘€ â€² e ğ‘£ğ‘Ÿ+1 âˆ¶= ğ‘€ â€² (ğ‘£ğ‘Ÿ ) Ã© tal que ğ‘£ğ‘Ÿ ğ‘£ğ‘Ÿ+1 âˆˆ ğ¸(ğºğ‘€,ğ‘€ â€² ). DaÃ­, por (ğ¼ ğ¼ ğ¼ ), ğ‘£ğ‘Ÿ ğ‘£ğ‘Ÿ+1 âˆ‰ ğ¸(ğ‘‡ ),
implicando que ğ‘‡ â€² = (ğ‘£0 , ğ‘£1 , ..., ğ‘£ğ‘Ÿ , ğ‘£ğ‘Ÿ+1 ) Ã© uma trilha de ğºğ‘€,ğ‘€ â€² mais longa que ğ‘‡ , o que Ã©
uma contradiÃ§Ã£o. A prova do caso em que ğ‘Ÿ Ã© par Ã© inteiramente anÃ¡loga.

Um corolÃ¡rio imediato do teorema Ã© o seguinte.
CorolÃ¡rio 2. Se um vÃ©rtice de um grafo de preferÃªncias bipartido ğº Ã© coberto por um
emparelhamento estÃ¡vel entÃ£o ele Ã© coberto por qualquer emparelhamento estÃ¡vel de ğº. De
modo equivalente, Se um vÃ©rtice nÃ£o Ã© coberto por um emparelhamento estÃ¡vel, ele nÃ£o Ã©
coberto por nenhum outro emparelhamento estÃ¡vel.
Um problema interessante de Teoria dos Jogos Ã© o de alocaÃ§Ã£o de residentes a hospitais.
Em tal problema, temos mÃ©dicos se candidatando a hospitais. Suponhamos que cada mÃ©dico

18
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

se candidata a um conjunto de hospitais e que ele possui uma ordem de preferÃªncia estrita
em relaÃ§Ã£o aos hospitais aos quais ele se candidatou. Cada hospital tem um nÃºmero fixo
e limitado de vagas. AlÃ©m disso, cada hospital avalia os seus candidatos atravÃ©s de um
exame. Assuma, por simplicidade, que dois candidatos nÃ£o podem receber a mesma nota
em um exame de um mesmo hospital. Por meio dessa avaliaÃ§Ã£o, cada hospital cria uma
lista de classificaÃ§Ã£o dos seus candidatos. Queremos encontrar uma alocaÃ§Ã£o de mÃ©dicos a
hospitais de modo que o nÃºmero de mÃ©dicos alocados a um hospital â„ arbitrÃ¡rio nÃ£o seja
maior que o nÃºmero de vagas de â„. Cada mÃ©dico sÃ³ pode ser alocado a um hospital ao qual
ele se candidatou. AlÃ©m disso, em uma dada alocaÃ§Ã£o, nÃ£o pode ocorrer de um mÃ©dico ğ‘š
ser alocado a um hospital â„ tal que haja um mÃ©dico ğ‘šâ€² â‰  ğ‘š abaixo na lista de classificaÃ§Ã£o
de â„ em relaÃ§Ã£o a ğ‘š e que ğ‘š prefira â„ ao hospital a que ele foi alocado.
Tal problema pode ser modelado matematicamente como o de encontrar um emparelhamento estÃ¡vel em um grafo de preferÃªncias bipartido ğº = (ğ‘‰ = ğ´ âˆª ğµ, ğ¸, ğ¿) definido da
seguinte forma:
1. ğ´ representa o conjunto dos residentes e ğµ representa o conjunto dos hospitais.
2. Para cada hospital â„ com nÃºmero de vagas ğ‘â„ temos ğ‘â„ vÃ©rtices de ğµ que se referem
a â„. A cada tal vÃ©rtice, associamos um Ã­ndice de 1 a ğ‘â„ .
3. Cada residente ğ‘Ÿ Ã© representado por um Ãºnico vÃ©rtice ğ‘ğ‘Ÿ âˆˆ ğ´.
4. Se um residente ğ‘Ÿ se candidatou a um hospital â„, existe uma aresta do vÃ©rtice ğ‘ğ‘Ÿ âˆˆ ğ´
que representa ğ‘Ÿ para cada vÃ©rtice que se refere ao hospital â„. A lista de preferÃªncias
de ğ‘ğ‘Ÿ Ã© tal que: se ğ‘Ÿ prefere o hospital â„ ao â„â€² , entÃ£o vÃ©rtices que se referem a â„
aparecem na frente de vÃ©rtices de se referem a â„â€² . VÃ©rtices que se referem a um
mesmo hospital â„ aparecem na lista de preferÃªncia em ordem crescente do seu Ã­ndice
(isto Ã©, o de ordem menor aparece na frente).
Modelando o problema dessa forma, ele se reduz ao de encontrar um emparelhamento
estÃ¡vel em um grafo de preferÃªncias bipartido.
Nos Estados Unidos, existe um Ã³rgÃ£o, o National Resident Matching Program (NRMP),
responsÃ¡vel por realizar a alocaÃ§Ã£o de seus mÃ©dicos residentes aos hospitais. O Ã“rgÃ£o utiliza
um algoritmo que, em essÃªncia, Ã© o de Gale-Shapley de encontrar um emparelhamento
estÃ¡vel [9]. LÃ¡, em geral, o nÃºmero de vagas Ã© maior que o nÃºmero de aplicantes e, portanto,
existem hospitais onde nem todas as suas vagas sÃ£o preenchidas. Devido a uma preferÃªncia
dos residentes aos hospitais urbanos, o emparelhamento estÃ¡vel encontrado pelo algoritmo
em geral ocasionava uma grande quantidade de vagas nÃ£o preenchidas nos hospitais
rurais.
Isso levantou a questÃ£o de se talvez fosse possÃ­vel alterar o algoritmo de modo a fazÃª-lo
encontrar um emparelhamento estÃ¡vel onde o nÃºmero de vagas preenchidas nos hospitais
rurais fosse maior. O Teorema dos Hospitais Rurais responde a essa questÃ£o negativamente
(e daÃ­ o seu nome).

19
2.4 | ESTRUTURA ALGÃ‰BRICA DOS EMPARELHAMENTOS ESTÃVEIS

2.4

Estrutura AlgÃ©brica dos Emparelhamentos
EstÃ¡veis

Ã‰ possÃ­vel munir o conjunto dos emparelhamentos estÃ¡veis de um grafo bipartido com
preferÃªncias de uma relaÃ§Ã£o de ordem de modo natural de modo a constituir o que os
algebristas chamam de um reticulado distributivo (conceito que serÃ¡ definido precisamente
mais a frente). Nessa seÃ§Ã£o usaremos esse fato e daremos uma demonstraÃ§Ã£o da existÃªncia
de um emparelhamento estÃ¡vel ğ´-Ã³timo sem lanÃ§ar mÃ£o da corretude do algoritmo de
Gale-Shapley.
Iniciaremos a seÃ§Ã£o introduzindo uma terminologia bÃ¡sica de teoria da ordem suficiente
para os propÃ³sitos dessa seÃ§Ã£o. O leitor familiarizado com conceitos bÃ¡sicos de Teoria da
Ordem pode pular para a subseÃ§Ã£o 2.4.2.

2.4.1

Terminologia bÃ¡sica de teoria da ordem

Seja â‰¼ uma relaÃ§Ã£o definida num conjunto ğ‘† (isto Ã©, â‰¼ Ã© um subconjunto de ğ‘† Ã— ğ‘†).
Dizemos que â‰¼ Ã© uma ordem parcial em ğ‘† se ela possui as seguintes propriedades:
1. Para todo ğ‘ âˆˆ ğ‘† vale que ğ‘ â‰¼ ğ‘. (Reflexividade)
2. Para todo ğ‘, ğ‘, ğ‘ âˆˆ ğ‘† tem-se que (ğ‘ â‰¼ ğ‘ e ğ‘ â‰¼ ğ‘ âŸ¹ ğ‘ â‰¼ ğ‘). (Transitividade)
3. Para todo ğ‘, ğ‘ âˆˆ ğ‘† tem-se que (ğ‘ â‰¼ ğ‘ e ğ‘ â‰¼ ğ‘ âŸ¹ ğ‘ = ğ‘). (Antissimetria)
O par (ğ‘†, â‰¼) Ã© chamado de conjunto ordenado. Se ğ‘, ğ‘ âˆˆ ğ‘† sÃ£o tais que ğ‘ â‰¼ ğ‘ ou ğ‘ â‰¼ ğ‘,
dizemos que ğ‘ e ğ‘ sÃ£o comparÃ¡veis. Caso contrÃ¡rio, ğ‘ e ğ‘ sÃ£o ditos incomparÃ¡veis. Se
todo par de elementos de ğ‘† forem comparÃ¡veis, diremos que â‰¼ Ã© uma ordem total e que
(ğ‘†, â‰¼) Ã© um conjunto totalmente ordenado.
Seja (ğ‘†, â‰¼) um conjunto ordenado e ğ» âŠ† ğ‘†. Dizemos que ğ» Ã© limitado superiormente
quando existe um ğ‘  âˆˆ ğ‘† tal que â„ â‰¼ ğ‘  para todo â„ âˆˆ ğ» . Tal ğ‘  Ã© denominado uma cota
superior de ğ» . De modo anÃ¡logo, dizemos que ğ» Ã© limitado inferiormente quando
existe ğ‘– âˆˆ ğ‘† tal que ğ‘– â‰¼ â„ para todo â„ âˆˆ ğ» . Tal ğ‘– Ã© dito uma cota inferior de ğ» . ğ» Ã© dito
limitado se Ã© limitado superiormente e inferiormente. Se ğ‘  Ã© cota superior (inferior) de
ğ» e ğ‘  âˆˆ ğ» , entÃ£o ğ‘  Ã© dito mÃ¡ximo (mÃ­nimo) de ğ» . Vale notar que se ğ» possui mÃ¡ximo
(ou mÃ­nimo) entÃ£o ele Ã© Ãºnico e isso nÃ£o Ã© verdade, em geral, quando falamos de cotas
(superiores ou inferiores).
Se ğ» Ã© limitado superiormente (inferiormente) e conjunto das cotas superiores (inferiores) possui mÃ­nimo (mÃ¡ximo), tal mÃ­nimo (mÃ¡ximo) Ã© chamado de supremo (Ã­nfimo) de
ğ».
Seja (ğ‘†, â‰¼) um conjunto ordenado. Dizemos que ğ‘† Ã© um reticulado se todo {ğ‘, ğ‘} âŠ† ğ‘†
possui supremo e Ã­nfimo. Denotamos tais supremo e Ã­nfimo por ğ‘ âˆ¨ ğ‘ e ğ‘ âˆ§ ğ‘, respectivamente.
Uma observaÃ§Ã£o importante Ã© a de que os operadores âˆ¨ e âˆ§ sÃ£o associativos. Vamos
provar apenas que âˆ¨ Ã© associativo (A associatividade de âˆ§ pode ser provada de modo
anÃ¡logo). Para isso, suponha que (ğ‘†, â‰¼) Ã© um reticulado e considere ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†. Defina

20
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

ğ‘  â€² = (ğ‘ âˆ¨ ğ‘) âˆ¨ ğ‘ e ğ‘  â€²â€² = ğ‘ âˆ¨ (ğ‘ âˆ¨ ğ‘). Assim, ğ‘  â€² â‰½ ğ‘ âˆ¨ ğ‘, isto Ã©, ğ‘  â€² â‰½ ğ‘ e ğ‘  â€² â‰½ ğ‘. AlÃ©m disso, ğ‘  â€² â‰½ ğ‘.
Logo, ğ‘  â€² â‰½ (ğ‘ âˆ¨ ğ‘) e ğ‘  â€² â‰½ ğ‘. DaÃ­, ğ‘  â€² Ã© cota superior de {ğ‘, ğ‘ âˆ¨ ğ‘} e, portanto, ğ‘  â€² â‰½ ğ‘ Îµ, pois Ã© ğ‘ Îµ Ã© a
menor das cotas superiores de {ğ‘, ğ‘ âˆ¨ ğ‘}. Analogamente, vem que ğ‘ Îµ â‰½ ğ‘  â€² . Pela propriedade
antissimÃ©trica de â‰¼, vem que ğ‘ Îµ = ğ‘  â€² , como querÃ­amos provar. Assim, podemos ocultar os
parÃªnteses e escrever ğ‘ âˆ¨ ğ‘ âˆ¨ ğ‘ (ou ğ‘ âˆ§ ğ‘ âˆ§ ğ‘) sem corrermos os risco de incorrermos em
ambiguidade.
Um reticulado (ğ‘†, â‰¼) Ã© dito distributivo quando o operador âˆ¨ se distribui em relaÃ§Ã£o ao
operador âˆ§ (e vice-versa), isto Ã©, para todo ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†, tem-se que ğ‘ âˆ¨ (ğ‘ âˆ§ ğ‘) = (ğ‘ âˆ¨ ğ‘) âˆ§ (ğ‘ âˆ¨ ğ‘)
e que ğ‘ âˆ§ (ğ‘ âˆ¨ ğ‘) = (ğ‘ âˆ§ ğ‘) âˆ¨ (ğ‘ âˆ§ ğ‘).

2.4.2

O conjunto dos emparelhamentos estÃ¡veis Ã© um reticulado
distributivo

Seja ğº = (ğ‘‰ = ğ´ âˆª ğµ, ğ¸, ğ¿) um grafo bipartido com preferÃªncias e denote por ğ‘†(ğº) o
conjunto dos emparelhamentos estÃ¡veis de ğº. Defina em ğ‘†(ğº) a relaÃ§Ã£o â‰¼ğ´ do seguinte
modo. Dados dois emparelhamentos estÃ¡veis ğ‘€1 e ğ‘€2 , ğ‘€1 â‰¼ğ´ ğ‘€2 se, e somente se, para
cada vÃ©rtice ğ‘ âˆˆ ğ´ tem-se que ğ‘€1 <ğ‘ ğ‘€2 ou ğ‘ Ã© indiferente a ğ‘€1 e ğ‘€2 .
O intuito desta seÃ§Ã£o Ã© provar o seguinte teorema.
Teorema 8. (ğ‘†(ğº), â‰¼ğ´ ) Ã© um reticulado distributivo.
Inicialmente, demonstremos que â‰¼ğ´ define uma ordem parcial em ğº.
Lema 2. â‰¼ğ´ Ã© uma ordem parcial em ğº.
DemonstraÃ§Ã£o. Considere abaixo que ğ‘€1 , ğ‘€2 e ğ‘€3 sÃ£o emparelhamento estÃ¡veis arbitrÃ¡rios
de ğº.
1. Para cada vÃ©rtice ğ‘ âˆˆ ğ´, de ğ‘€1 (ğ‘) = ğ‘€1 (ğ‘) segue trivialmente que ğ‘ Ã© indiferente a
ğ‘€1 e ğ‘€1 . Logo, â‰¼ğ´ Ã© reflexivo.
2. Se ğ‘€1 â‰¼ğ´ ğ‘€2 e ğ‘€2 â‰¼ğ´ ğ‘€3 , entÃ£o, para cada vÃ©rtice ğ‘ âˆˆ ğ´, tem-se que ğ‘€1 â‰¤ğ‘ ğ‘€2 e
ğ‘€2 â‰¤ğ‘ ğ‘€3 . Assim, pela transitividade de â‰¤ğ‘ , segue que ğ‘€1 â‰¤ğ‘ ğ‘€3 , para todo ğ‘ âˆˆ ğ´,
donde segue que ğ‘€1 â‰¼ğ´ ğ‘€3 . Portanto, â‰¼ğ´ Ã© transitivo.
3. Suponha que ğ‘€1 â‰¼ğ´ ğ‘€2 e ğ‘€2 â‰¼ğ´ ğ‘€1 e tome um vÃ©rtice ğ‘ âˆˆ ğ´. Por definiÃ§Ã£o de â‰¼ğ´ ,
tem-se que ğ‘€1 â‰¤ğ‘ ğ‘€2 e ğ‘€2 â‰¤ğ‘ ğ‘€1 . Se ğ‘ nÃ£o Ã© coberto por ğ‘€1 , de ğ‘€2 â‰¤ğ‘ ğ‘€1 , segue que
ğ‘ nÃ£o Ã© coberto por ğ‘€2 . Analogamente, se ğ‘ nÃ£o Ã© coberto por ğ‘€2 segue que ğ‘ nÃ£o Ã©
coberto por ğ‘€1 . Suponha entÃ£o que ğ‘ Ã© coberto por ğ‘€1 e ğ‘€2 . Assim, ğ‘€1 (ğ‘) â‰¤ğ‘ ğ‘€2 (ğ‘)
e ğ‘€1 (ğ‘) â‰¤ğ‘ ğ‘€2 (ğ‘). Se ğ‘€1 (ğ‘) â‰ ğ‘ ğ‘€2 (ğ‘), terÃ­amos que ğ‘€1 (ğ‘) <ğ‘ ğ‘€2 (ğ‘) e ğ‘€2 (ğ‘) <ğ‘ ğ‘€1 (ğ‘),
o que Ã© um absurdo. Logo, ğ‘€1 (ğ‘) = ğ‘€2 (ğ‘).
Assim, provamos que, para cada vÃ©rtice ğ‘ âˆˆ ğ´, ou ğ‘ nÃ£o Ã© coberto por ambos ğ‘€1 e ğ‘€2
, ou ğ‘ Ã© coberto por ğ‘€1 e por ğ‘€2 e ğ‘€1 (ğ‘) = ğ‘€2 (ğ‘). DaÃ­ segue que ğ‘€1 = ğ‘€2 . Portanto,
â‰¼ğ´ possui a propriedade antissimÃ©trica.

21
2.4 | ESTRUTURA ALGÃ‰BRICA DOS EMPARELHAMENTOS ESTÃVEIS

Assim, (ğ‘†, â‰¼ğ´ ) Ã© um conjunto ordenado. Vale notar que, em geral, â‰¼ğ´ nÃ£o Ã© uma ordem
total em ğº, como mostra o exemplo exibido na figura abaixo.
ğ‘1

ğ‘1

ğ‘2

ğ‘2

ğ‘3

ğ‘3

ğ‘4

ğ‘4

ğ‘1
ğ‘2
ğ‘3
ğ‘4

âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘2
ğ‘1
ğ‘3
ğ‘4

ğ‘1
ğ‘2
ğ‘4
ğ‘3

ğ‘3
ğ‘4
ğ‘1
ğ‘1

ğ‘4
ğ‘3
ğ‘2
ğ‘2

ğ‘1
ğ‘2
ğ‘3
ğ‘4

âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘1
ğ‘2
ğ‘4
ğ‘3

ğ‘2
ğ‘1
ğ‘3
ğ‘4

ğ‘4
ğ‘4
ğ‘2
ğ‘1

ğ‘3
ğ‘3
ğ‘1
ğ‘2

Figura 2.5: Considere o grafo de preferÃªncias definido por meio da figura acima, onde Ã  direita estÃ£o indicadas as listas de preferÃªncias de cada vÃ©rtice em ordem decrescente de preferÃªncia (por exemplo, ğ‘2 prefere ğ‘2 a ğ‘3 ). Ã‰ possÃ­vel verificar que ğ‘€1
=
{ğ‘1 ğ‘2 , ğ‘2 ğ‘1 , ğ‘3 ğ‘4 , ğ‘4 ğ‘3 } e
ğ‘€2 = {ğ‘1 ğ‘1 , ğ‘2 ğ‘2 , ğ‘3 ğ‘3 , ğ‘4 ğ‘4 } sÃ£o emparelhamentos estÃ¡veis. Note que ğ‘€2 (ğ‘1 ) = ğ‘1 â‰¤ğ‘1 ğ‘2 = ğ‘€1 (ğ‘1 )
e, logo, nÃ£o Ã© o caso que ğ‘€1 â‰¼ğ´ ğ‘€2 . Por outro lado, ğ‘€1 (ğ‘3 ) = ğ‘4 â‰¤ğ‘3 ğ‘3 = ğ‘€2 (ğ‘3 ) e, logo, Ã© falso que
ğ‘€2 â‰¼ğ´ ğ‘€1 . Portanto, ğ‘€1 e ğ‘€2 nÃ£o sÃ£o comparÃ¡veis por â‰¼ğ´ .

O natural seria provar agora que (ğ‘†, â‰¼ğ´ ) Ã© um reticulado, o que virÃ¡ como consequÃªncia
do lema abaixo.
Lema 3. Sejam ğ‘€1 e ğ‘€2 dois emparelhamentos estÃ¡veis. Seja ğ‘€ o conjunto de arestas definido
da seguinte forma. Para cada vÃ©rtice ğ‘ âˆˆ ğ´ tal que ğ‘ Ã© coberto por ğ‘€1 ou Ã© coberto por ğ‘€2 , se
ğ‘€1 â‰¤ğ‘ ğ‘€2 , ğ‘ğ‘€2 (ğ‘) âˆˆ ğ‘€. Caso contrÃ¡rio, ğ‘ğ‘€1 (ğ‘) âˆˆ ğ‘€. Temos que ğ‘€ Ã© um emparelhamento
estÃ¡vel.
DemonstraÃ§Ã£o. Primeiramente, provemos que ğ‘€ Ã© um emparelhamento. Pela definiÃ§Ã£o
de ğ‘€, fica claro que ğ‘ Ã© extremo de no mÃ¡ximo uma aresta em ğ‘€ para todo ğ‘ âˆˆ ğ´. Seja
ğ‘ âˆˆ ğµ coberto por ğ‘€. Para provar o requerido, Ã© suficiente provar que ğ‘ğ‘, ğ‘â€² ğ‘ âˆˆ ğ‘€ implica
ğ‘ = ğ‘â€² . Note que ğ‘ğ‘ e ğ‘ğ‘ â€² sÃ£o arestas de ğ‘€1 âˆª ğ‘€2 . Assim, no caso de ambas pertencerem a
ğ‘€1 ou de ambas pertencerem a ğ‘€2 , segue, da definiÃ§Ã£o de emparelhamento, que ğ‘ = ğ‘â€² .
Suponha entÃ£o, sem perda de generalidade, que ğ‘ğ‘ âˆˆ ğ‘€1 e ğ‘â€² ğ‘ âˆˆ ğ‘€2 . Como ğ‘ğ‘ âˆˆ ğ‘€1 e
ğ‘ğ‘ âˆˆ ğ‘€, temos, pela definiÃ§Ã£o de ğ‘€, que ğ‘€2 (ğ‘) â‰¤ğ‘ ğ‘ e isso, por sua vez, pelo fato de ğ‘€2
ser um emparelhamento estÃ¡vel, implica que ğ‘ â‰¤ğ‘ ğ‘â€² (Caso contrÃ¡rio, ğ‘â€² ğ‘ seria uma aresta
bloqueadora de ğ‘€2 ). De modo inteiramente anÃ¡logo, conclui-se que ğ‘â€² â‰¤ğ‘ ğ‘. Logo, ğ‘ = ğ‘â€² .
Isso prova que ğ‘€ Ã© um emparelhamento.
Resta-nos provar que ğ‘€ Ã© um emparelhamento estÃ¡vel. Suponha, por absurdo, que ğ‘ğ‘
Ã© uma aresta bloqueadora de ğ‘€. Assim, (ğ‘ nÃ£o Ã© coberto por ğ‘€ ou ğ‘€(ğ‘) <ğ‘ ğ‘) e (ğ‘ nÃ£o Ã©
coberto por ğ‘€ ou ğ‘€(ğ‘) <ğ‘ ğ‘). Consideremos 2 casos:
1. ğ‘ nÃ£o Ã© coberto por ğ‘€: Nesse caso, se ğ‘ tambÃ©m nÃ£o Ã© coberto por ğ‘€, terÃ­amos
que ğ‘ğ‘ claramente bloqueia ğ‘€1 e ğ‘€2 . Suponha entÃ£o que ğ‘ Ã© coberto por ğ‘€ e
ğ‘€(ğ‘) <ğ‘ ğ‘. Assim, pela definiÃ§Ã£o de ğ‘€, terÃ­amos duas possibilidades: ğ‘€(ğ‘) = ğ‘€1 (ğ‘)
ou ğ‘€(ğ‘) = ğ‘€2 (ğ‘). A primeira implicaria que ğ‘ğ‘ bloqueia ğ‘€1 e a segunda implicaria
que ğ‘ğ‘ bloqueia ğ‘€2 .

22
2 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS BIPARTIDOS

2. ğ‘ Ã© coberto por ğ‘€: Nesse caso, ğ‘€(ğ‘) <ğ‘ ğ‘ (ğ¼ ). Note que ğ‘€(ğ‘) = ğ‘€1 (ğ‘) ou ğ‘€(ğ‘) = ğ‘€2 (ğ‘).
Assim, se ğ‘ nÃ£o fosse coberto por ğ‘€, ğ‘ğ‘ bloquearia ğ‘€1 ou ğ‘€2 , o que nÃ£o pode ocorrer
jÃ¡ que ğ‘€1 e ğ‘€2 sÃ£o emparelhamento estÃ¡veis por hipÃ³tese. DaÃ­, ğ‘ Ã© coberto por ğ‘€ e
ğ‘€(ğ‘) <ğ‘ ğ‘. Considere a partir de agora que ğ‘€(ğ‘) = ğ‘€1 (ğ‘) (o outro caso Ã© anÃ¡logo).
Se ğ‘€(ğ‘) = ğ‘€1 (ğ‘), entÃ£o ğ‘ğ‘ bloquearia ğ‘€1 . Logo, ğ‘€(ğ‘) = ğ‘€2 (ğ‘). Mas, pela definiÃ§Ã£o
de ğ‘€ e (ğ¼ ), segue que ğ‘€1 (ğ‘) â‰¤ğ‘ ğ‘€2 (ğ‘) = ğ‘€(ğ‘) <ğ‘ ğ‘, donde segue que ğ‘ğ‘ bloqueia ğ‘€1 ,
o que Ã© uma contradiÃ§Ã£o.

Em outras palavras, o que o lema 3 nos revela Ã© que, dados dois emparelhamentos
estÃ¡veis quaisquer, o emparelhamento obtido tomando-se para cada vÃ©rtice de ğ´ o seu
parceiro preferido em relaÃ§Ã£o aos dois emparelhamentos Ã© um emparelhamento estÃ¡vel.
Assim, sendo ğ‘€1 , ğ‘€2 e ğ‘€ como no enunciado do 3, Ã© claro que ğ‘€ Ã© cota superior de ğ‘€1 e
ğ‘€2 em relaÃ§Ã£o Ã  ordem â‰¼ğ´ . Mais ainda, ğ‘€ Ã© a menor das cotas superiores (isto Ã©, supremo)
de {ğ‘€1 , ğ‘€2 }. De fato, se ğ‘€ â€² Ã© um emparelhamento estÃ¡vel tal que ğ‘€ â€² â‰¼ğ´ ğ‘€1 e ğ‘€ â€² â‰¼ğ´ ğ‘€2 ,
entÃ£o, para todo ğ‘ âˆˆ ğ´, ğ‘€ â€² (ğ‘) â‰¤ğ‘ ğ‘€1 (ğ‘) e ğ‘€ â€² (ğ‘) â‰¤ğ‘ ğ‘€2 (ğ‘), donde ğ‘€(ğ‘) â‰¤ğ‘ ğ‘€ â€² (ğ‘). Logo,
ğ‘€ â€² (ğ‘) â‰¤ğ‘ ğ‘€1 (ğ‘). Assim, provamos que ğ‘€ Ã© menor (segundo â‰¼ğ´ ) que qualquer cota superior
de {ğ‘€1 , ğ‘€2 }. Assim, ğ‘€ = ğ‘€1 âˆ¨ ğ‘€2 .
Dados dois emparelhamentos estÃ¡veis ğ‘€1 e ğ‘€2 e definindo ğ‘€ â€² como o conjunto de
arestas dado tomando-se, para cada ğ‘ âˆˆ ğ´ tal que ğ‘ Ã© coberto por ğ‘€1 ou ğ‘€2 , a aresta de
menor preferÃªncia (com respeito a ğ‘) dentre ğ‘ğ‘€1 (ğ‘) e ğ‘ğ‘€2 (ğ‘), Ã© possÃ­vel provar que ğ‘€ â€²
Ã© um emparelhamento estÃ¡vel e que ğ‘€ â€² = ğ‘€1 âˆ§ ğ‘€2 . A prova Ã© inteiramente anÃ¡loga Ã  do
caso âˆ¨. Portanto, (ğ‘†(ğº), â‰¼) Ã©, de fato, um reticulado.
Estamos agora em condiÃ§Ãµes de provar a existÃªncia do emparelhamento ğ´-Ã³timo sem
lanÃ§ar mÃ£o do algoritmo de Gale-Shapley. NÃ£o sÃ³ isso, obtemos uma descriÃ§Ã£o elegante
puramente algÃ©brica de tal objeto. Note que, usando a terminologia de Teoria da Ordem
exposta na seÃ§Ã£o anterior, Ã© fÃ¡cil ver que:

ğ‘€ Ã© ğ´-Ã³timo âŸº ğ‘€ â‰½ğ´ ğ‘€ â€² para qualquer emparelhamento estÃ¡vel ğ‘€ â€² .(ğ¼ )
.
Considere que ğ‘†(ğº) = {ğ‘€1 , ..., ğ‘€ğ‘Ÿ } para algum ğ‘Ÿ natural (Note que ğ‘†(ğº) Ã© finito pois o
nÃºmero de emparelhamentos Ã© finito) e defina ğ‘€ = ğ‘€1 âˆ¨ ğ‘€2 âˆ¨ ğ‘€3 âˆ¨ ... âˆ¨ ğ‘€ğ‘Ÿ . DaÃ­, ğ‘€ â‰½ ğ‘€ğ‘– para
todo ğ‘–, donde, por (ğ¼ ), concluÃ­mos que ğ‘€ Ã© ğ´-Ã³timo. Substituindo no argumento acima âˆ¨
por âˆ§ obtemos uma descriÃ§Ã£o do emparelhamento ğµ-Ã³timo.
Para encerrarmos a seÃ§Ã£o, resta-nos provar que (ğ‘†(ğº), â‰¼) Ã© distributivo. Primeiramente
provemos um lema que simplificarÃ¡ a prova de tal fato.
Lema 4. Seja (ğ‘†, â‰¼) um reticulado. EntÃ£o âˆ§ se distribui em relaÃ§Ã£o ao operador âˆ¨ se, e somente
se, âˆ¨ se distribui em relaÃ§Ã£o ao operador âˆ§.
DemonstraÃ§Ã£o. Por simetria, basta provarmos um sentido da equivalÃªncia do enunciado.
Deste modo, suponha que âˆ§ se distribui em relaÃ§Ã£o ao operador âˆ¨ (ğ¼ ). DaÃ­, dados ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†,

23
2.4 | ESTRUTURA ALGÃ‰BRICA DOS EMPARELHAMENTOS ESTÃVEIS

temos:
(ğ‘ âˆ¨ ğ‘) âˆ§ (ğ‘ âˆ¨ ğ‘) = ((ğ‘ âˆ¨ ğ‘) âˆ§ ğ‘) âˆ¨ ((ğ‘ âˆ¨ ğ‘) âˆ§ ğ‘), por (I)
= ((ğ‘ âˆ§ ğ‘) âˆ¨ (ğ‘ âˆ§ ğ‘)) âˆ¨ ((ğ‘ âˆ§ ğ‘) âˆ¨ (ğ‘ âˆ§ ğ‘)), novamente por (I)
= (ğ‘ âˆ¨ (ğ‘ âˆ§ ğ‘)) âˆ¨ ((ğ‘ âˆ§ ğ‘) âˆ¨ (ğ‘ âˆ§ ğ‘)), pois ğ‘ = ğ‘ âˆ§ ğ‘
= (ğ‘ âˆ¨ (ğ‘ âˆ§ ğ‘) âˆ¨ (ğ‘ âˆ§ ğ‘)) âˆ¨ (ğ‘ âˆ§ ğ‘), pois âˆ¨ Ã© associativo
= ğ‘ âˆ¨ (ğ‘ âˆ§ ğ‘), pois ğ‘ Ã© claramente o mÃ¡ximo de {ğ‘, ğ‘ âˆ§ ğ‘, ğ‘ âˆ§ ğ‘}.

Segue abaixo a demonstraÃ§Ã£o do Teorema 8.
DemonstraÃ§Ã£o. Pelo exposto anteriormente, segue que (ğ‘†(ğº), â‰¼) Ã© um reticulado. O Lema
4 nos garante que basta demonstrarmos que âˆ§ distribui em relaÃ§Ã£o a âˆ¨ para provarmos o
Teorema.
Sejam ğ‘€1 , ğ‘€2 , ğ‘€3 emparelhamentos estÃ¡veis. Considere ğ‘€ âˆ¶= ğ‘€1 âˆ§ (ğ‘€2 âˆ¨ ğ‘€3 ) e ğ‘€ â€² âˆ¶=
(ğ‘€1 âˆ§ ğ‘€2 ) âˆ¨ (ğ‘€1 âˆ§ ğ‘€3 ).
Tome ğ‘ âˆˆ ğ´. Inicialmente, suponha que ğ‘ nÃ£o Ã© coberto por ğ‘€. EntÃ£o ğ‘ nÃ£o Ã© coberto
por ğ‘€1 (ğ¼ ) ou ğ‘ nÃ£o Ã© coberto por ğ‘€2 âˆ¨ ğ‘€3 (ğ¼ ğ¼ ). Se (ğ¼ ), terÃ­amos que ğ‘ nÃ£o Ã© coberto nem
por ğ‘€1 âˆ¨ ğ‘€2 e nem por ğ‘€1 âˆ¨ ğ‘€3 e, logo, se seguiria que ğ‘ nÃ£o Ã© coberto por ğ‘€ â€² . No caso (ğ¼ ğ¼ ),
obterÃ­amos que ğ‘ nÃ£o Ã© coberto nem por ğ‘€2 e nem por ğ‘€3 , donde se seguiria facilmente que
ğ‘ nÃ£o Ã© coberto por ğ‘€1 âˆ§ ğ‘€2 e ğ‘€1 âˆ§ ğ‘€3 , isto Ã©, que ğ‘ nÃ£o Ã© coberto por ğ‘€ â€² . Reciprocamente,
suponha que ğ‘ nÃ£o Ã© coberto por ğ‘€ â€² . Disso segue que ğ‘ nÃ£o Ã© coberto por ğ‘€1 âˆ§ ğ‘€2 e nem
por ğ‘€1 âˆ§ ğ‘€3 , donde vem que, ou ğ‘ nÃ£o Ã© coberto por ğ‘€1 , ou ğ‘ Ã© coberto por ğ‘€1 mas nÃ£o
Ã© coberto nem por ğ‘€2 e nem por ğ‘€3 . Em qualquer um dos casos, obtemos que ğ‘ nÃ£o Ã©
coberto por ğ‘€. Logo, concluÃ­mos que (ğ‘ nÃ£o Ã© coberto por ğ‘€ âŸº ğ‘ nÃ£o Ã© coberto por
ğ‘€ â€² ) para todo ğ‘ âˆˆ ğ´.
Agora, tome ğ‘ âˆˆ ğ´ e suponha que ğ‘ Ã© coberto por ğ‘€ (e, portanto, coberto por ğ‘€ â€² ).
Suponha, sem perda de generalidade, que ğ‘€2 â‰¤ğ‘ ğ‘€3 . Ã‰ fÃ¡cil ver que isso implica que ğ‘ deve
ser coberto por ğ‘€1 e por ğ‘€3 (e, logo, por ğ‘€2 âˆ¨ ğ‘€3 ). Pela caracterizaÃ§Ã£o dos operadores
âˆ¨ e âˆ§, temos que ğ‘€(ğ‘) = ğ‘€1 (ğ‘) (ğ¼ ) ou ğ‘€(ğ‘) = ğ‘€3 (ğ‘) (ğ¼ ğ¼ ). Supondo (ğ¼ ), vem que (ğ‘€1 âˆ§
ğ‘€3 )(ğ‘) = ğ‘€3 (ğ‘) e, como ğ‘€2 â‰¼ğ‘ ğ‘€3 , concluÃ­mos que ğ‘€3 (ğ‘) â‰¥ğ‘ (ğ‘€2 âˆ§ ğ‘€1 )(ğ‘), de modo que
ğ‘€ â€² (ğ‘) = ğ‘€3 (ğ‘) = ğ‘€(ğ‘). Supondo (ğ¼ ğ¼ ), vem que ğ‘€3 â‰¤ğ‘ ğ‘€1 . DaÃ­, (ğ‘€1 âˆ§ ğ‘€3 )(ğ‘) = ğ‘€3 (ğ‘) e, como
ğ‘€2 â‰¤ğ‘ ğ‘€3 â‰¤ğ‘ , segue que (ğ‘€1 âˆ§ ğ‘€2 )(ğ‘) = ğ‘€2 (ğ‘). Finalmente, dado que ğ‘€2 â‰¤ğ‘ ğ‘€3 , vem que
ğ‘€ â€² (ğ‘) = ğ‘€3 (ğ‘) = ğ‘€(ğ‘). Isso encerra a demonstraÃ§Ã£o.

25

CapÃ­tulo 3
Emparelhamentos EstÃ¡veis em
Grafos Quaisquer
O nosso objeto de estudo principal do capÃ­tulo anterior eram grafos de preferÃªncias com
a propriedade particular de possuÃ­rem uma bipartiÃ§Ã£o. Vimos, por exemplo, que em tais
grafos Ã© possÃ­vel garantir a existÃªncia de ao menos um emparelhamento estÃ¡vel. Portanto,
ao considerarmos grafos quaisquer, uma pergunta natural seria se ainda podemos fazer tal
garantia. Infelizmente, a resposta Ã© negativa. A figura abaixo define um exemplo de um
grafo de preferÃªncias que nÃ£o possui emparelhamento estÃ¡vel.

ğ‘

ğ‘
ğ‘âˆ¶ğ‘ğ‘
ğ‘âˆ¶ğ‘ğ‘
ğ‘âˆ¶ğ‘ğ‘

ğ‘
Figura 3.1: Primeiramente, vale recordar que todo emparelhamento estÃ¡vel Ã© maximal (Fato
observado imediatamente apÃ³s a definiÃ§Ã£o de emparelhamento estÃ¡vel no capÃ­tulo 2). Assim, os
candidatos a emparelhamentos estÃ¡veis sÃ£o ğ‘€1 = {ğ‘ğ‘}, ğ‘€2 = {ğ‘ğ‘}, ğ‘€3 = {ğ‘ğ‘}. No entanto, ğ‘ğ‘, ğ‘ğ‘, e
ğ‘ğ‘ bloqueiam ğ‘€1 , ğ‘€2 e ğ‘€3 , respectivamente.

Knuth [7] chegou a conjecturar que o problema de decidir se um grafo de preferÃªncias
arbitrÃ¡rio possui algum emparelhamento estÃ¡vel seria ğ‘ ğ‘ƒ-completo. No entanto, Irving
[5] refutou essa hipÃ³tese, elaborando um algoritmo que, em tempo linear, decide se um
grafo de preferÃªncias possui um emparelhamento estÃ¡vel e, em caso positivo, devolve um.
Neste capÃ­tulo, descreveremos tal algoritmo e provaremos a sua corretude.

26
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

3.1

Algoritmo de Irving

Para facilitar a compreensÃ£o, o algoritmo de Irving Ã© classicamente subdividido em
duas etapas.

3.1.1

Primeira etapa

Esta etapa consiste em realizar um prÃ©-processamento no grafo de preferÃªncias dado
como entrada. Tal prÃ©-processamento possui bastante semelhanÃ§as com o algoritmo estendido de Gale-Shapley no sentido que arestas nÃ£o estÃ¡veis (isto Ã©, arestas que nÃ£o
aparecem em nenhum emparelhamento estÃ¡vel) sÃ£o removidas resultando num grafo com
algumas propriedades especiais. Apresentamos a seguir uma descriÃ§Ã£o em alto nÃ­vel do
algoritmo.
Considere que ğº Ã© o grafo de preferÃªncias dado como entrada. Defina ğº â€² âˆ¶= ğº e
um conjunto ğ¹ , denominado como o conjunto dos vÃ©rtices livres de ğº â€² . Inicialmente,
esse conjunto corresponde a todos os vÃ©rtices de ğº â€² . AlÃ©m disso, considere um conjunto ğ‘† de pares ordenados de vÃ©rtices de ğº â€² . Se (ğ‘£, ğ‘¤) âˆˆ ğ‘†, entÃ£o diremos que ğ‘£ estÃ¡
semi-comprometido com ğ‘¤. Enquanto ğ¹ apresentar vÃ©rtices de grau nÃ£o-nulo em ğº â€² o
algoritmo procede realizando os seguintes passos em sequÃªncia:
1. Remove um vÃ©rtice ğ‘£ de ğ¹ de grau nÃ£o-nulo em ğº â€² .
2. Considere que ğ‘¤ Ã© o vizinho preferido de ğ‘£ em ğº â€² . ğ‘£ passa a ficar semi-comprometido
com ğ‘¤, isto Ã©, fazemos ğ‘† âˆ¶= ğ‘† âˆª {(ğ‘£, ğ‘¤)}.
3. Se algum vÃ©rtice ğ‘¢ â‰  ğ‘£ estava semi-comprometido com ğ‘¤, (ğ‘¢, ğ‘¤) Ã© removido de ğ‘† e
ğ‘¢ Ã© adicionado de volta a ğ¹ .
4. Todas as arestas ğ‘¤ğ‘¥ em ğº tais que ğ‘£ >ğ‘¤ ğ‘¥ sÃ£o removidas de ğº.
Note que quando um par (ğ‘¢, ğ‘¤) Ã© removido de ğ‘† no passo 3, a aresta correspondente
ğ‘¢ğ‘¤ certamente Ã© removida no passo 4. Isso garante que tal par (ğ‘¢, ğ‘¤) nÃ£o serÃ¡ considerado
novamente. Assim, como a cada execuÃ§Ã£o dos passos acima, um novo par (ğ‘£, ğ‘¤) Ã© considerado no passo 2, podemos afirmar que o algoritmo para em no mÃ¡ximo 2ğ‘š execuÃ§Ãµes do
laÃ§o acima, onde ğ‘š Ã© o nÃºmero de arestas de ğº. Deste modo, em algum instante, ou ğ¹ = âˆ…
ou todos os vÃ©rtices presentes em ğ¹ sÃ£o isolados em ğº.
Finalmente, o algoritmo procede removendo os vÃ©rtices isolados de ğº â€² . A saÃ­da do

27
3.1 | ALGORITMO DE IRVING

algoritmo Ã© o grafo ğº â€² . Abaixo temos uma descriÃ§Ã£o formal do algoritmo.
Algoritmo 3: Primeira etapa do algoritmo de Irving.
Entrada: Um grafo de preferÃªncias ğº = (ğ‘‰ , ğ¸, ğ¿)
SaÃ­da: Um subgrafo com preferÃªncias ğº â€² de ğº
1 inÃ­cio
2
FaÃ§a ğ¹ âˆ¶= ğ‘‰ , ğ‘† âˆ¶= âˆ… e ğº â€² âˆ¶= ğº
3
enquanto existe ğ‘£ âˆˆ ğ¹ nÃ£o isolado em ğº â€² faÃ§a
4
Seja ğ‘¤ o vizinho preferido de ğ‘£ em ğº â€²
5
se existe ğ‘¢ âˆˆ ğ‘‰ tal que (ğ‘¢, ğ‘¤) âˆˆ ğ‘† entÃ£o
6
ğ‘† âˆ¶= ğ‘† â§µ {(ğ‘¢, ğ‘¤)}
7
ğ¹ âˆ¶= ğ¹ âˆª {ğ‘¢}
8

10

ğ‘† âˆ¶= ğ‘† âˆª {(ğ‘£, ğ‘¤)}
para cada ğ‘¥ âˆˆ ğ‘‰ vizinho de ğ‘¤ em ğº â€² tal que ğ‘¥ <ğ‘¤ ğ‘£ faÃ§a
ğº â€² âˆ¶= ğº â€² âˆ’ {ğ‘¥ğ‘¤}

11

ğ‘‰ (ğº â€² ) âˆ¶= {ğ‘£ âˆˆ ğ‘‰ (ğº â€² ) âˆ¶ ğ‘£ nÃ£o Ã© isolado em ğº â€² }

9

12

retorna Gâ€™

Na discussÃ£o abaixo, considere que ğ¹ âˆ— e ğ‘† âˆ— sÃ£o os estados de ğ¹ e ğ‘† ao final da execuÃ§Ã£o
do algoritmo.
O grafo produzido pelo algoritmo acima ao aplicÃ¡-lo em um grafo de preferÃªncias ğº
serÃ¡ denotado por ğº1 . Uma observaÃ§Ã£o importante Ã© que ao longo da execuÃ§Ã£o do loop
principal temos a seguinte invariante para todo ğ‘£, ğ‘¤ âˆˆ ğ‘‰ : (ğ‘£, ğ‘¤) âˆˆ ğ‘† âŸ¹ ğ‘£ğ‘¤ âˆˆ ğ¸(ğº â€² ).
De fato, supondo que em algum momento durante a execuÃ§Ã£o do algoritmo tivÃ©ssemos
(ğ‘£, ğ‘¤) âˆˆ ğ‘† tal que ğ‘£ğ‘¤ âˆ‰ ğ¸(ğº â€² ), a remoÃ§Ã£o de tal ğ‘£ğ‘¤ sÃ³ poderia ter sido devido algum
vÃ©rtice ğ‘¢ ter ficado semi-comprometido com ğ‘£ tal que ğ‘¤ <ğ‘£ ğ‘¢. Isso, no entanto, entraria
em contradiÃ§Ã£o com o fato de ğ‘¤ ter sido em algum instante anterior o vizinho preferido
de ğ‘£ em ğº â€² (jÃ¡ que ele ficou semi-comprometido com ğ‘¤).
Outra observaÃ§Ã£o Ãºtil Ã© a de que se ğ‘£ âˆˆ ğ‘‰ (ğº1 ) entÃ£o existe vÃ©rtice ğ‘¢ tal que ğ‘¢ estÃ¡ semicomprometido com ğ‘£ ao final do algoritmo. De fato, sendo ğ‘£ âˆˆ ğ‘‰ (ğº1 ) segue que ğ‘£ nÃ£o foi
removido na linha 11 e, portanto, ğ‘£ âˆ‰ ğ¹ âˆ— , donde conclui-se que ğ‘£ estÃ¡ semi-comprometido
com algum vÃ©rtice ğ‘¤ de ğº, isto Ã©, (ğ‘£, ğ‘¤) âˆˆ ğ‘† âˆ— . Assim, ğ‘£ğ‘¤ âˆˆ ğ¸(ğº1 ) (pela observaÃ§Ã£o do
parÃ¡grafo anterior) e ğ‘¤ âˆˆ ğ‘‰ (ğº1 ) e, de modo anÃ¡logo, concluÃ­mos que existe ğ‘¢0 âˆˆ ğ‘‰ (ğº1 ) tal
que (ğ‘¤, ğ‘¢0 ) âˆˆ ğ‘† âˆ— . Se ğ‘¢0 = ğ‘£, acabou. Caso contrÃ¡rio, existe ğ‘¢1 tal que (ğ‘¢0 , ğ‘¢1 ) âˆˆ ğ‘† âˆ— . Se ğ‘¢1 = ğ‘£,
acabou. Note que ğ‘¢1 âˆ‰ {ğ‘¢0 , ğ‘¤} (jÃ¡ que cada vÃ©rtice sÃ³ pode estar semi-comprometido com
no mÃ¡ximo um vÃ©rtice). Como o nÃºmero de vÃ©rtices Ã© finito, procedendo dessa forma,
encontraremos ğ‘¢ğ‘– tal que ğ‘£ = ğ‘¢ğ‘– e (ğ‘¢ğ‘–âˆ’1 , ğ‘¢ğ‘– ) âˆˆ ğ‘† âˆ— e assim, segue o requerido.
Antes de enunciarmos algumas propriedades de ğº1 convÃ©m introduzir a seguinte
terminologia: Dado um vÃ©Å•tice ğ‘£ de um grafo de preferÃªncias ğº, ğ‘“ğº (ğ‘£) Ã© o vizinho de ğ‘£
preferido em ğº; ğ‘ ğº (ğ‘£) Ã© o segundo vizinho preferido de ğ‘£ em ğº e ğ‘™ğº (ğ‘£) Ã© o vizinho menos
preferido de ğ‘£ em ğº. Note que ğ‘“ğº (ğ‘£) e ğ‘™ğº (ğ‘£) nÃ£o estÃ£o bem definidos quando ğ‘£ Ã© isolado
e ğ‘ ğº (ğ‘£) nÃ£o estÃ¡ bem quando ğ‘£ tem grau menor que 2. O subscrito ğº pode ser omitido
quando fica claro pelo contexto o grafo de preferÃªncias que estÃ¡ sendo referido.

28
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

Lema 5.

1. ğ‘¤ = ğ‘“ğº1 (ğ‘£) se, e somente se, ğ‘£ = ğ‘™ğº1 (ğ‘¤).

2. Sejam ğ‘£, ğ‘¤ âˆˆ ğ‘‰ (ğº1 ) tais que ğ‘£ğ‘¤ âˆˆ ğ¸(ğº). EntÃ£o ğ‘£ğ‘¤ nÃ£o Ã© aresta de ğº1 se, e somente se,
ğ‘£ prefere ğ‘™ğº1 (ğ‘£) a ğ‘¤ em ğº ou ğ‘¤ prefere ğ‘™ğº1 (ğ‘¤) a ğ‘£ em ğº.
DemonstraÃ§Ã£o.
1. Vale notar que todo vÃ©rtice ğ‘£ de ğ‘‰ (ğº1 ) Ã© nÃ£o isolado e, portanto,
ğ‘“ğº1 (ğ‘£) e ğ‘™ğº1 (ğ‘£) estÃ£o bem definidos. Inicialmente, vamos provar que ğ‘£ = ğ‘™ğº1 (ğ‘¤) se,
e somente se, (ğ‘£, ğ‘¤) âˆˆ ğ‘† âˆ— . De fato, se (ğ‘£, ğ‘¤) âˆˆ ğ‘† ao final do algoritmo, entÃ£o, pela
descriÃ§Ã£o do algoritmo, todas as arestas ğ‘¤ğ‘¥ tais que ğ‘£ >ğ‘¤ ğ‘¥ foram removidas de
ğº1 . AlÃ©m disso, como (ğ‘£, ğ‘¤) âˆˆ ğ‘† âˆ— entÃ£o ğ‘£ğ‘¤ âˆˆ ğ¸(ğº1 ). DaÃ­, ğ‘£ = ğ‘™ğº1 (ğ‘¤). Para provar
a recÃ­proca, suponha que ğ‘£ = ğ‘™ğº1 (ğ‘¤). Isso implica, em particular, que ğ‘£ğ‘¤ âˆˆ ğ¸(ğº1 ).
Assim, ğ‘¤ nÃ£o Ã© isolado em ğº1 e todo vÃ©rtice nÃ£o isolado em ğº1 possui um vÃ©rtice ğ‘¢
tal que (ğ‘¢, ğ‘¤) âˆˆ ğ‘† âˆ— (fato observado acima). Assim, ğ‘¢ğ‘¤ âˆˆ ğ¸(ğº1 ) e todas as arestas ğ‘¤ğ‘¥
tais que ğ‘¥ <ğ‘¤ ğ‘¢ foram removidas, donde ğ‘¢ = ğ‘™ğº1 (ğ‘¤) = ğ‘£ e a conclusÃ£o se segue.
Resta-nos provar que ğ‘¤ = ğ‘“ğº1 (ğ‘£) se, e somente se, (ğ‘£, ğ‘¤) âˆˆ ğ‘† âˆ— . De fato, se (ğ‘£, ğ‘¤) âˆˆ ğ‘† âˆ— ,
entÃ£o ğ‘£ğ‘¤ âˆˆ ğ¸(ğº1 ) e, pela descriÃ§Ã£o do algoritmo, segue que ğ‘¤ Ã© o vizinho preferido
de ğ‘£ em ğº1 . Reciprocamente, suponha que ğ‘¤ = ğ‘“ğº1 (ğ‘£). Assim, ğ‘£ğ‘¤ âˆˆ ğ¸(ğº1 ) e, portanto,
ğ‘£ nÃ£o Ã© isolado em ğº1 . Disso vem que ğ‘£ âˆ‰ ğ¹ âˆ— e, logo, existe vÃ©rtice ğ‘¢ tal que (ğ‘£, ğ‘¢) âˆˆ ğ‘† âˆ—
e, assim, fica claro que ğ‘¢ Ã© o vÃ©rtice menos preferido de ğ‘£ em ğº1 . Logo, ğ‘¤ = ğ‘¢ e o
resultado segue.
2. Se ğ‘£ğ‘¤ nÃ£o Ã© aresta de ğº1 , pela descriÃ§Ã£o do algoritmo, segue que ğ‘£ğ‘¤ foi removido
ou devido a algum vÃ©rtice ğ‘¢ ter ficado semi-comprometido com ğ‘£ e ğ‘¢ >ğ‘£ ğ‘¤ (ğ¼ ) ou
devido a algum vÃ©rtice ğ‘¢ â€² ter ficado semi-comprometido com ğ‘¤ tal que ğ‘¢ â€² >ğ‘¤ ğ‘£ (ğ¼ ğ¼ ).
Suponha (ğ¼ ) (a prova para o caso (ğ¼ ğ¼ ) Ã© anÃ¡loga). Assim, temos que ğ‘£ğ‘¥ foi removido
para todos os vÃ©rtices ğ‘¥ tal que ğ‘¢ >ğ‘£ ğ‘¥ e, portanto, ğ‘¤ <ğ‘£ ğ‘¢ â‰¤ğ‘£ ğ‘™ğº1 (ğ‘£), donde, por
transitividade, ğ‘¤ <ğ‘£ ğ‘™ğº1 (ğ‘£), como querÃ­amos.
Reciprocamente, suponha, sem perda de generalidade, que ğ‘¢ âˆ¶= ğ‘™ğº1 (ğ‘£) <ğ‘£ ğ‘¤ e,
pela prova do item anterior, ğ‘¢ esteve comprometido com ğ‘£ em algum momento do
algoritmo, implicando que todas as arestas ğ‘£ğ‘¥ tal que ğ‘¥ <ğ‘£ ğ‘¢ foram removidas de ğº
e, em particular, a aresta ğ‘£ğ‘¤.

O lema abaixo expÃµe informaÃ§Ãµes que podem ser obtidas de ğº1 sobre emparelhamentos
estÃ¡veis em ğº.
Lema 6.
1. Se ğ‘£ğ‘¤ Ã© uma aresta de ğº que nÃ£o Ã© uma aresta de ğº1 , entÃ£o ğ‘£ğ‘¤ nÃ£o Ã© estÃ¡vel
em ğº.
2. Se ğ‘£ğ‘¤ Ã© uma aresta de ğº e ğ‘£ e ğ‘¤ nÃ£o sÃ£o vÃ©rtices de ğº1 , entÃ£o ğº nÃ£o apresenta
emparelhamentos estÃ¡veis.
DemonstraÃ§Ã£o.
1. Seja ğ‘£ğ‘¤ âˆˆ ğ¸(ğº) tal que ğ‘£ğ‘¤ âˆ‰ ğ¸(ğº1 ). Suponha, por absurdo, que exista
um emparelhamento ğ‘€ estÃ¡vel em ğº tal que ğ‘£ğ‘¤ âˆˆ ğ‘€. Pelo item 2 do lema 5, ou ğ‘£
prefere ğ‘™ğº1 (ğ‘£) a ğ‘¤ (ğ¼ ) ou ğ‘¤ prefere ğ‘™ğº1 (ğ‘¤) a ğ‘£ (ğ¼ ğ¼ ). Se (ğ¼ ), pelo item 1 do lema anterior,
ğ‘¢ âˆ¶= ğ‘™ğº1 (ğ‘£) âŸ¹ ğ‘“ğº1 (ğ‘¢) = ğ‘£ e, portanto, ğ‘¢ prefere ğ‘£ a ğ‘¤, donde ğ‘¢ğ‘£ bloqueia ğ‘€.

29
3.1 | ALGORITMO DE IRVING

Se (ğ¼ ğ¼ ), de modo anÃ¡logo, concluirÃ­amos que ğ‘™ğº1 (ğ‘¤)ğ‘¤ bloqueia ğ‘€. Assim, ğ‘£ğ‘¤ nÃ£o Ã©
estÃ¡vel.
2. Suponha que ğ‘£ğ‘¤ Ã© uma aresta de ğº tal que ğ‘£ e ğ‘¤ nÃ£o sÃ£o vÃ©rtices de ğº1 . AlÃ©m disso,
suponha, por absurdo, que ğº apresenta um emparelhamento estÃ¡vel ğ‘€. Como ğ‘£ e ğ‘¤
nÃ£o pertencem a ğ‘‰ (ğº1 ), pelo item anterior, segue que ğ‘£ e ğ‘¤ nÃ£o sÃ£o cobertos por ğ‘€.
Isso implica que ğ‘€ âˆª {ğ‘£ğ‘¤} Ã© um emparelhamento, e, portanto, ğ‘€ nÃ£o Ã© maximal, o
que Ã© uma contradiÃ§Ã£o, jÃ¡ que todo emparelhamento estÃ¡vel Ã© maximal e ğ‘€ Ã©, por
hipÃ³tese, estÃ¡vel.

Note que hÃ¡ casos em que ğº1 jÃ¡ nos dÃ¡ informaÃ§Ãµes suficientes para determinar rapidamente se ğº possui um emparelhamento estÃ¡vel. Um desses casos corresponde ao item 2 do
lema anterior, onde chegamos Ã  conclusÃ£o que ğº nÃ£o apresenta emparelhamentos estÃ¡veis.
Outro seria quando cada vÃ©rtice de ğº1 apresenta grau 1 (relembre que ğº1 nÃ£o apresenta
vÃ©rtices isolados) e, assim, ğº1 se reduziria a um emparelhamento estÃ¡vel, ou seja, ğ¸(ğº1 )
seria um emparelhamento estÃ¡vel. De fato, suponha que esse seja o caso, e seja ğ‘£ğ‘¤ uma
aresta de ğº tal que ğ‘£ğ‘¤ âˆ‰ ğ¸(ğº1 ). Pelo item 2 do lema 5 ğ‘£ğ‘¤ nÃ£o bloquearia ğ¸(ğº1 ).
Infelizmente, apÃ³s a etapa 1 nem sempre estaremos em algum dos casos anteriores, como
nos mostra exemplo da figura abaixo. Chamaremos tais casos de casos degenerados.
ğ‘

ğ‘
ğ‘âˆ¶ğ‘ğ‘
ğ‘âˆ¶ğ‘ğ‘
ğ‘âˆ¶ğ‘ğ‘

ğ‘
Figura 3.2: A figura acima representa o grafo produzido ao aplicar o prÃ©-processamento da
etapa 1 do algoritmo de Irving ao grafo ğº representado na figura 3.1. Os arcos coloridos de azul
representam o estado de ğ‘† ao final do algoritmo (Note que ğ‘† induz um grafo dirigido nos vÃ©rtices de
ğº). Assim, vemos que ğº1 = ğº. Note que cada vÃ©rtice de ğº1 apresenta grau 2.

Dada a importÃ¢ncia dos grafos produzidos pela etapa 1 serem relevantes para as
discussÃµes que vem a seguir, introduzimos a seguir o conceito de subgrafo estÃ¡vel de um
grafo de preferÃªncias.
Dado um grafo de preferÃªncias ğº, um subgrafo de preferÃªncias ğº â€² Ã© dito estÃ¡vel (com
respeito a ğº):
1. Para quaisquer ğ‘£, ğ‘¤ âˆˆ ğ‘‰ (ğº â€² ): ğ‘£ = ğ‘™ğº â€² (ğ‘¤) se, e somente, se ğ‘¤ = ğ‘“ğº â€² (ğ‘£).
2. Para quaisquer ğ‘£, ğ‘¤ âˆˆ ğ‘‰ (ğº â€² ) tais que ğ‘£ğ‘¤ âˆˆ ğ¸(ğº): ğ‘£ğ‘¤ âˆ‰ ğ¸(ğº â€² ) se, e somente, se ğ‘£
prefere ğ‘™ğº â€² (ğ‘£) a ğ‘¤ ou ğ‘¤ prefere ğ‘™ğº â€² (ğ‘¤) a ğ‘£.

30
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

3. NÃ£o existem vÃ©rtices ğ‘£, ğ‘¤ âˆˆ ğ‘‰ (ğº) tais que ğ‘£ğ‘¤ âˆˆ ğ¸(ğº) e ğ‘£, ğ‘¤ âˆ‰ ğ‘‰ (ğº â€² ).
4. NÃ£o existem vÃ©rtices isolados em ğº â€² .
Note que se ğº1 nÃ£o se encontra em nenhum dos casos degenerados, ele Ã© estÃ¡vel. O
lema abaixo enumera propriedades interessantes de subgrafos estÃ¡veis que serÃ£o Ãºteis na
discussÃ£o da seÃ§Ã£o seguinte.
Lema 7. Sejam ğº um grafo de preferÃªncias e ğº â€² , ğº â€²â€² subgrafos estÃ¡veis de ğº. EntÃ£o:
1. Se ğ‘€ Ã© um emparelhamento de ğº contido em ğº â€² , entÃ£o toda aresta ğ‘£ğ‘¤ de ğº ausente
em ğº â€² nÃ£o bloqueia ğ‘€.
2. Se todo vÃ©rtice de ğº â€² apresenta grau no mÃ¡ximo 1, entÃ£o ğº â€² se reduz a um emparelhamento estÃ¡vel de ğº, isto Ã©, ğ¸(ğº â€² ) Ã© um emparelhamento estÃ¡vel de ğº.
3. Se ğ‘‰ (ğº â€² ) = ğ‘‰ (ğº â€²â€² ) e, para todo vÃ©rtice ğ‘£ âˆˆ ğ‘‰ (ğº â€² )(= ğ‘‰ (ğº â€²â€² )), ğ‘“ğº â€² (ğ‘£) = ğ‘“ğº â€²â€² (ğ‘£), entÃ£o
ğº â€² = ğº â€²â€² .
DemonstraÃ§Ã£o.
estÃ¡vel.

1. Tal fato segue diretamente dos itens 2 e 3 da definiÃ§Ã£o de subgrafo

2. Pelo item anterior, ğ¸(ğº â€² ) Ã© um emparelhamento que nÃ£o Ã© bloqueado por nenhuma
aresta fora de ğ¸(ğº â€² ) e obtemos o requerido.
3. Suponha que ğ‘“ğº â€² (ğ‘£) = ğ‘“ğº â€²â€² (ğ‘£) para todo ğ‘£ âˆˆ ğ‘‰ (ğº â€² ). Fixe um ğ‘£ âˆˆ ğ‘‰ (ğº â€² ) arbitrÃ¡rio e
considere ğ‘¢1 âˆ¶= ğ‘™ğº â€² (ğ‘£) e ğ‘¢2 âˆ¶= ğ‘™ğº â€²â€² (ğ‘£). Pelo item 1 da definiÃ§Ã£o de subgrafo estÃ¡vel e
pela hipÃ³tese anterior, ğ‘“ğº â€²â€² (ğ‘¢1 ) = ğ‘“ğº â€² (ğ‘¢1 ) = ğ‘£ e, novamente pelo item 1 da definiÃ§Ã£o
de subgrafo estÃ¡vel, conclui-se que ğ‘¢1 = ğ‘™ğº â€²â€² (ğ‘£) = ğ‘¢2 . Assim provamos que ğ‘™ğº â€² (ğ‘¢) =
ğ‘™ğº â€²â€² (ğ‘¢) para todo ğ‘¢ âˆˆ ğ‘‰ (ğº â€² ) e, pelo item 2 da definiÃ§Ã£o de subgrafo estÃ¡vel, segue
imediatamente que ğ¸(ğº â€² ) = ğ¸(ğº â€²â€² ) e obtemos o requerido.

3.1.2

Teorema dos hospitais rurais generalizado

Relembre que ğº1 Ã© o grafo de preferÃªncias obtido apÃ³s aplicaÃ§Ã£o da etapa 1 em um grafo
de preferÃªncias ğº. Assim, pelo item 1 do lema 6, segue imediatamente que todo vÃ©rtice de
ğ‘£ de ğ‘‰ (ğº) â§µ ğ‘‰ (ğº1 ) nÃ£o Ã© estÃ¡vel. Agora, com relaÃ§Ã£o aos vÃ©rtices de ğ‘‰ (ğº1 ), podemos tirar
alguma conclusÃ£o geral que relaciona tal conjunto com os emparelhamentos estÃ¡veis de ğº
(caso existam)? A resposta Ã© positiva(!). Segue abaixo uma generalizaÃ§Ã£o do Teorema dos
Hospitais Rurais.
Teorema 9 (hospitais rurais generalizado). Seja ğº = (ğ‘‰ , ğ¸, ğ¿) um grafo de preferÃªncias que
apresenta emparelhamentos estÃ¡veis. EntÃ£o qualquer vÃ©rtice de ğº1 Ã© coberto por cada um dos
emparelhamentos estÃ¡veis de ğº. AlÃ©m disso, todo vÃ©rtice de ğº fora de ğ‘‰ (ğº1 ) nÃ£o Ã© estÃ¡vel.
DemonstraÃ§Ã£o. Seja ğ‘£ âˆˆ ğ‘‰ (ğº1 ), entÃ£o foi observado anteriormente que nesse caso existe
ğ‘¢ âˆˆ ğ‘‰ (ğº1 ) tal que (ğ‘¢, ğ‘£) âˆˆ ğ‘† âˆ— , implicando que ğ‘£ = ğ‘“ğº1 (ğ‘¢) (ğ¼ ). Seja ğ‘€ um emparelhamento
de ğº tal que ğ‘£ nÃ£o Ã© coberto por ğ‘€. Sabemos, pelo item 1 do lema 6, que ğ‘€ estÃ¡ contido
em ğ¸(ğº1 ) (ğ¼ ğ¼ ). Assim, ou ğ‘¢ nÃ£o Ã© coberto por ğ‘€, caso em que claramente ğ‘£ğ‘¢ bloqueia ğ‘€,

31
3.1 | ALGORITMO DE IRVING

ou ğ‘¢ Ã© coberto por ğ‘€, donde ğ‘€(ğ‘¢) âˆˆ ğ‘‰ (ğº1 ), por (ğ¼ ğ¼ ), e, por (ğ¼ ), ğ‘€(ğ‘¢) <ğ‘¢ ğ‘£, implicando que
ğ‘¢ğ‘£ bloqueia ğ‘€.
A segunda afirmaÃ§Ã£o do enunciado segue diretamente do item 1 do lema 6.

3.1.3

Preliminares para a segunda etapa

Antes de descrevermos a segunda etapa propriamente dita, introduziremos um
conceito que serÃ¡ de imensa utilidade para a discussÃ£o que vem a seguir. Seja ğº =
(ğ‘‰ , ğ¸, ğ¿) um grafo de preferÃªncias e ğº â€² um subgrafo estÃ¡vel de ğº. Uma sequÃªncia
ğœŒ = (ğ‘¥0 , ğ‘¦0 ), (ğ‘¥1 , ğ‘¦1 ), ..., (ğ‘¥ğ‘Ÿâˆ’1 , ğ‘¦ğ‘Ÿâˆ’1 ) tal que ğ‘¦ğ‘– = ğ‘“ğº â€² (ğ‘¥ğ‘– ) e ğ‘¦(ğ‘–+1 mod ğ‘Ÿ) = ğ‘ ğº â€² (ğ‘¥ğ‘– ), para todo
ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}, Ã© dita uma rotaÃ§Ã£o exposta em ğº â€² . Definimos ğ‘‹ğœŒ âˆ¶= {ğ‘¥0 , ..., ğ‘¥ğ‘Ÿâˆ’1 } e
ğ‘ŒğœŒ âˆ¶= {ğ‘¦0 , ..., ğ‘¦ğ‘Ÿâˆ’1 }. Como de praxe, o subscrito ğœŒ pode ser omitido quando estiver subentendido no contexto. Para evitar carregar a notaÃ§Ã£o, quando estivermos nos referindo a
um Ã­ndice de um elemento de ğ‘‹ğœŒ ou ğ‘ŒğœŒ considere que ele estÃ¡ sendo tomado mÃ³dulo ğ‘Ÿ.
Assim, por exemplo, escrevemos ğ‘¥ğ‘–+1 e ğ‘¦ğ‘–âˆ’1 nos lugares de, respectivamente, ğ‘¥(ğ‘–+1 mod ğ‘Ÿ) e
ğ‘¦(ğ‘–âˆ’1 mod ğ‘Ÿ) .
Vale notar a natureza cÃ­clica da rotaÃ§Ã£o, de modo, que diremos que duas rotaÃ§Ãµes sÃ£o
iguais se as sequÃªncias que as definem sÃ£o iguais a menos de rotaÃ§Ãµes. Mais precisamente,
â€²
â€²
ğ›¼ = (ğ‘¥0 , ğ‘¦0 ), (ğ‘¥1 , ğ‘¦1 ), ..., (ğ‘¥ğ‘Ÿâˆ’1 , ğ‘¦ğ‘Ÿâˆ’1 ) e ğ›½ = (ğ‘¥0â€² , ğ‘¦0â€² ), (ğ‘¥1â€² , ğ‘¦1â€² ), ..., (ğ‘¥ğ‘¡âˆ’1
, ğ‘¦ğ‘¡âˆ’1
) expostas em ğº â€² sÃ£o
iguais quando ğ‘Ÿ = ğ‘¡ e existir um ğ‘˜ âˆˆ {0, .., ğ‘Ÿ âˆ’ 1} tal que ğ‘¥ğ‘–+ğ‘˜ = ğ‘¥ğ‘–â€² e ğ‘¦ğ‘–+ğ‘˜ = ğ‘¦ğ‘–â€² para
todo ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}. O lema a seguir nos dÃ¡ uma maneira mais simples de verificar se
duas rotaÃ§Ãµes sÃ£o iguais. Note que quando falamos que uma rotaÃ§Ã£o estÃ¡ completamente
determinada, estamos dizendo que ela estÃ¡ determinada a menos de rotaÃ§Ãµes.
Lema 8. Se ğ›¼ e ğ›½ sÃ£o rotaÃ§Ãµes distintas expostas em um subgrafo estÃ¡vel ğº â€² de um grafo de
preferÃªncias ğº, entÃ£o ğ‘‹ğ›¼ âˆ© ğ‘‹ğ›½ = âˆ… e ğ‘Œğ›¼ âˆ© ğ‘Œğ›½ = âˆ….
DemonstraÃ§Ã£o. Para provar o enunciado, basta provar que uma rotaÃ§Ã£o ğœŒ estÃ¡ completamente determinada por cada um dos seus ğ‘¥ğ‘– â€™s e ğ‘¦ğ‘– â€™s. De fato, note que ğ‘“ğº â€² (ğ‘¥ğ‘– ) = ğ‘¦ğ‘– = ğ‘ ğº â€² (ğ‘¥ğ‘–âˆ’1 )
e, assim, ğ‘¥ğ‘– = ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¥ğ‘–âˆ’1 )). Assim, dado ğ‘¥ğ‘– para algum ğ‘– e, visto que ğ‘¦ğ‘– = ğ‘“ğºâ€² (ğ‘¥ğ‘– ) para todo
ğ‘–, segue que ğœŒ estÃ¡ completamente determinada. Note que ğ‘¥ğ‘– = ğ‘™ğº â€² (ğ‘¦ğ‘– ) para todo ğ‘– e, logo,
segue que, dado ğ‘¦ğ‘– , ğœŒ estÃ¡ completamente determinada.
Assim, para verificar que duas rotaÃ§Ãµes ğ›¼ e ğ›½ sÃ£o iguais basta verificar se ğ‘‹ğ›¼ e ğ‘‹ğ›½ (ou
ğ‘Œğ›¼ e ğ‘Œğ›½ ) apresentam algum elemento em comum.
Encontrar rotaÃ§Ãµes expostas em subgrafos estÃ¡veis Ã© de suma importÃ¢ncia para a
segunda etapa do algoritmo de Irving. Nesse sentido, O lema a seguir nos garante a
existÃªncia de rotaÃ§Ãµes expostas em subgrafos estÃ¡veis que nÃ£o se reduzem a um emparelhamento.
Lema 9. Seja ğº â€² um subgrafo estÃ¡vel de um grafo de preferÃªncias ğº. Se existe um vÃ©rtice
ğ‘£ âˆˆ ğ‘‰ (ğº â€² ) tal que ğ‘”ğº â€² (ğ‘£) â‰¥ 2, entÃ£o existe uma rotaÃ§Ã£o exposta em ğº â€² .
DemonstraÃ§Ã£o. Suponha que exista um vÃ©rtice ğ‘£ tal que ğ‘”ğº â€² (ğ‘£) â‰¥ 2. Seja ğ‘†(ğº â€² ) o conjunto
dos vÃ©rtices de ğº â€² tal que ğ‘”ğº â€² (ğ‘£) â‰¥ 2. Provemos que, dado ğ‘¢ âˆˆ ğ‘‰ (ğº), ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¢)) â‰  ğ‘¢ e
ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¢)) âˆˆ ğ‘†(ğº â€² ). De fato, se ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¢)) = ğ‘¢, terÃ­amos ğ‘ ğº â€² (ğ‘¢) = ğ‘“ğº â€² (ğ‘¢), o que Ã© um absurdo.

32
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

Para concluir a veracidade da segunda afirmaÃ§Ã£o, basta notar que se ğ‘¤ âˆˆ ğ‘‰ (ğº â€² ) Ã© tal que
ğ‘”ğº â€² (ğ‘¤) = 1, entÃ£o seu Ãºnico vizinho ğ‘¤ â€² âˆˆ ğ‘‰ (ğº â€² ) Ã© tal que ğ‘¤ â€² = ğ‘“ğº â€² (ğ‘¤) = ğ‘™ğº â€² (ğ‘¤) e, portanto,
pela estabilidade de ğº â€² , segue que ğ‘¤ = ğ‘™ğº â€² (ğ‘¤ â€² ) = ğ‘“ğº â€² (ğ‘¤ â€² ), implicando que ğ‘”ğº â€² (ğ‘¤ â€² ) = 1. Logo,
dado que ğ‘¢ âˆˆ ğ‘†(ğº â€² ) e que ğº â€² nÃ£o apresenta vÃ©rtices isolados, segue que ğ‘ ğº â€² (ğ‘¢) âˆˆ ğ‘†(ğº â€² ), que
por sua vez, implica ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¢)) âˆˆ ğ‘†(ğº â€² ), como nÃ£o hÃ¡ vÃ©rtices isolados em ğº â€² , segue que
ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¢)) âˆˆ ğ‘†(ğº â€² ), como querÃ­amos demonstrar.
Assim estÃ¡ bem definido o grafo direcionado ğº(ğ‘†(ğº â€² )) definido a seguir. ğ‘‰ (ğº(ğ‘†(ğº â€² ))) âˆ¶=
ğ‘†(ğº â€² ) e para cada ğ‘¢ âˆˆ ğ‘†(ğº â€² ) tem-se um arco de ğ‘¢ para ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¢)) âˆˆ ğ‘†(ğº â€² ). Desta forma,
cada nÃ³ de ğº(ğ‘†(ğº â€² )) apresenta grau de saÃ­da exatamente 1 e, portanto, existe um circuito
simples ğ¶ = (ğ‘¥0 , ğ‘¥1 , ..., ğ‘¥ğ‘Ÿâˆ’1 , ğ‘¥0 ).
Finalmente, resta-nos provar que ğœŒ âˆ¶= (ğ‘¥0 , ğ‘“ğº â€² (ğ‘¥0 )), (ğ‘¥1 , ğ‘“ğº â€² (ğ‘¥1 )), ..., (ğ‘¥ğ‘Ÿâˆ’1 , ğ‘“ğº â€² (ğ‘¥ğ‘Ÿâˆ’1 )) Ã© uma
rotaÃ§Ã£o exposta em ğº â€² . Tal afirmaÃ§Ã£o segue diretamente do fato que ğ‘¥ğ‘– = ğ‘™ğº â€² (ğ‘ ğº â€² (ğ‘¥ğ‘–âˆ’1 )) se, e
somente se, ğ‘“ğº â€² (ğ‘¥ğ‘– ) = ğ‘ ğº â€² (ğ‘¥ğ‘–âˆ’1 ).
Note que a demonstraÃ§Ã£o do lema acima nos dÃ¡ um algoritmo para encontrar uma
rotaÃ§Ã£o exposta em ğº â€² : Comece com ğ‘ƒ âˆ¶= (ğ‘¢0 ), onde ğ‘¢0 Ã© um vÃ©rtice arbitrÃ¡rio de ğ‘†(ğº â€² ),
e, enquanto ğ‘ƒ nÃ£o contiver vÃ©rtices repetidos, acrescente ao final de ğ‘ƒ o vizinho do atÃ©
entÃ£o vÃ©rtice final de ğ‘ƒ. Ao final, ğ‘ƒ serÃ¡ da forma ğ‘ƒ = (ğ‘¢0 , ğ‘¢1 , ..., ğ‘¢ğ‘˜ , ..., , ğ‘¢ğ‘˜+ğ‘Ÿ , ğ‘¢ğ‘˜ ) e, assim,
(ğ‘¢ğ‘˜ , ..., ğ‘¢ğ‘˜+ğ‘Ÿâˆ’1 , ğ‘¢ğ‘˜ ) serÃ¡ um circuito e ğœŒ = (ğ‘¢ğ‘˜ , ğ‘“ğº â€² (ğ‘¢ğ‘˜ )), ..., (ğ‘¢ğ‘˜+ğ‘Ÿâˆ’1 , ğ‘“ğº â€² (ğ‘¢ğ‘˜+ğ‘Ÿâˆ’1 )) Ã© uma rotaÃ§Ã£o
exposta em ğº â€² .
Denotamos por ğº â€² â§µ ğœŒ o subgrafo obtido ao se remover de ğº â€² as arestas do conjunto
ğ‘Ÿ

ğ¸(ğœŒ) âˆ¶= â‹ƒ {ğ‘ğ‘¦ğ‘– âˆ¶ ğ‘¥ğ‘–âˆ’1 >ğ‘¦ğ‘– ğ‘}. Dizemos que ğº â€² â§µ ğœŒ Ã© ğº â€² apÃ³s a remoÃ§Ã£o da rotaÃ§Ã£o ğœŒ.
ğ‘–=1

O lema abaixo nos dÃ¡ uma caracterizaÃ§Ã£o de ğº â€² â§µ ğœŒ quando a remoÃ§Ã£o de ğœŒ nos conduz
a um subgrafo estÃ¡vel de ğº (isto Ã©, quando ğº â€² â§µ ğœŒ nÃ£o possui vÃ©rtices isolados).
Lema 10. Seja ğº â€² um subgrafo estÃ¡vel de um grafo de preferÃªncias ğº e ğœŒ =
(ğ‘¥0 , ğ‘¦0 ), ..., (ğ‘¥ğ‘Ÿâˆ’1 , ğ‘¦ğ‘Ÿâˆ’1 ) uma rotaÃ§Ã£o exposta em ğº â€² . Se ğº â€² â§µ ğœŒ Ã© tal que nÃ£o apresenta
vÃ©rtices isolados, temos:
1. ğ‘“ğº â€² â§µğœŒ (ğ‘¥ğ‘– ) = ğ‘¦ğ‘–+1 para todo ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}.
2. ğ‘™ğº â€² â§µğœŒ (ğ‘¦ğ‘– ) = ğ‘¥ğ‘–âˆ’1 para todo ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}.
3. Para todo ğ‘¥ âˆˆ ğ‘‰ (ğº â€² ) â§µ ğ‘‹ğœŒ , ğ‘“ğº â€² â§µğœŒ (ğ‘¥) = ğ‘“ğº â€² (ğ‘¥).
4. Para todo ğ‘¦ âˆˆ ğ‘‰ (ğº â€² ) â§µ ğ‘ŒğœŒ , ğ‘™ğº â€² â§µğœŒ (ğ‘¦) = ğ‘™ğº â€² (ğ‘¦).
5. ğº â€² â§µ ğœŒ Ã© um subgrafo estÃ¡vel de ğº.
DemonstraÃ§Ã£o.
1. Note que a remoÃ§Ã£o de ğœŒ remove, em particular, as arestas ğ‘¥ğ‘– ğ‘¦ğ‘– com
ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}. Se para algum ğ‘–, ğ‘¥ğ‘– ğ‘¦ğ‘–+1 fosse removido, seria devido a existÃªncia de
algum ğ‘— tal que ğ‘¦ğ‘— = ğ‘¥ğ‘– e ğ‘¦ğ‘–+1 <ğ‘¥ğ‘– ğ‘¥ğ‘—âˆ’1 . Nesse caso, como cada vizinho ğ‘¢ â‰  ğ‘¦ğ‘– de ğ‘¥ğ‘– Ã© tal
que ğ‘¢ â‰¤ğ‘¥ğ‘– ğ‘¦ğ‘–+1 <ğ‘¥ğ‘– ğ‘¥ğ‘—âˆ’1 (pois ğ‘¦ğ‘–+1 = ğ‘ ğº â€² (ğ‘¥ğ‘– ) e ğ‘¦ğ‘– = ğ‘“ğº â€² (ğ‘¥ğ‘– )), concluirÃ­amos que todos os
vizinhos de ğ‘¥ğ‘– foram removidos, o que contradiz a hipÃ³tese de nÃ£o haverem vÃ©rtices
isolados em ğº â€² â§µ ğœŒ. Assim, segue o requerido.

33
3.1 | ALGORITMO DE IRVING

2. Como observado no item anterior, ao se remover ğœŒ, remove-se as arestas ğ‘¥ğ‘– ğ‘¦ğ‘– com
ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}. AlÃ©m disso, pela definiÃ§Ã£o de remoÃ§Ã£o de rotaÃ§Ã£o, dado ğ‘–, todo
vizinho ğ‘¢ de ğ‘¦ğ‘– tal que ğ‘¢ <ğ‘¦ğ‘– ğ‘¥ğ‘–âˆ’1 sÃ£o removidos. Assim, se ğ‘¥ğ‘–âˆ’1 ğ‘¦ğ‘– fosse removido,
seria devido a existÃªncia de algum ğ‘— tal que ğ‘¦ğ‘— = ğ‘¥ğ‘–âˆ’1 e, por um argumento anÃ¡logo
ao do item 1 concluirÃ­amos que ğ‘¥ğ‘–âˆ’1 Ã© isolado em ğº â€² â§µ ğœŒ, o que Ã© uma contradiÃ§Ã£o.
Assim, segue o enunciado.
3. Seja ğ‘¥ âˆˆ ğ‘‰ (ğº â€² ) tal que ğ‘¥ âˆ‰ ğ‘‹ğœŒ . Logo, ğ‘“ğº â€² (ğ‘¥) âˆ‰ ğ‘ŒğœŒ . AlÃ©m disso, para que ğ‘¥ğ‘“ğº â€² (ğ‘¥) fosse
removido, deverÃ­amos ter um ğ‘— tal que ğ‘¦ğ‘— = ğ‘¥ e ğ‘“ğº â€² (ğ‘¥) <ğ‘¥ ğ‘¥ğ‘—âˆ’1 o que contradiria a
definiÃ§Ã£o de ğ‘“ğº â€² (ğ‘¥).
4. Seja ğ‘¦ âˆˆ ğ‘‰ (ğº â€² ) tal que ğ‘¦ âˆ‰ ğ‘ŒğœŒ . Logo, ğ‘™ğº â€² (ğ‘¦) âˆ‰ ğ‘‹ğœŒ . Assim, fazendo ğ‘¥ âˆ¶= ğ‘™ğº â€² (ğ‘¦) âˆ‰ ğ‘‹ğœŒ ,
temos que ğ‘¦ = ğ‘“ğº â€² (ğ‘¥) âˆ‰ ğ‘ŒğœŒ e, pelo item anterior, ğ‘¥ğ‘“ğº â€² (ğ‘¥) = ğ‘¦ğ‘™ğº â€² (ğ‘¦) nÃ£o Ã© removido de
de ğº â€² .
5. Note que, como ğ‘‰ (ğº â€² â§µğœŒ) = ğ‘‰ (ğº â€² ) e ğº â€² Ã© estÃ¡vel, ğº â€² â§µğœŒ satisfaz trivialmente a condiÃ§Ã£o
3 da definiÃ§Ã£o de subgrafo estÃ¡vel. AlÃ©m disso, como ğº â€² â§µ ğœŒ nÃ£o apresenta vÃ©rtices
isolados, a condiÃ§Ã£o 4 Ã© automaticamente satisfeita. A condiÃ§Ã£o 1 segue dos itens
anteriores.
Resta-nos provar que a condiÃ§Ã£o 2 de subgrafo estÃ¡vel Ã© satisfeita por ğº â§µ ğœŒ. Para
isso, tomemos uma aresta ğ‘¥ğ‘¦ âˆˆ ğ¸(ğº) tal que ğ‘¥, ğ‘¦ âˆˆ ğ‘‰ (ğº â€² â§µ ğœŒ) = ğ‘‰ (ğº â€² ). Se ğ‘¥ğ‘¦ âˆ‰ ğ¸(ğº â€² ),
entÃ£o o resultado segue imediatamente do fato que ğ‘™ğº â€² â§µğœŒ (ğ‘£) â‰¤ğ‘£ ğ‘™ğº â€² (ğ‘£) (jÃ¡ que ğº â€² â§µ ğœŒ
Ã© obtido de ğº â€² removendo-se arestas). Suponha entÃ£o que ğ‘¥ğ‘¦ âˆˆ ğ¸(ğº â€² ). Assim, ğ‘¥ğ‘¦
Ã© removido de ğº â€² se, e somente se, ğ‘¥ = ğ‘¦ğ‘— e ğ‘¦ <ğ‘¥ ğ‘¥ğ‘—âˆ’1 = ğ‘™ğº â€² â§µğœŒ (ğ‘¥) para algum ğ‘— (ğ¼ ) ou
ğ‘¦ = ğ‘¦ğ‘– e ğ‘¥ <ğ‘¦ ğ‘¥ğ‘–âˆ’1 = ğ‘™ğº â€² â§µğœŒ (ğ‘¦) para algum ğ‘– (ğ¼ ğ¼ ). Isso prova o requerido.

Os lemas expostos a seguir sÃ£o de fundamental importÃ¢ncia para prova da corretude
da etapa 2.
Lema 11. Seja ğº â€² um subgrafo estÃ¡vel de um grafo de preferÃªncias ğº e ğœŒ uma rotaÃ§Ã£o
exposta em ğº â€² . Se ğ‘€ Ã© um emparelhamento estÃ¡vel de ğº contido em ğº â€² e existe ğ‘¥ âˆˆ ğ‘‹ğœŒ tal
que ğ‘€(ğ‘¥) â‰  ğ‘“ğº â€² (ğ‘¥), entÃ£o ğ‘€ estÃ¡ contido em ğº â€² â§µ ğœŒ.
DemonstraÃ§Ã£o. Suponha que exista um ğ‘€ definido conforme o enunciado e suponha que
ğœŒ âˆ¶= (ğ‘¥0 , ğ‘¦0 ), ..., (ğ‘¥ğ‘Ÿâˆ’1 , ğ‘¦ğ‘Ÿâˆ’1 ). Pelo carÃ¡ter cÃ­clico de uma rotaÃ§Ã£o, podemos supor, sem perda
de generalidade, que ğ‘€(ğ‘¥0 ) â‰  ğ‘“ğº â€² (ğ‘¥0 ). EntÃ£o, temos dois casos, a saber: ğ‘€(ğ‘¥0 ) = ğ‘ ğº â€² (ğ‘¥0 )
(ğ¼ ) ou ğ‘€(ğ‘¥0 ) <ğ‘¥0 ğ‘ ğº â€² (ğ‘¥0 ) = ğ‘“ğº â€² (ğ‘¥1 ) = ğ‘¦1 (ğ¼ ğ¼ ). Se (ğ¼ ), temos que ğ‘€(ğ‘¥0 ) = ğ‘¦1 e, como ğ‘€ Ã© um
emparelhamento, devemos ter ğ‘€(ğ‘¥1 ) â‰  ğ‘€(ğ‘¥0 ) = ğ‘¦1 = ğ‘“ğº â€² (ğ‘¥1 ). Se (ğ¼ ğ¼ ), dado que ğ‘¥0 ğ‘¦1 nÃ£o
bloqueia ğ‘€ (pois ğ‘€ Ã© estÃ¡vel), devemos ter ğ‘¥0 <ğ‘¦1 ğ‘€(ğ‘¦1 ) e, visto que ğ‘¥1 = ğ‘™ğº â€² (ğ‘¦1 ) <ğ‘¦1 ğ‘¥0 ,
segue que ğ‘¥1 â‰  ğ‘€(ğ‘¦1 ), isto Ã©, ğ‘€(ğ‘¥1 ) â‰  ğ‘¦1 = ğ‘“ğº â€² (ğ‘¥1 ). Por induÃ§Ã£o, Ã© possÃ­vel provar que
ğ‘€(ğ‘¥ğ‘– ) â‰  ğ‘“ğº â€² (ğ‘¥ğ‘– ) para todo ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}.
Agora, suponha, por absurdo, que algum ğ‘¥ğ‘€(ğ‘¥) âˆˆ ğ¸(ğº â€² ) Ã© removido ao se remover ğœŒ
de ğº â€² . Pela definiÃ§Ã£o de remoÃ§Ã£o de rotaÃ§Ã£o, para que isso tenha ocorrido, existe algum
ğ‘— tal que ğ‘¥ = ğ‘¦ğ‘— e ğ‘€(ğ‘¥) <ğ‘¥ ğ‘¥ğ‘—âˆ’1 (ğ¼ ) ou algum ğ‘— tal que ğ‘€(ğ‘¥) = ğ‘¦ğ‘— e ğ‘¥ <ğ‘€(ğ‘¥) ğ‘¥ğ‘—âˆ’1 (ğ¼ ğ¼ ). No
caso (ğ¼ ), pela estabilidade de ğ‘€, obtemos que ğ‘ ğº â€² (ğ‘¥ğ‘—âˆ’1 ) = ğ‘¦ğ‘— = ğ‘¥ <ğ‘¥ğ‘—âˆ’1 ğ‘€(ğ‘¥ğ‘—âˆ’1 ), donde vem
que ğ‘€(ğ‘¥ğ‘—âˆ’1 ) = ğ‘“ğº â€² (ğ‘¥ğ‘—âˆ’1 ), o que contradiz a conclusÃ£o do parÃ¡grafo anterior. Supondo (ğ¼ ğ¼ ),

34
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

de modo inteiramente anÃ¡logo ao caso anterior, chegamos a uma contradiÃ§Ã£o. Portanto,
nenhuma aresta de ğ‘€ Ã© removida ao se remover ğœŒ de ğº â€² e, portanto, ğ‘€ estÃ¡ contido em
ğº â€² â§µ ğœŒ.
Lema 12. Seja ğº â€² um subgrafo estÃ¡vel de um grafo de preferÃªncias ğº e ğœŒ uma rotaÃ§Ã£o
exposta em ğº â€² . Se ğº â€² contÃ©m algum emparelhamento estÃ¡vel de ğº, entÃ£o ğº â€² â§µ ğœŒ contÃ©m algum
emparelhamento estÃ¡vel de ğº.
DemonstraÃ§Ã£o. Suponha que ğº â€² contenha algum emparelhamento estÃ¡vel e seja ğ‘€ um
emparelhamento estÃ¡vel de ğº contido em ğº â€² . Inicialmente, veja que, como ğ‘€ Ã© um emparelhamento estÃ¡vel contido em ğº â€² , pelo Teorema 9, ğ‘‰ (ğ‘€) = ğ‘‰ (ğº1 ). Por outro lado, pelo item
4 do lema 7, ğ‘‰ (ğº â€² ) âŠ‚ ğ‘‰ (ğº1 ) = ğ‘‰ (ğ‘€) âŠ‚ ğ‘‰ (ğº â€² ), donde ğ‘‰ (ğº â€² ) = ğ‘‰ (ğ‘€) = ğ‘‰ (ğº1 ). Considere que
ğœŒ âˆ¶= (ğ‘¥0 , ğ‘¦0 ), ..., (ğ‘¥ğ‘Ÿâˆ’1 , ğ‘¦ğ‘Ÿâˆ’1 ). Se ğ‘€(ğ‘¥ğ‘– ) â‰  ğ‘“ğº â€² (ğ‘¥ğ‘– ) para algum ğ‘–, entÃ£o, pelo lema anterior, ğ‘€
estÃ¡ contido em ğº â€² â§µ ğœŒ e obtemos o requerido. Suponha entÃ£o que ğ‘€(ğ‘¥ğ‘– ) = ğ‘“ğº â€² (ğ‘¥ğ‘– ) = ğ‘¦ğ‘– para
todo ğ‘–. EntÃ£o, pelo lema 9, segue que ğ‘¥ğ‘– ğ‘¦ğ‘– âˆ‰ ğº â€² â§µ ğœŒ para todo ğ‘–. Note que ğ‘¥ğ‘€(ğ‘¥) âˆˆ ğ¸(ğº â€² ) sÃ³
Ã© removido quando ğ‘¥ğ‘€(ğ‘¥) = ğ‘¥ğ‘– ğ‘¦ğ‘– para algum ğ‘– (ğ¼ ). De fato, para que ğ‘¥ğ‘€(ğ‘¥) âˆˆ ğ¸(ğº â€² ) fosse
removido, deveria existir ğ‘— tal que ğ‘¥ = ğ‘¦ğ‘— (implicando que ğ‘€(ğ‘¥) = ğ‘€(ğ‘¦ğ‘— ) = ğ‘¥ğ‘— ) ou existir ğ‘—
tal que ğ‘€(ğ‘¥) = ğ‘¦ğ‘— (implicando que ğ‘¥ğ‘— = ğ‘€(ğ‘¦ğ‘— ) = ğ‘¥).
Assim, considere ğ‘€ â€² âˆ¶= (ğ‘€ â§µ {ğ‘¥ğ‘– ğ‘¦ğ‘– âˆ¶ ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}}) âˆª {ğ‘¥ğ‘– ğ‘¦ğ‘–+1 âˆ¶ ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}. Note
que se ğ‘¥ğ‘– ğ‘¦ğ‘–+1 âˆ‰ ğº â€² â§µ ğœŒ para algum ğ‘–, existiria ğ‘— tal que ğ‘¥ğ‘– = ğ‘¦ğ‘— = ğ‘“ğº â€² (ğ‘¥ğ‘— ) e ğ‘¦ğ‘–+1 <ğ‘¥ğ‘– ğ‘¥ğ‘—âˆ’1 , donde
ğ‘“ğº â€² (ğ‘¥ğ‘– ) = ğ‘¦ğ‘– = ğ‘€(ğ‘¥ğ‘– ) = ğ‘€(ğ‘¦ğ‘— ) = ğ‘¥ğ‘— = ğ‘™ğº â€² (ğ‘¥ğ‘– ), implicando que o grau de ğ‘¥ğ‘– Ã© 1 em ğº â€² , o que Ã©
um absurdo. Logo, ğ‘€ â€² estÃ¡ contido em ğº â§µ ğœŒ.
Provemos agora que ğ‘€ â€² se trata de um emparelhamento. Note que ğ‘€ â§µ {ğ‘¥ğ‘– ğ‘¦ğ‘– âˆ¶ ğ‘– âˆˆ
{0, ..., ğ‘Ÿ âˆ’ 1}} nÃ£o pode cobrir nenhum vÃ©rtice de ğ‘‹ğœŒ ou ğ‘ŒğœŒ (caso contrÃ¡rio, ğ‘€ nÃ£o seria um
emparelhamento) e, portanto, se ğ‘… âˆ¶= {ğ‘¥ğ‘– ğ‘¦ğ‘–+1 âˆ¶ ğ‘– âˆˆ {0, ..., ğ‘Ÿ âˆ’ 1}} Ã© um emparelhamento,
ğ‘€ â€² tambÃ©m o Ã©. Suponha, por absurdo, que ğ‘¥ğ‘– ğ‘¦ğ‘–+1 e ğ‘¥ğ‘— ğ‘¦ğ‘—+1 , onde ğ‘– Ã© distinto de ğ‘— mÃ³dulo
ğ‘Ÿ, possuem algum extremo em comum. Nesse caso, temos as seguintes possibilidades:
ğ‘¥ğ‘– = ğ‘¥ğ‘— (implicaria que ğ‘€ nÃ£o Ã© emparelhamento); ğ‘¦ğ‘–+1 = ğ‘¦ğ‘—+1 (idem); ğ‘¥ğ‘– = ğ‘¦ğ‘—+1 (ğ‘¥ğ‘– ğ‘¦ğ‘– e ğ‘¥ğ‘—+1 ğ‘¦ğ‘—+1
teriam algum extremo em comum, donde ğ‘— + 1 = ğ‘– (mÃ³dulo ğ‘Ÿ)e ğ‘¥ğ‘– = ğ‘¦ğ‘– = ğ‘€(ğ‘¥ğ‘– ), o que Ã© um
absurdo); ğ‘¥ğ‘—+1 = ğ‘¦ğ‘– (de modo anÃ¡logo ao caso anterior, chegarÃ­amos a uma contradiÃ§Ã£o).
Assim, ğ‘€ â€² Ã© um emparelhamento. Note que ğ‘‰ (ğ‘€ â€² ) = ğ‘‰ (ğ‘€) = ğ‘‰ (ğº â€² ).
Resta-nos provar que ğ‘€ â€² Ã© estÃ¡vel. De fato, como ğ‘‰ (ğ‘€ â€² ) = ğ‘‰ (ğº â€² ) = ğ‘‰ (ğº â€² â§µ ğœŒ), temos,
em particular, que ğº â§µ ğœŒ nÃ£o contÃ©m vÃ©rtices isolados e, portanto, Ã© estÃ¡vel (item 5 do lema
10). Assim, pelo item 1 do lema 7, nenhuma aresta fora de ğ¸(ğº â§µ ğœŒ) bloqueia ğ‘€ â€² . Tome
entÃ£o uma aresta arbitrÃ¡ria ğ‘¢ğ‘£ âˆˆ ğ¸(ğº â€² â§µ ğœŒ) e suponha, por absurdo, que ğ‘¢ğ‘£ bloqueia ğ‘€ â€² .
Como ğ‘¦ğ‘–+1 = ğ‘“ğº â€² â§µğœŒ (ğ‘¥ğ‘– ) para todo ğ‘–, segue que ğ‘¥ğ‘– nÃ£o pode ser extremo de uma aresta de ğº â€²
que bloqueia ğ‘€ â€² e, logo, ğ‘¢, ğ‘£ âˆ‰ ğ‘‹ğœŒ . Temos 3 casos a considerar:
â€¢ (ambos os extremos de ğ‘¢ğ‘£ nÃ£o pertencem a ğ‘ŒğœŒ ): uma vez que ğ‘€(ğ‘¢) = ğ‘€ â€² (ğ‘¢) e
ğ‘€(ğ‘£) = ğ‘€ â€² (ğ‘£), isso implicaria que ğ‘¢ğ‘£ bloqueia ğ‘€, o que contradiz a estabilidade de
ğ‘€.
â€¢ (um dos extremos Ã© elemento de ğ‘ŒğœŒ e o outro nÃ£o): Nesse caso, podemos supor,
sem perda de generalidade, que ğ‘¢ = ğ‘¦ğ‘— para algum ğ‘— e ğ‘£ âˆ‰ ğ‘ŒğœŒ . Assim, terÃ­amos que
ğ‘¢ >ğ‘£ ğ‘€ â€² (ğ‘£) = ğ‘€(ğ‘£) e ğ‘£ >ğ‘¢ ğ‘€ â€² (ğ‘¢) = ğ‘¥ğ‘—âˆ’1 >ğ‘¢ ğ‘™ğº â€² (ğ‘¦ğ‘— ) = ğ‘¥ğ‘— = ğ‘€(ğ‘¢), implicando que ğ‘¢ğ‘£
bloqueia ğ‘€, o que Ã© uma contradiÃ§Ã£o.

35
3.1 | ALGORITMO DE IRVING

â€¢ (ambos os extremos pertencem a ğ‘ŒğœŒ ): Nesse caso, ğ‘¢ = ğ‘¦ğ‘— e ğ‘£ = ğ‘¦ğ‘– para ğ‘–, ğ‘— distintos
mÃ³dulo ğ‘Ÿ e assim, ğ‘¦ğ‘– >ğ‘¢ ğ‘€ â€² (ğ‘¦ğ‘— ) = ğ‘¥ğ‘—âˆ’1 >ğ‘¢ ğ‘™ğº â€² (ğ‘¦ğ‘— ) = ğ‘¥ğ‘— e ğ‘¦ğ‘— >ğ‘£ ğ‘€ â€² (ğ‘¦ğ‘– ) = ğ‘¥ğ‘–âˆ’1 >ğ‘£ ğ‘¥ğ‘– ,
implicando que ğ‘¢ğ‘£ bloqueia ğ‘€, o que Ã© uma contradiÃ§Ã£o.

3.1.4

Segunda etapa

Com os resultados anteriores, estamos em plenas condiÃ§Ãµes de provar a corretude da
segunda etapa, descrita a seguir. Se ğº â€² âˆ¶= ğº1 se encontra em alguns dos casos degenerados
discutidos anteriormente, ou devolvemos ğ¸(ğº â€² ) (no caso em que cada vÃ©rtice de ğº â€² tem grau
exatamente 1) ou acusamos que ğº â€² apresenta emparelhamento estÃ¡veis. Caso contrÃ¡rio, ğº â€²
Ã© estÃ¡vel e possui algum vÃ©rtice de grau 2. Assim, pelo lema 9, existe uma rotaÃ§Ã£o exposta
em ğº â€² e, como observado anteriormente, a prova do lema 9 nos dÃ¡ um algoritmo para uma
encontrar uma tal rotaÃ§Ã£o ğœŒ. O algoritmo prossegue removendo rotaÃ§Ãµes de ğº â€² atÃ© que
nos deparamos com um dos casos abaixo:
â€¢ (Todos os vÃ©rtices de ğº â€² grau exatamente 1): Nesse caso, o algoritmo se encerra
devolvendo ğ¸(ğº â€² ).
â€¢ (ğº â€² apresenta algum vÃ©rtice isolado): Nesse caso, o algoritmo se encerra acusando
que ğº nÃ£o apresenta emparelhamentos estÃ¡veis.
Algoritmo 4: Segunda etapa do algoritmo de Irving.
Entrada: Um grafo de preferÃªncias ğº = (ğ‘‰ , ğ¸, ğ¿) e ğº1
SaÃ­da: Um emparelhamento estÃ¡vel de ğº ou âˆ… indicando que ğº nÃ£o possui emparelhamentos estÃ¡veis
1 inÃ­cio
2
se existe ğ‘£, ğ‘¤ âˆ‰ ğ‘‰ (ğº1 ) tais que ğ‘£ğ‘¤ âˆˆ ğ¸(ğº) entÃ£o
3
retorna âˆ…
4
5

se para todo ğ‘£ âˆˆ ğ‘‰ (ğº1 ), ğ‘”ğº1 (ğ‘£) = 1 entÃ£o
retorna ğ¸(ğº1 )

12

FaÃ§a ğº â€² âˆ¶= ğº1
repita
Tome uma rotaÃ§Ã£o ğœŒ exposta em ğº â€²
ğº â€² âˆ¶= ğº â€² â§µ ğœŒ
atÃ© existe algum vÃ©rtice isolado em ğº â€² ou ğ‘”ğº â€² (ğ‘£) â‰¤ 1 para todo ğ‘£ âˆˆ ğ‘‰ (ğº â€² )
se existe vÃ©rtice isolado em ğº â€² entÃ£o
retorna âˆ…

13

retorna ğ¸(ğº â€² )

6
7
8
9
10
11

A fim de verificar a corretude da segunda etapa, observe que o laÃ§o da linha 7 possui a
seguinte invariante: ğº â€² Ã© um subgrafo de ğº obtido apÃ³s a remoÃ§Ã£o de uma rotaÃ§Ã£o exposta
de um subgrafo estÃ¡vel (ğ¼ ). De fato, imediatamente apÃ³s a primeira iteraÃ§Ã£o do laÃ§o, ğº â€² Ã© o
grafo obtido apÃ³s a remoÃ§Ã£o de uma rotaÃ§Ã£o exposta em ğº1 (Vale observar que, como ğº1
nÃ£o se encontra em nenhum caso degenerado, ğº1 Ã© estÃ¡vel e apresenta algum vÃ©rtice de

36
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

grau maior ou igual a 2) e temos a veracidade de (ğ¼ ). Suponha agora que (ğ¼ ) e a condiÃ§Ã£o do
laÃ§o sÃ£o verdadeiras logo apÃ³s a ğ‘—-Ã©sima iteraÃ§Ã£o, para um ğ‘— arbitrÃ¡rio. Provemos que (ğ¼ )
serÃ¡ verdadeira imediatamente apÃ³s a (ğ‘— + 1)-Ã©sima iteraÃ§Ã£o do laÃ§o. De fato, imediatamente
antes da linha 8 da (ğ‘— + 1)-Ã©sima, por (ğ¼ ) e pela veracidade da condiÃ§Ã£o do laÃ§o, segue que
ğº â€² Ã© um subgrafo estÃ¡vel de ğº e o lema 10 nos garante a existÃªncia de uma rotaÃ§Ã£o exposta
em ğº â€² , portanto o ğœŒ da linha 8 estÃ¡ bem definido. Assim, a linha 9 prossegue removendo ğœŒ,
donde segue a veracidade de (ğ¼ ) logo apÃ³s a (ğ‘— + 1)-Ã©sima iteraÃ§Ã£o. Demonstramos entÃ£o
que (ğ¼ ) se trata de uma invariante de laÃ§o.
Vale notar que em algum momento a condiÃ§Ã£o do laÃ§o da linha 7 serÃ¡ verdadeira, jÃ¡
que, ao se remover uma rotaÃ§Ã£o exposta, removemos uma quantidade positiva de arestas,
de modo que hÃ¡ um decrÃ©scimo do grau de alguns vÃ©rtices.
Assim, logo antes da linha 11, vale a invariante (ğ¼ ) e a condiÃ§Ã£o do laÃ§o da linha 7. Se
algum ğ‘£ âˆˆ ğ‘‰ (ğº â€² ) = ğ‘‰ (ğº1 ) Ã© isolado, pelo Teorema dos Hospitais Rurais Generalizado, ğº â€²
nÃ£o apresenta emparelhamentos estÃ¡veis (com respeito a ğº). Portanto, usando a contrapositiva do lema 12, segue que ğº nÃ£o apresenta emparelhamentos estÃ¡veis e a linha 12 estÃ¡
justificada.
No caso em que a condiÃ§Ã£o da linha 11 Ã© falsa, segue que ğ¸(ğº â€² ) Ã© um emparelhamento,
o qual Ã© estÃ¡vel pois ğº â€² Ã© subgrafo estÃ¡vel de ğº ((ğ¼ ) e item 1 do lema 7). Assim, na linha 13,
o algoritmo devolve um emparelhamento estÃ¡vel.

3.1.5

Exemplo de execuÃ§Ã£o do algoritmo de Irving

Vamos descrever a execuÃ§Ã£o do algoritmo para o grafo de preferÃªncias ğº representado
na figura abaixo. Escrevemos ğ‘¥ â†’ ğ‘¦ para indicar que o vÃ©rtice ğ‘¥ fez um pedido para o
vÃ©rtice ğ‘¦.
ğ‘£2

ğ‘£1

ğ‘£3

ğ‘£6

ğ‘£4

ğ‘£1
ğ‘£2
ğ‘£3
ğ‘£4
ğ‘£5
ğ‘£6

âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘£6 ğ‘£3 ğ‘£4 ğ‘£5 ğ‘£2
ğ‘£4 ğ‘£1 ğ‘£3 ğ‘£6 ğ‘£5
ğ‘£4 ğ‘£5 ğ‘£6 ğ‘£2 ğ‘£1
ğ‘£5 ğ‘£3 ğ‘£6 ğ‘£2 ğ‘£1
ğ‘£6 ğ‘£1 ğ‘£3 ğ‘£2 ğ‘£4
ğ‘£4 ğ‘£2 ğ‘£5 ğ‘£1 ğ‘£3

ğ‘£5
Figura 3.3

Etapa 1
Uma possÃ­vel execuÃ§Ã£o do algoritmo Ã© a seguinte.
â€¢ ğ‘£1 â†’ ğ‘£6 . A aresta ğ‘£3 ğ‘£6 Ã© removida. ğ‘† = {(ğ‘£1 , ğ‘£6 )} e ğ¹ = ğ‘‰ â§µ {ğ‘£1 }.

37
3.1 | ALGORITMO DE IRVING

â€¢ ğ‘£2 â†’ ğ‘£4 . A aresta ğ‘£1 ğ‘£4 Ã© removida. ğ‘† = {(ğ‘£1 , ğ‘£6 ), (ğ‘£2 , ğ‘£4 )} e ğ¹ = ğ‘‰ â§µ {ğ‘£1 , ğ‘£2 }.
â€¢ ğ‘£3 â†’ ğ‘£4 . As arestas ğ‘£2 ğ‘£4 e ğ‘£6 ğ‘£4 sÃ£o removidas. ğ‘† = {ğ‘£1 , ğ‘£6 ), (ğ‘£3 , ğ‘£4 )} e ğ¹ = ğ‘‰ â§µ{ğ‘£1 , ğ‘£3 }.
Note que ğ‘£2 voltou a ser um vÃ©rtice livre.
â€¢ ğ‘£2 â†’ ğ‘£1 . Nenhuma aresta Ã© removida. ğ‘† = {(ğ‘£1 , ğ‘£6 ), (ğ‘£3 , ğ‘£4 ), (ğ‘£2 , ğ‘£1 } e ğ¹ =
{ğ‘£4 , ğ‘£5 , ğ‘£6 }.
â€¢ ğ‘£4 â†’ ğ‘£5 . Nenhuma aresta Ã© removida. ğ‘† = {ğ‘£1 , ğ‘£6 ), (ğ‘£3 , ğ‘£4 ), (ğ‘£2 , ğ‘£1 ), (ğ‘£4 , ğ‘£5 )} e ğ¹ =
{ğ‘£5 , ğ‘£6 }.
â€¢ ğ‘£5 â†’ ğ‘£6 . A aresta ğ‘£1 ğ‘£6 Ã© removida. ğ‘† = {ğ‘£1 , ğ‘£6 ), (ğ‘£3 , ğ‘£4 ), (ğ‘£2 , ğ‘£1 ), (ğ‘£4 , ğ‘£5 ), (ğ‘£5 , ğ‘£6 )} e
ğ¹ = {ğ‘£6 }.
â€¢ ğ‘£6 â†’ ğ‘£2 . A aresta ğ‘£5 ğ‘£2 Ã© removida. ğ‘† = {ğ‘£1 , ğ‘£6 ), (ğ‘£3 , ğ‘£4 ), (ğ‘£2 , ğ‘£1 ), (ğ‘£4 , ğ‘£5 ), (ğ‘£5 , ğ‘£6 )} e
ğ¹ = âˆ….
â€¢ Como ğ¹ = âˆ…, o loop principal se encerra devolvendo ğº1 (representado na figura
abaixo).

ğ‘£2

ğ‘£1

ğ‘£3

ğ‘£6

ğ‘£4

ğ‘£1
ğ‘£2
ğ‘£3
ğ‘£4
ğ‘£5
ğ‘£6

âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘£3 ğ‘£5 ğ‘£2
ğ‘£1 ğ‘£3 ğ‘£6
ğ‘£4 ğ‘£5 ğ‘£2 ğ‘£1
ğ‘£5 ğ‘£3
ğ‘£6 ğ‘£1 ğ‘£3 ğ‘£4
ğ‘£2 ğ‘£5

ğ‘£5
Figura 3.4

Etapa 2
Primeiramente, note que ğº1 nÃ£o estÃ¡ em nenhum caso degenerado. Agora, o algoritmo
prossegue buscando uma rotaÃ§Ã£o que serÃ¡, em seguida, removida. Aplicando o algoritmo
para encontrar rotaÃ§Ãµes (demonstraÃ§Ã£o do lema 9) para cada vÃ©rtice, Ã© possÃ­vel verificar
que a Ãºnica rotaÃ§Ã£o exposta no momento Ã© ğœŒ1 = (ğ‘£1 , ğ‘£5 ), (ğ‘£4 , ğ‘£3 ). Ao remover esta rotaÃ§Ã£o,
sÃ£o removidas as arestas ğ‘£3 ğ‘£1 , ğ‘£3 ğ‘£2 , ğ‘£3 ğ‘£5 e ğ‘£5 ğ‘£4 . Abaixo temos representado o grafo de
preferÃªncias que resulta dessa operaÃ§Ã£o.

38
3 | EMPARELHAMENTOS ESTÃVEIS EM GRAFOS QUAISQUER

ğ‘£2

ğ‘£1

ğ‘£3

ğ‘£6

ğ‘£4

ğ‘£1
ğ‘£2
ğ‘£3
ğ‘£4
ğ‘£5
ğ‘£6

âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘£5 ğ‘£2
ğ‘£1 ğ‘£6
ğ‘£4
ğ‘£3
ğ‘£6 ğ‘£1
ğ‘£2 ğ‘£5

ğ‘£5
Figura 3.5

Note que nenhum vÃ©rtice se tornou isolado. Assim, o algoritmo prossegue buscando
outra rotaÃ§Ã£o exposta. Desta vez, temos duas rotaÃ§Ãµes expostas: ğœŒ2 = (ğ‘£2 , ğ‘£6 ), (ğ‘£5 , ğ‘£1 )
e ğœŒ3 = (ğ‘£1 , ğ‘£2 ), (ğ‘£6 , ğ‘£5 ). O emparelhamento estÃ¡vel devolvido pelo algoritmo depende
da escolha da rotaÃ§Ã£o a ser removida. As figuras 3.6 e 3.7 correspondem aos grafos de
preferÃªncias resultantes ao se remover ğœŒ2 e ğœŒ3 , respectivamente. Em ambos os casos, o
grafo de preferÃªncias obtido corresponde a um emparelhamento estÃ¡vel.

ğ‘£2

ğ‘£1

ğ‘£3

ğ‘£6

ğ‘£4

ğ‘£1
ğ‘£2
ğ‘£3
ğ‘£4
ğ‘£5
ğ‘£6

âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘£5
ğ‘£6
ğ‘£4
ğ‘£3
ğ‘£6
ğ‘£2

ğ‘£5
Figura 3.6: Grafo de preferÃªncias resultante da remoÃ§Ã£o de ğœŒ2 = (ğ‘£2 , ğ‘£6 ), (ğ‘£5 , ğ‘£1 ) do grafo da figura
3.5.

39
3.1 | ALGORITMO DE IRVING

ğ‘£2

ğ‘£1

ğ‘£3

ğ‘£6

ğ‘£4

ğ‘£1
ğ‘£2
ğ‘£3
ğ‘£4
ğ‘£5
ğ‘£6

âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶
âˆ¶

ğ‘£2
ğ‘£1
ğ‘£4
ğ‘£3
ğ‘£6
ğ‘£5

ğ‘£5
Figura 3.7: Grafo de preferÃªncias resultante da remoÃ§Ã£o de ğœŒ3 = (ğ‘£1 , ğ‘£2 ), (ğ‘£6 , ğ‘£5 ) do grafo da figura
3.5.

41

CapÃ­tulo 4
ConclusÃ£o
O presente estudo teÃ³rico nos permitiu aplicar os conceitos de Algoritmos e Teoria
dos Grafos normalmente encontrados em um currÃ­culo de uma graduaÃ§Ã£o em CiÃªncia da
ComputaÃ§Ã£o. Vale notar que, a partir de conceitos elementares, como o de emparelhamento
estÃ¡vel e de grafos de preferÃªncias, foi possÃ­vel fazer uma anÃ¡lise profunda e rigorosa de
dois algoritmos: o algoritmo de Gale-Shapley e o algoritmo de Irving. Sendo o primeiro,
mais simples, mas nÃ£o menos relevante, e, o segundo, mais sofisticado.
AlÃ©m disso, usando conceitos abstratos de Teoria da Ordem, conseguimos concluir
a existÃªncia do emparelhamento ğ´-Ã³timo por meio de um raciocÃ­nio puramente nÃ£oconstrutivo. Isso evidencia que o estudo de Ã¡reas puramente abstratas, como Ãlgebra
Abstrata, nÃ£o deve ser negligenciado atÃ© mesmo no estudo de uma Ã¡rea com um teor mais
construtivo, como a de Algoritmos.
A investigaÃ§Ã£o aqui presente em nenhum momento teve a intenÃ§Ã£o de ser exaustiva
e nem teria como ser. Ao leitor interessado em se aprofundar nos temas aqui discutidos,
sugere-se a leitura de [5] e de [3]. Para o leitor interessado em expandir o seu conhecimento
na Ã¡rea de pesquisa de emparelhamentos estÃ¡veis, vale mencionar um tema que tem forte
relaÃ§Ã£o com o conteÃºdo deste material e vem sendo alvo de muitos estudos ultimamente:
o dos emparelhamentos populares ([8], [6]).

43

ReferÃªncias
[1] A. Bondy e U.S.R. Murty. Graph Theory. Graduate Texts in Mathematics. Springer
London, 2011. isbn: 9781846289699 (citado na pg. 2).
[2] B.A. Davey, H.A. Priestley e H.A.P. Priestley. Introduction to Lattices and Order. Cambridge mathematical textbooks. Cambridge University Press, 2002. isbn:
9780521784511. url: https://books.google.com.br/books?id=vVVTxeuiyvQC.
[3] M. David. Algorithmics Of Matching Under Preferences. Series On Theoretical Computer Science. World Scientific Publishing Company, 2013. isbn: 9789814425261
(citado na pg. 41).
[4] D. Gale e L. S. Shapley. â€œCollege Admissions and the Stability of Marriageâ€. Em:
The American Mathematical Monthly 69.1 (1962), pgs. 9â€“15. doi: 10.1080/00029890.
1962.11989827 (citado nas pgs. 1, 6).
[5] Dan Gusfield e Robert W. Irving. The Stable Marriage Problem: Structure and
Algorithms. Cambridge, MA, USA: MIT Press, 1989. isbn: 0-262-07118-5 (citado nas
pgs. 1, 10, 25, 41).
[6] Chien-Chung Huang e Telikepalli Kavitha. â€œPopular Matchings in the Stable
Marriage Problemâ€. Em: Automata, Languages and Programming. Ed. por Luca Aceto,
Monika Henzinger e JiÅ™Ã­ Sgall. Berlin, Heidelberg: Springer Berlin Heidelberg,
2011, pgs. 666â€“677. isbn: 978-3-642-22006-7 (citado na pg. 41).
[7] D.E. Knuth. Stable Marriage and Its Relation to Other Combinatorial Problems: An
Introduction to the Mathematical Analysis of Algorithms. CRM proceedings & lecture
notes. American Mathematical Soc. isbn: 9780821870129 (citado na pg. 25).
[8] Krishnapriya A M, Meghana Nasre, Prajakta Nimbhorkar e Amit Rawat. How
good are Popular Matchings? 2018. arXiv: 1805.01311 [cs.GT] (citado na pg. 41).
[9] Sara Robinson. â€œAre medical students meeting their (best possible) matchâ€. Em:
SIAM News 36.3 (2003), pgs. 8â€“9 (citado na pg. 18).
[10] Szestopalow, Michael Jay. Properties of Stable Matchings. 2010.

