Universidade de SÃ£o Paulo
Instituto de MatemÃ¡tica e EstatÃ­stica
Bacharelado em CiÃªncia da ComputaÃ§Ã£o

Jogo Educativo Phoenix Rising:
Para Ensino de Conceitos
de ProgramaÃ§Ã£o

Mateus Agostinho dos Anjos

Monografia Final
mac 0499 â€” Trabalho de
Formatura Supervisionado

Supervisor: Prof. Dr. Marco Dimas Gubitoso

SÃ£o Paulo
7 de janeiro de 2020

i

Agradecimentos
A conclusÃ£o deste trabalho sÃ³ foi possÃ­vel, pois muitas pessoas me ajudaram ao longo
do caminho. Sabia que nÃ£o seria fÃ¡cil, mas tinha certeza de que nÃ£o estaria sozinho.
AgradeÃ§o aos meus pais pela ajuda em momentos difÃ­ceis, quando pensei que desistir
fosse a melhor opÃ§Ã£o.
AgradeÃ§o Ã  minha irmÃ£ pelos momentos de alegria que me motivaram a continuar em
frente.
AgradeÃ§o aos amigos por enfrentarem as dificuldades comigo e pela parceria atÃ© nos
momentos tensos.
AgradeÃ§o aos professores que tive ao longo da vida por me incentivarem a aprender
cada vez mais, buscar as perguntas certas e nÃ£o sÃ³ as respostas esperadas.

Resumo
Mateus Agostinho dos Anjos. Jogo Educativo Phoenix Rising: Para Ensino de Conceitos
de ProgramaÃ§Ã£o. Monografia (Bacharelado). Instituto de MatemÃ¡tica e EstatÃ­stica, Universidade de SÃ£o Paulo, SÃ£o Paulo, 2019.

A ideia do trabalho Ã© desenvolver um jogo que facilite o aprendizado de conceitos iniciais de
programaÃ§Ã£o e que, ao mesmo tempo, tenha um cÃ³digo facilmente personalizÃ¡vel, fazendo com
que os indivÃ­duos tenham interesse em jogar e alterar as caracterÃ­sticas do jogo modificando
o cÃ³digo fonte, tornando o projeto um ambiente mais completo de aprendizado.
Para atender a demanda do projeto foi desenvolvido Phoenix Rising, um jogo cujo objetivo de
cada nÃ­vel Ã© criar um programa que processa dados de entrada e devolve uma determinada
resposta, conquistando pontos ao concluir cada desafio. Para isso o jogador deve solucionar
um tipo de quebra cabeÃ§as e utilizar conceitos de programaÃ§Ã£o.
A fim de facilitar o aprendizado, existe uma animaÃ§Ã£o que aparece na tela e mostra como os
valores do programa criado se modificam a cada comando executado.
JÃ¡ para os jogadores que gostam de efetuar algumas modificaÃ§Ãµes e criar novos comandos,
por exemplo, o cÃ³digo Ã© aberto e foi pensado de maneira a facilitar as personalizaÃ§Ãµes e a
continuaÃ§Ã£o do projeto.

Palavras-chave: Phoenix Rising. Godot. Jogo Educativo.

v

Lista de Figuras
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
2.10
2.11

Exemplo de Ã¡rvore . . . . . . . . . . . . . . . . . . . . .
Logo da Godot game engine . . . . . . . . . . . . . . . .
Exemplo de nÃ³s . . . . . . . . . . . . . . . . . . . . . .
SÃ­mbolo que indica Cena Instanciada . . . . . . . . . .
Cena Tutorial . . . . . . . . . . . . . . . . . . . . . . .
Cena InputOutput . . . . . . . . . . . . . . . . . . . . .
Exemplo de instanciaÃ§Ã£o . . . . . . . . . . . . . . . . .
Sinais prÃ© programados de um nÃ³ do tipo Button . . . .
Sinal input_output_defined criado por cÃ³digo . . . . . .
Sinal input_output_defined conectado via interface . . .
Sinal variable_changed conectado via cÃ³digo (linha 12.)

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

3
4
5
6
7
7
7
10
10
10
10

3.1
3.2
3.3
3.4
3.5
3.6
3.7
3.8
3.9
3.10
3.11
3.12
3.13
3.14
3.15
3.16
3.17

Exemplo de um nÃ­vel . . . . . . . .
Exemplo de entrada . . . . . . . . .
Objetivos . . . . . . . . . . . . . . .
Tempo restante no inÃ­cio do nÃ­vel .
PontuaÃ§Ã£o obtida . . . . . . . . . .
Entrada e SaÃ­da . . . . . . . . . . .
Um espaÃ§o de aÃ§Ã£o . . . . . . . . .
Ãcones de arrastar . . . . . . . . . .
Ãcone de trocas de conexÃµes . . . .
Exemplos de conexÃµes alteradas . .
PosiÃ§Ã£o na ordem de aÃ§Ãµes (1) . . .
EspaÃ§o para Argumentos . . . . . .
EspaÃ§o de AÃ§Ã£o com Comando Print
InventÃ¡rio com Comandos . . . . .
Processo visual para If . . . . . . . .
Processo visual para Else . . . . . .
Valores das VariÃ¡veis . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

13
14
14
14
15
16
16
17
17
17
17
18
18
18
19
19
20

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

vi

3.18
3.19
3.20
3.21
3.22
3.23
3.24
3.25
3.26
3.27

Processo visual para mudanÃ§a nas variÃ¡veis .
Setas de Entrada e SaÃ­da . . . . . . . . . . . .
Jogo nÃ£o conectado . . . . . . . . . . . . . .
Jogo conectado . . . . . . . . . . . . . . . . .
Exemplo de comandos disponÃ­veis . . . . . .
Jogador preenchendo os argumentos . . . .
Sistema pronto para execuÃ§Ã£o . . . . . . . .
InÃ­cio da execuÃ§Ã£o do sistema . . . . . . . .
Valor do Input antes da operaÃ§Ã£o . . . . . . .
Valor do Input apÃ³s a operaÃ§Ã£o . . . . . . . .

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

20
21
22
22
23
23
24
24
25
25

4.1
4.2
4.3
4.4
4.5
4.6
4.7
4.8
4.9
4.10
4.11
4.12
4.13
4.14
4.15
4.16
4.17
4.18
4.19
4.20
4.21
4.22
4.23
4.24
4.25
4.26
4.27

Ãrvore da cena Inventory . . . . . . . . . . . . . . . . . .
FunÃ§Ãµes do script do nÃ³ Inventory . . . . . . . . . . . . .
VariÃ¡veis do script do nÃ³ Inventory . . . . . . . . . . . .
VariÃ¡veis do Grid . . . . . . . . . . . . . . . . . . . . . .
inicializaÃ§Ã£o do Grid . . . . . . . . . . . . . . . . . . . . .
MÃ©todo de inserÃ§Ã£o de um item . . . . . . . . . . . . . .
MarcaÃ§Ã£o das posiÃ§Ãµes do grid . . . . . . . . . . . . . . .
Cena MovableActionSpace . . . . . . . . . . . . . . . . .
Cena ActionSpace . . . . . . . . . . . . . . . . . . . . . .
Sistema gerador da Ãrvore de ExecuÃ§Ã£o . . . . . . . . . .
Esquema de Ãrvore de ExecuÃ§Ã£o . . . . . . . . . . . . . .
Cena Visual Process . . . . . . . . . . . . . . . . . . . . .
VariÃ¡veis Visual Process . . . . . . . . . . . . . . . . . .
FunÃ§Ã£o _on_MoveableActionSpace_change_area_entered
Ãrvore da cena RunEnvironment . . . . . . . . . . . . .
FunÃ§Ãµes de RunEnvironment.gd . . . . . . . . . . . . . .
FunÃ§Ã£o do botÃ£o Rodar! . . . . . . . . . . . . . . . . . .
Sistema gerador da Ãrvore de ExecuÃ§Ã£o nÃ£o Conectada .
Esquema de Ãrvore de ExecuÃ§Ã£o nÃ£o Conectada . . . . .
FunÃ§Ã£o _process_input . . . . . . . . . . . . . . . . . . .
Parte do Script de DeclaraÃ§Ã£o dos Comandos . . . . . . .
FunÃ§Ã£o get_item . . . . . . . . . . . . . . . . . . . . . . .
Exemplo de pickup_item_list . . . . . . . . . . . . . . . .
FunÃ§Ã£o pickup_item . . . . . . . . . . . . . . . . . . . . .
Exemplo de mensagem da caixa de diÃ¡logo . . . . . . . .
Exemplo de painel de ajuda . . . . . . . . . . . . . . . . .
Exemplo de nÃ­vel base . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

28
28
28
29
29
29
30
30
30
32
32
34
35
36
37
37
38
39
39
39
41
42
42
42
43
44
45

vii

SumÃ¡rio
1 IntroduÃ§Ã£o
1.1 MotivaÃ§Ã£o e Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 OrganizaÃ§Ã£o do Projeto . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 VisÃ£o Geral do Jogo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Conceitos BÃ¡sicos
2.1 O Conceito de Ãrvore . . . . . . .
2.2 O que Ã© Game Engine? . . . . . .
2.3 Entendendo sobre a Godot Engine
2.3.1 NÃ³s . . . . . . . . . . . . .
2.3.2 Cenas . . . . . . . . . . .
2.3.3 InstÃ¢ncias . . . . . . . . .
2.3.4 SceneTree . . . . . . . . .
2.3.5 Singleton . . . . . . . . .
2.3.6 Sinais . . . . . . . . . . .
2.3.7 GDScripts . . . . . . . . .

1
1
2
2

.
.
.
.
.
.
.
.
.
.

3
3
4
4
5
6
6
8
9
9
11

.
.
.
.
.
.
.
.

13
13
15
15
16
18
20
21
21

4 ImplementaÃ§Ã£o do Projeto
4.1 InventÃ¡rio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

27
27

3 O Jogo
3.1 Objetivo Dentro do Jogo . . . .
3.2 Elementos do Jogo . . . . . . . .
3.2.1 Entrada e SaÃ­da . . . . .
3.2.2 EspaÃ§o de AÃ§Ã£o . . . . .
3.2.3 InventÃ¡rio e Comandos .
3.2.4 Setas de Entrada e SaÃ­da
3.2.5 BotÃµes . . . . . . . . . .
3.3 Forma de Jogar . . . . . . . . . .

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

viii

4.2
4.3
4.4
4.5
4.6
4.7
4.8

EspaÃ§o de AÃ§Ã£o . . . .
Processo Visual . . . .
Ambiente de ExecuÃ§Ã£o
Comandos do Jogo . . .
Ajuda ao UsuÃ¡rio . . .
Gamification . . . . . .
NÃ­vel Base . . . . . . .

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

30
33
37
40
43
44
45

5 ConsideraÃ§Ãµes Finais
5.1 UsuÃ¡rios e o Tutorial . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 RefatoraÃ§Ãµes do CÃ³digo . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

47
47
48
49

6 ConclusÃ£o

51

ApÃªndices
Anexos

Bibliografia

53

1

CapÃ­tulo 1
IntroduÃ§Ã£o
1.1

MotivaÃ§Ã£o e Objetivos

Com a crescente ascensÃ£o da tecnologia nos dias de hoje, o conhecimento sobre programaÃ§Ã£o tem se tornado cada vez mais importante, nÃ£o sÃ³ pelas inÃºmeras aplicaÃ§Ãµes
que existem, mas tambÃ©m por ser um facilitador, tanto na vida pessoal quanto na vida
profissional.
Devido a esse fato, houve um grande aumento no nÃºmero de interessados pelo conhecimento da programaÃ§Ã£o e, consequentemente, o ensino de tal Ã¡rea tem se difundido
cada vez mais. Entretanto, muitos dos interessados por tais tÃ©cnicas nÃ£o dispÃµem do
tempo necessÃ¡rio ou da paciÃªncia e concentraÃ§Ã£o para o aprendizado tradicional, ou seja,
leituras extensas sobre os temas e longas sessÃµes prÃ¡ticas para a aplicaÃ§Ã£o das tÃ©cnicas
aprendidas.
Neste momento os jogos ganham forÃ§a como disseminadores do conhecimento para
os que buscam o primeiro contato com esta Ã¡rea, pois sÃ£o uma forma divertida e rÃ¡pida
de se adquirir experiÃªncia bÃ¡sica sobre algo. Por ser uma forma simples e dinÃ¢mica de
aprendizado o indÃ­viduo encontra mais facilidade para encaixar o jogo em sua agenda do
que ler um livro teÃ³rico sobre algo.
Desta forma, visando proporcionar um ambiente facilitador do aprendizado dos conceitos de programaÃ§Ã£o para indivÃ­duos iniciantes ou com pouca experiÃªncia, foi desenvolvido
o jogo Phoenix Rising que gamifica 1 uma plataforma de ensino. AlÃ©m disso a estrutura do
cÃ³digo foi pensada de modo a facilitar a inserÃ§Ã£o de novas caracterÃ­sticas ao jogo pelos indivÃ­duos que tÃªm certa experiÃªncia em programaÃ§Ã£o, fazendo com que o projeto desenvolvido
sirva para uma grande parte dos interessados em aprofundar o conhecimento.

1 Uso

de mecÃ¢nicas e dinÃ¢micas de jogos para engajar pessoas, resolver problemas e melhorar o aprendizado, motivando aÃ§Ãµes e comportamentos em ambientes fora do contexto de jogos.

2
1 | INTRODUÃ‡ÃƒO

1.2

OrganizaÃ§Ã£o do Projeto

O projeto foi desenvolvido utilizando Godot na versÃ£o 3.1.1 stable, uma game engine
que facilita a produÃ§Ã£o de jogos e possui uma linguagem prÃ³pria chamada GDScript. Todo
o cÃ³digo do jogo estÃ¡ mantido no GitHub, portanto o projeto Ã© open source, o que facilita
a contribuiÃ§Ã£o pela comunidade.
Como um dos objetivos do projeto Ã© disponibilizar o cÃ³digo fonte para melhorias serem
implementadas, o cÃ³digo e comentÃ¡rios estÃ£o em inglÃªs, seguindo as boas prÃ¡ticas de
programaÃ§Ã£o. Vale salientar tambÃ©m que a eficiÃªncia nÃ£o foi o principal ponto do projeto
mas sim a legibilidade e a flexibilidade do cÃ³digo, portanto em algumas partes preferiu-se
utilizar um pouco mais de memÃ³ria e/ou processamento, embora tais escolhas nÃ£o tenham
grande impacto na jogabilidade.

1.3

VisÃ£o Geral do Jogo

Para nortear o leitor neste trabalho, aqui estÃ¡ uma breve descriÃ§Ã£o sobre como o jogo
funciona.
O objetivo do jogador Ã© completar o maior nÃºmero de desafios no menor tempo possÃ­vel,
maximizando o somatÃ³rio de pontos. Para isso ele deve resolver o problema de cada nÃ­vel
criando um programa que processa os dados de entrada e devolve dados de saÃ­da iguais ao
dados de saÃ­da esperados no nÃ­vel.
A resoluÃ§Ã£o do desafio pode ser dividido em duas etapas, a primeira Ã© resolver o quebra
cabeÃ§as e a segunda Ã© posicionar os comandos de programaÃ§Ã£o da forma correta, para que
o programa processe corretamente os dados. O quebra cabeÃ§as consiste em conectar a
entrada dos dados com a saÃ­da da resposta esperada, utilizando conexÃµes especÃ­ficas. ApÃ³s
completado o primeiro desafio, o jogador deve posicionar os comandos disponibilizados
para criar o programa que solucionarÃ¡ o problema daquele nÃ­vel.
Tudo isso deve ser feito no menor tempo possÃ­vel, pois hÃ¡ um cronÃ´metro que marca
quanto tempo o jogador tem para solucionar o nÃ­vel e os pontos ganhos sÃ£o diretamente
porporcionais ao tempo restante.
Para auxiliar o processo de aprendizado, o jogador conta com mensagens de guia no
inÃ­cio do jogo alÃ©m de uma animaÃ§Ã£o que aparece na tela ao executar o programa criado.
Nesta animaÃ§Ã£o Ã© possÃ­vel ver o que acontece com os valores de entrada e atÃ© mesmo
acompanhar como as variÃ¡veis do programa estÃ£o mudando.
As informaÃ§Ãµes sobre o cÃ³digo do jogo estarÃ£o explicadas mais adiante. As explicaÃ§Ãµes incluem como os arquivos estÃ£o organizados, como cenas mais importantes foram
implementadas e algumas imagens que exemplificam trechos de alguns scripts2 mais
importantes.

2 conjunto

de instruÃ§Ãµes para que uma funÃ§Ã£o (ou mÃ©todo) seja executada em determinado aplicativo.

3

CapÃ­tulo 2
Conceitos BÃ¡sicos
2.1

O Conceito de Ãrvore

Para facilitar o entendimento, deve-se entender um pouco sobre o que Ã© uma Ã¡rvore no
escopo da programaÃ§Ã£o, pois tal conceito aparecerÃ¡ muitas vezes neste trabalho. Entretanto
a definiÃ§Ã£o informal, passando apenas a ideia do funcionamento, bastarÃ¡ para entender
este projeto.
Ãrvore refere-se a uma forma de estruturar os dados de um programa; informalmente,
pode ser definido como um conjunto de elementos que armazenam informaÃ§Ãµes, por sua
vez sÃ£o os chamados nÃ³s. Toda Ã¡rvore possui o elemento chamado raiz, que Ã© primeiro nÃ³,
de onde a Ã¡rvore comeÃ§a, e que possui ligaÃ§Ãµes para outros elementos denominados filhos,
que por sua vez tambÃ©m sÃ£o nÃ³s.

Figura 2.1: Exemplo de Ã¡rvore

Note que a Ã¡rvore cresce para baixo, sendo que a raiz dÃ¡ origem a tudo. Os nÃ³s A, B,

4
2 | CONCEITOS BÃSICOS

C, D sÃ£o filhos da Raiz. Os nÃ³s E, F sÃ£o filhos do nÃ³ A. O nÃ³ D Ã© filho da Raiz e nÃ£o tem
filhos.
Como a estrutura dos projetos criados utilizando a Godot Engine Ã© baseada em Ã¡rvores,
jÃ¡ Ã© possÃ­vel entender parte de como o jogo desenvolvido foi estruturado. Entretanto ainda
Ã© necessÃ¡rio explicar o que Ã© uma Game Engine.

2.2

O que Ã© Game Engine?

Uma game engine Ã© um programa para computador com um conjunto de bibliotecas
capaz de juntar e construir, em tempo real, todos os elementos de um jogo. Ela inclui
motor grÃ¡fico para renderizar grÃ¡ficos em 2D ou 3D, motor de fÃ­sica para detectar colisÃµes
e fazer animaÃ§Ãµes, alÃ©m de suporte para sons, inteligÃªncia artificial, gerenciamento de
arquivos, programaÃ§Ã£o, entre outros. Por conta dessas facilidades, a partir do uso de uma
game engine, Ã© possÃ­vel criar um jogo do zero de maneira mais simples e replicar vÃ¡rios
estilos de jogos com mais facilidade.
Pelas facilidades com a estrutura e organizaÃ§Ã£o do cÃ³digo, a linguagem prÃ³pria e por ser
um software open source sob a licenÃ§a MIT, desenvolvido de forma independente pela comunidade, foi escolhido a Godot game engine para este projeto, tendo como motivaÃ§Ã£o extra o
grupo de extensÃ£o de jogos da Universidade de SÃ£o Paulo, chamado USPGameDev.

Figura 2.2: Logo da Godot game engine

Como foi estabelecido o conhecimento sobre alguns termos gerais, agora Ã© possÃ­vel
entender o bÃ¡sico de como funciona a Godot Engine.

2.3

Entendendo sobre a Godot Engine

A seguir estÃ£o as explicaÃ§Ãµes dos conceitos bÃ¡sicos.

5
2.3 | ENTENDENDO SOBRE A GODOT ENGINE

2.3.1

NÃ³s

NÃ³s sÃ£o blocos de construÃ§Ã£o fundamentais para a criaÃ§Ã£o de um jogo. Um nÃ³ pode
executar uma variedade de funÃ§Ãµes especializadas. No entanto, qualquer nÃ³ fornecido
sempre possui os seguintes atributos:
âˆ™ Possui um nome.
âˆ™ Possui propriedades editÃ¡veis.
âˆ™ Ele pode receber um retorno de chamada (callback) para processar todos os quadros
(frames).
âˆ™ Pode ser estendido (para ter mais funÃ§Ãµes).
âˆ™ Pode ser adicionado a outro nÃ³ como filho.
Perceba que o Ãºltimo atributo Ã© muito importante, pois quando nÃ³s tem outros nÃ³s
como filhos o conjunto se torna uma Ã¡rvore, como foi explicado anteriormente. Em Godot,
a capacidade de organizar nÃ³s dessa maneira cria uma ferramenta poderosa para organizar
projetos. Como nÃ³s diferentes tÃªm funÃ§Ãµes diferentes, combinÃ¡-los permite a criaÃ§Ã£o de
funÃ§Ãµes mais complexas, a partir disso Phoenix Rising foi criado.

Note que na imagem ao lado existem
vÃ¡rios nÃ³s diferentes, porÃ©m todos
sÃ£o verdes, isso se deve ao fato de todos herdarem da classe Control, nÃ³s
que compÃµem a interface de usuÃ¡rio.
Os Ã­cones do lado esquerdo de cada
nome dos nÃ³s indicam a qual classe
filha pertence o nÃ³ escolhido. De
uma maneira informal pode-se entender isso como a especializaÃ§Ã£o
deste nÃ³ dentro da classe Control.
O nÃ³ chamado Menu Ã© filho da raÃ­z
da cena, chamada TitleScreen, e tambÃ©m tem um filho chamado Texture
Rect, exemplificando o Ãºltimo atributo citado acima.
Figura 2.3: Exemplo de nÃ³s

A partir do exemplo acima Ã© possÃ­vel entender como a organizaÃ§Ã£o dos nÃ³s contrÃ³i a
Ã¡rvore de cena, conceito explicado na prÃ³xima seÃ§Ã£o.

6
2 | CONCEITOS BÃSICOS

2.3.2

Cenas

Uma cena Ã© composta por um grupo de nÃ³s organizados hierarquicamente (em forma
de Ã¡rvore). AlÃ©m disso, uma cena:
âˆ™ Sempre tem um nÃ³ raiz.
âˆ™ Pode ser salva no disco e carregada de volta.
âˆ™ Pode ser instanciada.
Neste caso o nÃ³ ficarÃ¡ marcado com o sÃ­mbolo:

Figura 2.4: SÃ­mbolo que indica Cena Instanciada

Executar um jogo significa executar uma cena. Um projeto pode conter vÃ¡rias cenas, mas
para o jogo comeÃ§ar, uma delas deve ser selecionada como a cena principal.
Basicamente, o editor Godot Ã© um editor de cenas. Possui muitas ferramentas para
editar cenas 2D e 3D, bem como interfaces com o usuÃ¡rio, mas o editor Ã© baseado no
conceito de ediÃ§Ã£o de uma cena e nos nÃ³s que a compÃµem.

2.3.3

InstÃ¢ncias

Criar uma Ãºnica cena e adicionar nÃ³s a ela pode funcionar para pequenos projetos,
mas Ã  medida que o projeto aumenta em tamanho e complexidade, o nÃºmero de nÃ³s pode
se tornar rapidamente incontrolÃ¡vel. Para resolver isso, Godot permite que um projeto
seja separado em qualquer nÃºmero de cenas. Isso fornece uma ferramenta poderosa que
ajuda a organizar os diferentes componentes do seu jogo.
Em Cenas e nÃ³s, uma cena Ã© uma coleÃ§Ã£o de nÃ³s organizados em uma estrutura de
Ã¡rvore, com um Ãºnico nÃ³ como raiz da Ã¡rvore. Pode-se criar quantas cenas forem desejadas
e salvÃ¡-las em disco. As cenas salvas dessa maneira sÃ£o chamadas de "Cenas compactadas"
(packed scenes) e tÃªm uma extensÃ£o de nome de arquivo ".tscn".
No exemplo mostrado na figura, a cena Tutorial Ã© composta por vÃ¡rios outros nÃ³s,
dentre eles o nÃ³ InputOutput tambÃ©m Ã© uma cena e foi instanciada.

7
2.3 | ENTENDENDO SOBRE A GODOT ENGINE

Figura 2.5: Cena Tutorial

Figura 2.6: Cena InputOutput

Instanciar uma cena utilizando Godot Ã© bem fÃ¡cil; basta clicar no botÃ£o de instanciar
cena e selecionar qual cena salva que se deseja instanciar.

Figura 2.7: Exemplo de instanciaÃ§Ã£o

A instanciaÃ§Ã£o Ã© muito utilizada em Phoenix Rising, portanto esta parte deve ficar
mais clara conforme adentramos nos detalhes da estrutura e de implementaÃ§Ã£o mais
adiante.

8
2 | CONCEITOS BÃSICOS

2.3.4

SceneTree

Para entender melhor o que Ã© uma SceneTree deve-se entender um pouco sobre o modo
como Godot trabalha internamente.
Primeiro, a Ãºnica instÃ¢ncia que Ã© executada no inÃ­cio pertence Ã  classe OS. Depois,
todos os drivers, servidores, linguagens de script, sistema de cenas e outros recursos sÃ£o
carregados.
Quando a inicializaÃ§Ã£o estiver concluÃ­da, o sistema operacional precisarÃ¡ receber
um MainLoop para executar. AtÃ© o momento, tudo isso funciona internamente (pode-se
verificar o arquivo "main.cpp"no cÃ³digo-fonte se estiver interessado em ver como isso
funciona internamente).
Este MainLoop dÃ¡ inÃ­cio ao programa do usuÃ¡rio, ou jogo. Essa classe possui alguns
mÃ©todos, para inicializaÃ§Ã£o, callbacks e input. Novamente, esse Ã© um nÃ­vel baixo e, ao fazer
jogos em Godot, escrever seu prÃ³prio MainLoop raramente faz sentido.
A partir disso o sistema de cena fornece seu prÃ³prio loop principal para o OS, chamado
de SceneTree. Isso Ã© instanciado automaticamente e definido ao executar uma cena, sem a
necessidade de fazer nenhum trabalho extra.
Agora que a SceneTree foi introduzida Ã© importante saber que ela existe e possui algumas
caracterÃ­sticas, como:
âˆ™ ContÃ©m o Viewport raiz, ao qual uma cena Ã© adicionada como filha quando Ã© aberta
pela primeira vez para se tornar parte da SceneTree.
âˆ™ ContÃ©m informaÃ§Ãµes sobre os grupos e possui os meios para chamar todos os nÃ³s
em um grupo ou obter uma lista deles.
âˆ™ ContÃ©m algumas funcionalidades do estado atual do jogo, como definir o modo de
pausa ou tÃ©rmino de processos.
Desta forma, quando um nÃ³ Ã© conectado, direta ou indiretamente, Ã  viewport raiz, ele
se torna parte da SceneTree. Quando os nÃ³s entram na Ãrvore da cena, eles se tornam
ativos. Eles tÃªm acesso a tudo o que precisam para processar, obter informaÃ§Ãµes, exibir
imagens em 2D e 3D, receber e enviar notificaÃ§Ãµes, reproduzir sons, entre outros processamentos. Quando sÃ£o removidos da Ã¡rvore da cena, perdem essas habilidades, evitado
alguns comportamentos indesejados.
A importÃ¢ncia de se entender tudo isso, para este projeto, se dÃ¡ pois a maioria das
operaÃ§Ãµes de nÃ³ em Godot, como desenhar 2D, processar ou obter notificaÃ§Ãµes, sÃ£o feitas
seguindo a ordem na qual os nÃ³s estÃ£o na Ã¡rvore.
O processo de tornar um nÃ³ ativo ao entrar na SceneTree se dÃ¡ seguindo os passos:
1. Uma cena Ã© carregada do disco ou criada por script.
2. A raiz dessa cena Ã© adicionada como filha de Viewport, ou como filha de qualquer
filha de Viewport

9
2.3 | ENTENDENDO SOBRE A GODOT ENGINE

3. Cada nÃ³ da cena recÃ©m-adicionada receberÃ¡ a notificaÃ§Ã£o "enter_tree" na ordem de
cima para baixo, ou seja, o pai Ã© notificado e depois cada um de seus filhos.
4. Uma notificaÃ§Ã£o extra, "ready" Ã© fornecida por conveniÃªncia, quando um nÃ³ e todos
os seus filhos estÃ£o dentro da cena ativa.
5. Quando uma cena (ou parte dela) Ã© removida, eles recebem a notificaÃ§Ã£o "exit_tree"
na ordem de baixo para cima, ou seja, os filhos sÃ£o notificados e depois o pai.

2.3.5

Singleton

O sistema de cenas utilizado em Godot, embora poderoso e flexÃ­vel, tem uma desvantagem: nÃ£o hÃ¡ mÃ©todo para armazenar informaÃ§Ãµes, por exemplo, pontuaÃ§Ã£o do jogador
(inclusive utilizado neste projeto), que Ã© necessÃ¡rio para mais de uma cena.
Existem alternativas de implementaÃ§Ã£o ao se deparar com estes problemas, porÃ©m na
maioria dos casos o padrÃ£o Singleton irÃ¡ consumir menos tempo e memÃ³ria. Isso deve-se
ao fato de Singleton ser uma ferramenta Ãºtil para resolver o caso de uso comum no qual hÃ¡
necessidade de se armazenar informaÃ§Ãµes persistentes entre as cenas. No nosso caso, Ã©
possÃ­vel reutilizar a mesma cena ou classe para vÃ¡rios Singletons, desde que eles tenham
nomes diferentes.
Resumindo, usando esse conceito, pode-se criar objetos que:
âˆ™ Sempre estejam carregados e prontos para uso, independentemente da cena em
execuÃ§Ã£o no momento.
âˆ™ Pode armazenar variÃ¡veis globais, como informaÃ§Ãµes do jogador.
âˆ™ Pode lidar com alternÃ¢ncia de cenas e transiÃ§Ãµes entre cenas.
Vale lembrar tambÃ©m que o carregamento automÃ¡tico de nÃ³s e scripts pode nos dar
essas caracterÃ­sticas ao custo de processamento.

2.3.6

Sinais

Sinais permitem que um nÃ³ envie uma mensagem que outros nÃ³s possam ouvir e
responder. Por exemplo, em vez de verificar continuamente um botÃ£o para ver se ele estÃ¡
sendo pressionado, o botÃ£o pode emitir um sinal quando Ã© pressionado e assim quem
receber o sinal poderÃ¡ executar o que Ã© necessÃ¡rio.
Servem, portanto, para dissociar os objetos do jogo, o que leva a um cÃ³digo melhor
organizado, mais legÃ­vel e limpo. TambÃ©m faz com que os objetos do jogo nÃ£o precisem
estar sempre em conexÃ£o com outros, pois um nÃ³ pode emitir um sinal e apenas os
nÃ³s interessados em tratar tal evento, aqueles que o emissor se conectou, recebam este
sinal.
Alguns nÃ³s jÃ¡ vem com uma serie de sinais prontos para serem conectados, como visto
na figura abaixo:

10
2 | CONCEITOS BÃSICOS

Figura 2.8: Sinais prÃ© programados de um nÃ³ do tipo Button

Note que o sinal pressed() relativo ao nÃ³ chamado FullScreen jÃ¡ estÃ¡ conectado (note o
Ã­cone em verde, que simboliza a conexÃ£o).
Entretando nem sempre estes sinais cobrem a necessidade do projeto. Sendo assim Ã©
preciso criar o prÃ³prio sinal, utilizando cÃ³digo. Veja o exemplo abaixo:

Figura 2.9: Sinal input_output_defined criado por cÃ³digo

Veja que foi criado o sinal chamado input_output_defined que carrega dois parÃ¢metros:
input e output.
Depois pode-se conectar o sinal utilizando a interface de programaÃ§Ã£o que o Godot
oferece ou conectÃ¡-lo via cÃ³digo como visto nas imagens a seguir:

Figura 2.10: Sinal input_output_defined conectado via interface

Figura 2.11: Sinal variable_changed conectado via cÃ³digo (linha 12.)

11
2.3 | ENTENDENDO SOBRE A GODOT ENGINE

2.3.7

GDScripts

GDScript Ã© uma linguagem de programaÃ§Ã£o de alto nÃ­vel e tipagem dinÃ¢mica usada para
criar e modelar o comportamento dos nÃ³s. Ela usa uma sintaxe semelhante ao Python (os
blocos sÃ£o baseados em identaÃ§Ã£o e muitas palavras-chave sÃ£o semelhantes). Seu objetivo
Ã© ser otimizada e fortemente integrada ao Godot Engine, permitindo grande flexibilidade
para criaÃ§Ã£o e integraÃ§Ã£o de conteÃºdo.
Quando adicionado ao nÃ³, o script adiciona comportamento a ele, controlando seu
funcionamento e as interaÃ§Ãµes com outros nÃ³s: filhos, pais, irmÃ£os e assim por diante.
O escopo local do script Ã© o prÃ³prio nÃ³. Em outras palavras, o script herda as funÃ§Ãµes
fornecidas por esse nÃ³.

13

CapÃ­tulo 3
O Jogo
3.1

Objetivo Dentro do Jogo

Para que seja mais fÃ¡cil entender o projeto como um todo, esta seÃ§Ã£o explicarÃ¡ o
objetivo que o jogador deve alcanÃ§ar ao jogar Phoenix Rising. A imagem abaixo exemplifica
um nÃ­vel do jogo.

Figura 3.1: Exemplo de um nÃ­vel

O jogador irÃ¡ receber dados que serÃ£o mostrados dentro do retÃ¢ngulo azul, posicionado
no lado esquerdo da tela. O exemplo abaixo mostra um nÃ­vel que fornece ao jogador os
nÃºmeros 7 e 41 como dados iniciais.

14
3 | O JOGO

Figura 3.2: Exemplo de entrada

O objetivo do jogador Ã© conseguir reproduzir o que estÃ¡ no retÃ¢ngulo verde, posicionado
no lado direito da tela, chamado "Resposta Esperada". No exemplo abaixo o nÃ­vel exige
que o jogador reproduza os nÃºmeros 8 e 42. ApÃ³s o programa do jogador ser executado a
saÃ­da que ele obteve aparecerÃ¡ abaixo de "Sua Resposta" que estÃ¡ no retÃ¢ngulo vermelho
(fig(a)) e caso o resultado em "Sua Resposta" for igual ao que estÃ¡ em "Resposta Esperada"o
retÃ¢ngulo tambÃ©m ficarÃ¡ verde (fig (b)).

(a) Objetivo nÃ£o alcanÃ§ado

(b) Objetivo alcanÃ§ado

Figura 3.3: Objetivos

O jogador deve cumprir o objetivo dentro do tempo limite para acumular pontos.
Este tempo Ã© mostrado constantemente na tela e sempre iniciarÃ¡ com 120 segundos
restantes.

Figura 3.4: Tempo restante no inÃ­cio do nÃ­vel

15
3.2 | ELEMENTOS DO JOGO

Ao concluir o nÃ­vel o jogador ganharÃ¡ pontos iguais ao valor de tempo que restava
ao apertar o botÃ£o "rodar!", obviamente os pontos sÃ³ serÃ£o obtidos caso o objetivo seja
alcanÃ§ado. Este fato estÃ¡ relacionado com a duraÃ§Ã£o do processo visual que o jogo possui e serÃ¡ explicado mais adiante, por hora deve-se entender que existe um sistema de
pontuaÃ§Ã£o.

Figura 3.5: PontuaÃ§Ã£o obtida

Note que, se o jogador tinha zero pontos quando concluiu este nÃ­vel, o programa criado
que alcanÃ§ou o objetivo foi executado quando ainda havia 101 segundos restantes, porÃ©m
a animaÃ§Ã£o continuou executando, consequentemente o tempo continuou correndo, para
que o usuÃ¡rio pudesse visualizar o que estÃ¡ acontecendo durante a execuÃ§Ã£o do programa
criado e aprender como funciona cada comando.
Portanto o objetivo final de Phoenix Rising Ã© completar o maior nÃºmero de nÃ­veis no
menor tempo possÃ­vel para maximizar o somatÃ³rio de pontos. Para isso o jogador deve
aprender a mecÃ¢nica de jogo, o que e como cada comando executa sua instruÃ§Ã£o e como
montar o quebra cabeÃ§a dos diferentes nÃ­veis.

3.2

Elementos do Jogo

Agora que o objetivo do jogo foi explicitado, deve-se entender quais elementos estÃ£o
envolvidos para que o jogador possa concluir o desafio.

3.2.1

Entrada e SaÃ­da

Estes termos sÃ£o recorrentes na computaÃ§Ã£o e geralmente sÃ£o chamados de Intput 1 e
Output 2 respectivamente. Neste jogo a entrada e saÃ­da estÃ£o delimitadas pelos retÃ¢ngulos
coloridos e servem para mostrar para o jogador o que ele receberÃ¡ para processar e o que
ele deve produzir com o cÃ³digo gerado.

1 Dados
2 Dados

fornecidos para o sistema processar
que o sistema gera apÃ³s o processamento

16
3 | O JOGO

(a) Exemplo de Entrada

(b) Exemplo de SaÃ­da

Figura 3.6: Entrada e SaÃ­da

3.2.2

EspaÃ§o de AÃ§Ã£o

Os espaÃ§os de aÃ§Ã£o sÃ£o as Ã¡reas mÃ³veis do jogo que permitem montar o quebra-cabeÃ§as
e que recebem os comandos que executarÃ£o as aÃ§Ãµes de processamento dos dados de
entrada. Portanto este Ã© um dos principais itens do jogo.

Figura 3.7: Um espaÃ§o de aÃ§Ã£o

17
3.2 | ELEMENTOS DO JOGO

O jogador pode:
âˆ™ Movimentar o espaÃ§o de aÃ§Ã£o ao clicar no Ã­cone de arrastar.

(a) Ãcone de arrastar nÃ£o pressionado

(b) Ãcone de arrastar pressionado

Figura 3.8: Ãcones de arrastar

âˆ™ Modificar as conexÃµes de entrada e saÃ­da ao clicar nos Ã­cones de troca de conexÃµes.

Figura 3.9: Ãcone de trocas de conexÃµes

Figura 3.10: Exemplos de conexÃµes alteradas

âˆ™ Verificar qual a posiÃ§Ã£o do espaÃ§o de aÃ§Ã£o na sequÃªncia de operaÃ§Ãµes.

Figura 3.11: PosiÃ§Ã£o na ordem de aÃ§Ãµes (1)

âˆ™ Preencher os argumentos3 necessÃ¡rios para os diferentes comandos
3Ã‰

um valor, proveniente de uma variÃ¡vel ou de uma expressÃ£o mais complexa, que pode ser passado
para um comando (sub-rotina). Um comando utiliza os valores atribuÃ­dos aos parÃ¢metros para alterar o seu
comportamento em tempo de execuÃ§Ã£o.

18
3 | O JOGO

Figura 3.12: EspaÃ§o para Argumentos

âˆ™ Posicionar o comando a ser utilizado no respectivo espaÃ§o de aÃ§Ã£o.

Figura 3.13: EspaÃ§o de AÃ§Ã£o com Comando Print

Note que, dentro do jogo, um espaÃ§o de aÃ§Ã£o nÃ£o pode ser movimentado caso um
comando esteja posicionado, isso faz com que o jogador tenha que completar o quebra
cabeÃ§as antes de pensar quais comandos serÃ£o utilizados.

3.2.3

InventÃ¡rio e Comandos

Um comando Ã© uma aÃ§Ã£o que processa o dado de uma forma especÃ­fica de acordo
com os argumentos que recebe, portanto todo comando possui nome e uma funÃ§Ã£o. Os
comandos do jogo estÃ£o em vermelho na imagem abaixo.

Figura 3.14: InventÃ¡rio com Comandos

Os trÃªs primeiros comandos na imagem sÃ£o de soma, subtraÃ§Ã£o e multiplicaÃ§Ã£o respectivamente. Estes comandos executam as operaÃ§Ãµes bÃ¡sicas como conhecemos e apenas a
operaÃ§Ã£o de soma funciona como operador de concatenaÃ§Ã£o caso o dado a ser processado
seja uma string.

19
3.2 | ELEMENTOS DO JOGO

O quarto comando da sequÃªncia, chamado Print, escreve na saÃ­da "Sua Resposta"o valor
do Input ou de uma variÃ¡vel do programa, dependendo de qual argumento passado.
O quinto comando da sequÃªncia, chamado Pass, serve apenas para conectar o sistema
sem executar nenhum processamento dos dados. O sexto comando da sequÃªncia, chamado
If/Else, serve como controle de fluxo do programa, ou seja, o comando recebe como argumento uma expressÃ£o, nomeada condiÃ§Ã£o, e durante a execuÃ§Ã£o o comando If/Else avalia
se tal condiÃ§Ã£o Ã© verdadeira ou falsa, executando o ramo de aÃ§Ã£o referente ao resultado da
avaliaÃ§Ã£o.

(a) AvaliaÃ§Ã£o da condiÃ§Ã£o

(b) Caminho referente a avaliaÃ§Ã£o

Figura 3.15: Processo visual para If

(a) AvaliaÃ§Ã£o da condiÃ§Ã£o

(b) Caminho referente a avaliaÃ§Ã£o

Figura 3.16: Processo visual para Else

Nos exemplos acima o input segue o caminho de cima caso ele seja maior que zero,
caso contrÃ¡rio seguirÃ¡ o caminho de baixo. Para o sistema ter esse comportamento basta
passar como argumento para o comando If/Else â€ > 0 â€.
O sÃ©timo e oitavo comandos, chamados A e B respectivamente, sÃ£o variÃ¡veis e podem
armazenar informaÃ§Ãµes do programa para serem utilizadas posteriormente. AlÃ©m disso o
jogador pode acompanhar os valores de A e B durante a execuÃ§Ã£o do programa olhando
para a regiÃ£o de Valores das VariÃ¡veis localizada no canto superior direito da tela.

20
3 | O JOGO

Figura 3.17: Valores das VariÃ¡veis

Conforme a execuÃ§Ã£o do programa estes valores serÃ£o modificados, veja na imagem
abaixo.

(a) AtribuiÃ§Ã£o do valor 42 para variÃ¡vel A

(b) MudanÃ§a na regiÃ£o de Valores das VariÃ¡veis

Figura 3.18: Processo visual para mudanÃ§a nas variÃ¡veis

Note tambÃ©m que o Input era vazio, portanto valores de variÃ¡veis podem ser valores
fixos atribuidos pelo jogador, como o exemplo acima mostra, ou podem ser dinÃ¢micos, ou
seja, o jogador pode armazenar em uma variÃ¡vel o valor corrente do Input.
O nono comando, chamado Error, nÃ£o deve ser utilizado, pois sÃ³ aparece caso haja
algum erro na obtenÃ§Ã£o dos comandos anteriores. Por conta disso o comando de erro
nÃ£o possui comportamento algum e, se tudo der certo durante o jogo, este comando nÃ£o
aparecerÃ¡ em nenhum momento.

3.2.4

Setas de Entrada e SaÃ­da

Estas setas sÃ£o as conexÃµes iniciais com a qual o jogador deve se preocupar. O programa
do jogador irÃ¡ receber os valores disponibilizados a serem processados a partir da Seta de
Entrada, portanto a primeira conexÃ£o que deve ser feita Ã© entre um espaÃ§o de aÃ§Ã£o e esta
seta. JÃ¡ a Seta de SaÃ­da serÃ¡ a Ãºltima conexÃ£o que o jogador terÃ¡ que fazer, pois o programa
sÃ³ estarÃ¡ apto a ser executado quando existir uma conexÃ£o entre a duas setas.

21
3.3 | FORMA DE JOGAR

(a) Seta de onde saem dados de Entrada

(b) Seta que recebe dados de SaÃ­da

Figura 3.19: Setas de Entrada e SaÃ­da

3.2.5

BotÃµes

Na tela de jogo constam os seguintes botÃµes cujo comportamento estÃ¡ especificado ao
lado:
âˆ™ Tela Cheia - Coloca o jogo em tela cheia.
âˆ™ Menu Principal - Retorna ao menu principal
âˆ™ Velocidade da AnimaÃ§Ã£o - Modifica a velocidade da animaÃ§Ã£o de execuÃ§Ã£o do
programa.
âˆ™ Rodar! - Inicia a execuÃ§Ã£o do programa criado caso o sistema esteja conectado e
nÃ£o haja erro na utilizaÃ§Ã£o dos comandos.
âˆ™ Reiniciar NÃ­vel - RecomeÃ§a o nÃ­vel atual.
âˆ™ PrÃ³ximo NÃ­vel - Inicia o nÃ­vel subsequente do nÃ­vel atual.

3.3

Forma de Jogar

Para conseguir completar o objetivo o jogo Phoenix Rising funciona da seguinte
forma:
O jogador deve resolver o quebra cabeÃ§as conectando os blocos da forma correta atÃ©
que a Seta de Entrada esteja conectada com a Seta de SaÃ­da.

22
3 | O JOGO

Figura 3.20: Jogo nÃ£o conectado

Figura 3.21: Jogo conectado

Desta forma o jogador deve compreender que, para criar um programa, Ã© necessÃ¡rio
pensar sobre a estrutura que o cÃ³digo terÃ¡ antes de comeÃ§ar a utilizar os comandos, pois
tentar criar um cÃ³digo apenas inserindo comandos sem pensar previamente em uma estrutura base leva a cÃ³digos confusos e que muitas vezes nÃ£o funcionam corretamente. Ã‰ claro
que para sistemas maiores as reestruturaÃ§Ãµes do modelo ocorrem com certa frequÃªncia,
porÃ©m o objetivo deste jogo Ã© apenas introduzir os conceitos bÃ¡sicos de programaÃ§Ã£o.
ApÃ³s ter o sistema conectado, o jogador deve utilizar os comandos que sÃ£o disponibilizados no inventÃ¡rio, posicionados no canto inferior esquerdo da tela de jogo.

23
3.3 | FORMA DE JOGAR

Figura 3.22: Exemplo de comandos disponÃ­veis

Depois de posicionar os comandos, o jogador deve preencher os argumentos que cada
comando recebe e entÃ£o o sistema estarÃ¡ pronto para ser executado.

Figura 3.23: Jogador preenchendo os argumentos

Agora o sistema estÃ¡ pronto para ser executado.

24
3 | O JOGO

Figura 3.24: Sistema pronto para execuÃ§Ã£o

Para iniciar o processamento dos dados de entrada, ou seja, rodar o programa, basta o
jogador clicar no botÃ£o rodar! e ficar atento Ã  animaÃ§Ã£o. No exemplo abaixo a primeira
entrada era o nÃºmero 7 e estÃ¡ sinalizada na animaÃ§Ã£o pelo nome Input:.

Figura 3.25: InÃ­cio da execuÃ§Ã£o do sistema

Agora o programa estÃ¡ rodando e o jogador pode acompanhar o que estÃ¡ acontecendo,
pois o valor do Input serÃ¡ exibido constantemente na tela. ApÃ³s passar por algum comando
o valor de Input serÃ¡ modificado de acordo com a operaÃ§Ã£o executada.

25
3.3 | FORMA DE JOGAR

Figura 3.26: Valor do Input antes da operaÃ§Ã£o

Note que apÃ³s passar pelo comando de soma, o valor de Input serÃ¡ incrementado em
1, pois foi passado como argumento "input, 1", fazendo com que seja somado 1 ao valor
corrente do Input.

Figura 3.27: Valor do Input apÃ³s a operaÃ§Ã£o

Esta maneira de conseguir acompanhar o que estÃ¡ acontecendo com os valores do
programa enquanto Ã© executada cada aÃ§Ã£o permite que o jogador entenda realmente como
cada comando funciona, facilitando o aprendizado principalmente das instruÃ§Ãµes que
controlam o fluxo de operaÃ§Ã£o e loops.

27

CapÃ­tulo 4
ImplementaÃ§Ã£o do Projeto

Agora que foram definidas as mecÃ¢nicas de jogo do ponto de vista de um jogador
e explicado que uma das intenÃ§Ãµes do projeto Ã© facilitar o aprendizado de um iniciante
em computaÃ§Ã£o Ã© preciso explicar melhor os detalhes da implementaÃ§Ã£o para concluir a
segunda intenÃ§Ã£o do projeto que Ã© permitir a extensÃ£o do jogo por alguÃ©m que jÃ¡ conheÃ§a
um pouco de programaÃ§Ã£o ou esteja interessado em modificar o cÃ³digo fonte, inserindo
novas funcionalidades.

Para isso, essa seÃ§Ã£o divide a explicaÃ§Ã£o dos arquivos do jogo agrupando por funcionalidades, assim entender o cÃ³digo de implementaÃ§Ã£o torna-se mais simples.

4.1

InventÃ¡rio

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pasta GenericGameScenes e administra os comandos disponÃ­veis e a movimentaÃ§Ã£o deles na tela.

A seguir estÃ£o imagens com os nÃ³s que compÃµem a cena, os mÃ©todos do script atrelado
ao nÃ³ raiz, chamado Inventory e as variÃ¡veis mais importantes para entender o cÃ³digo.

28
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Figura 4.1: Ãrvore da cena Inventory

Figura 4.2: FunÃ§Ãµes do script do nÃ³ Inventory

Figura 4.3: VariÃ¡veis do script do nÃ³ Inventory

O nÃ³ InventoryBase apenas dÃ¡ cor ao espaÃ§o destinado aos comandos no inÃ­cio do jogo
e o nÃ³ HelpPanel Ã© uma cena instanciada que gerencia o menu de ajuda que aparece ao
solicitar mais explicaÃ§Ãµes sobre um comando.
Dentro do jogo Phoenix Rising os comandos disponÃ­veis devem ocupar o espaÃ§o de Ã¡reas
especÃ­ficas. Estas Ã¡reas sÃ£o chamadas de recipientes (do inglÃªs container). Um recipiente
pode ser o prÃ³prio Grid do inventÃ¡rio ou espaÃ§os definidos dentro dos EspaÃ§os de AÃ§Ã£o,
que serÃ£o explicados posteriormente.
O nÃ³ Grid tem grande importÃ¢ncia dentro da cena, pois Ã© ele quem separa cada recipiente da tela de jogo em pequenos quadradinhos, facilitando a mecÃ¢nica de mover os
comandos disponÃ­veis. Estes recipientes sÃ£o adicionados na lista de containers, definida na
linha 11 da figura 4.3.
Para facilitar o entendimento, veja as variÃ¡veis mais importantes e o mÃ©todo de inicializaÃ§Ã£o da grade (do inglÃªs grid):

29
4.1 | INVENTÃRIO

Figura 4.4: VariÃ¡veis do Grid
Figura 4.5: inicializaÃ§Ã£o do Grid

O tamanho de cada quadrado Ã© armazenado e definido na linha 8 do cÃ³digo mostrado
na figura 4.4 e as medidas da grade sÃ£o armazenadas pelas variÃ¡veis definidas nas linhas
10 e 11 da mesma figura.

Na inicializaÃ§Ã£o da grade do inventÃ¡rio o mÃ©todo get_grid_size recebe o retÃ¢ngulo que
foi definido para ser o recipiente e devolve seu tamanho (largura e altura) usando o sistema
quadriculado, ou seja, devolve quantos quadrados de largura e altura ele ocupa. Depois,
cada posiÃ§Ã£o desta grade recebe o valor "falso", sinalizando que aquele quadrado estÃ¡ vazio,
ou seja, que nenhum item do jogo ocupa aquelas posiÃ§Ãµes.

A partir dessa divisÃ£o todo comando que Ã© disponibilizado no inventÃ¡rio ocuparÃ¡ um
nÃºmero de quadrados do grid e a movimentaÃ§Ã£o destes itens Ã© feita pelos mÃ©todos de
pegar (do inglÃªs grab) e soltar (do inglÃªs release) definidos no scripts do nÃ³ Inventory. Ao
posicionar um comando em alguma regiÃ£o do recipiente os quadrados sÃ£o marcados com
"verdadeiro"para sinalizar que aquela regiÃ£o estÃ¡ preenchida.

Figura 4.6: MÃ©todo de inserÃ§Ã£o de um item

30
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Figura 4.7: MarcaÃ§Ã£o das posiÃ§Ãµes do grid

4.2

EspaÃ§o de AÃ§Ã£o

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pasta ActionSpace. O espaÃ§o de aÃ§Ã£o serve para conectar o sistema fazendo com que seja possÃ­vel
executÃ¡-lo e posicionar os comandos que serÃ£o utilizados no programa criado pelo jogador.
Basicamente o espaÃ§o de aÃ§Ã£o Ã© divido em duas partes, uma mÃ³vel e outra fixa. A cena
MovableActionSpace Ã© a parte que permite a mobilidade e a cena ActionSpace cuida de
receber o item posicionado e os argumentos.

Figura 4.8: Cena MovableActionSpace

Figura 4.9: Cena ActionSpace

Note que, como MovableActionSpace Ã© mÃ³vel, foi utilizado um nÃ³ do tipo Node2D e
como ActionSpace Ã© fixo, foi utilizado um nÃ³ do tipo Control.
A cena MovableActionSpace Ã© formada pelos seguintes nÃ³s:

31
4.2 | ESPAÃ‡O DE AÃ‡ÃƒO

âˆ™ ActionSpace - Cena que trata dos comandos e argumentos que sÃ£o posicionados
para a execuÃ§Ã£o.
âˆ™ ClickDragArea - Ãrea com o Ã­cone da mÃ£ozinha, destinada a mover o espaÃ§o de
aÃ§Ã£o pela tela.
âˆ™ InputArea - ConexÃµes simples de input.
âˆ™ OutputArea - ConexÃµes simples de output.
âˆ™ IfArea - ConexÃ£o complexa para administrar o comando if/else.
âˆ™ ConvergeArea ConexÃ£o complexa para unir os dois caminhos gerados a partir de
um if/else.
âˆ™ ActionNumber - Indica qual a posiÃ§Ã£o na ordem de processamento.
âˆ™ OutputChangeButton - Ãrea que permite a troca da conexÃ£o de saÃ­da (output)
âˆ™ InputChangeButton - Ãrea que permite a troca da conexÃ£o de entrada (input)
âˆ™ ChangeArea - Ãrea que marca em qual momento serÃ¡ feita a troca do valor input
definido no processo visual.
O script atrelado ao nÃ³ MovableActionSpace torna possÃ­vel os comportamentos descritos
acima. Os detalhes de como isso Ã© feito nÃ£o sÃ£o relevantes neste momento, por isso nÃ£o
haverÃ¡ explicaÃ§Ã£o detalhada sobre o cÃ³digo, entretanto os curiosos que quiserem adicionar
uma nova conexÃ£o simples de input devem seguir os passos:
âˆ™ Seguindo o padrÃ£o de nomenclatura, criar um nÃ³ sprite chamado NewConnection e
um nÃ³ de forma de colisÃ£o (CollisionShape2D) chamado NewCollisionShape, filhos de
InputArea.
âˆ™ Definir a forma de colisÃ£o do nÃ³ NewCollisionShape.
âˆ™ Abrir o script MovableActionSpace.gd e adicionar na lista input_connections o nome
do nÃ³ sprite que foi criado, seguindo o exemplo:
$ğ¼ ğ‘›ğ‘ğ‘¢ğ‘¡ğ´ğ‘Ÿğ‘’ğ‘/ğ‘ ğ‘’ğ‘¤ğ¶ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡ğ‘–ğ‘œğ‘›
âˆ™ Ainda no script MovableActionSpace.gd, adicionar na lista input_collisions uma lista
contendo o nome do nÃ³ CollisionShape2D que foi criado, seguindo o exemplo:
[$ğ¼ ğ‘›ğ‘ğ‘¢ğ‘¡ğ´ğ‘Ÿğ‘’ğ‘/ğ‘ ğ‘’ğ‘¤ğ¶ğ‘œğ‘™ğ‘™ğ‘–ğ‘ ğ‘–ğ‘œğ‘›ğ‘†â„ğ‘ğ‘ğ‘’]
âˆ™ Adicionar na lista input_connected_textures o caminho no qual estÃ¡ a imagem referente a nova conexÃ£o quando conectada. O DEFAULT_PATH estÃ¡ definido como
"res://Accessories/art/", se a imagem estiver neste diretÃ³rio basta adicionar:
ğ·ğ¸ğ¹ğ´ğ‘ˆ ğ¿ğ‘‡ _ğ‘ƒğ´ğ‘‡ ğ» + â€²â€² ğ‘šğ‘–ğ‘›â„ğ‘_ğ‘›ğ‘œğ‘£ğ‘_ğ‘ğ‘œğ‘›ğ‘’ğ‘¥ğ‘ğ‘œ.ğ‘ğ‘›ğ‘” â€²â€²
âˆ™ Adicionar na lista input_not_connected_textures o caminho no qual estÃ¡ a imagem

32
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

referente a nova conexÃ£o quando nÃ£o conectada. O DEFAULT_PATH estÃ¡ definido
como "res://Accessories/art/", se a imagem estiver neste diretÃ³rio basta adicionar:
ğ·ğ¸ğ¹ğ´ğ‘ˆ ğ¿ğ‘‡ _ğ‘ƒğ´ğ‘‡ ğ» + â€²â€² ğ‘šğ‘–ğ‘›â„ğ‘_ğ‘›ğ‘œğ‘£ğ‘_ğ‘ğ‘œğ‘›ğ‘’ğ‘¥ğ‘ğ‘œ_ğ‘›ğ‘ğ‘œ_ğ‘ğ‘œğ‘›ğ‘’ğ‘ğ‘¡ğ‘ğ‘‘ğ‘.ğ‘ğ‘›ğ‘” â€²â€²
âˆ™ Por Ãºltimo basta incrementar o nÃºmero total de conexÃµes da variÃ¡vel
num_input_connections e pronto.
Esta sequÃªncia de aÃ§Ãµes pode ser utilizada para criar conexÃµes de saÃ­da; basta preencher
as respectivas listas que controlam as conexÃµes de output.
O motivo das conexÃµes serem tÃ£o importantes para este elemento do jogo vai alÃ©m de
sÃ³ conectar o sistema e permitir sua execuÃ§Ã£o, pois cada espaÃ§o de aÃ§Ã£o possui tambÃ©m
duas variÃ¡veis chamadas right_child e left_child que fazem referÃªncia a qual outro espaÃ§o
de aÃ§Ã£o estÃ¡ conectado a sua conexÃ£o de saÃ­da, criando a Ã¡rvore de execuÃ§Ã£o, utilizada
pelo RunEnvironment e VisualProcess.
A Ã¡rvore de execuÃ§Ã£o permite obter a sequÃªncia de aÃ§Ãµes que o jogador projetou no
nÃ­vel, alÃ©m disso esta estrutura facilita o comando condicional (if/else), o comando de loop
e outros comandos que podem ser implementados como subrotinas.
Depois que o sistema estÃ¡ totalmente conectado, podemos criar um esquema da Ã¡rvore
de execuÃ§Ã£o a partir de um sistema gerador da seguinte forma:

Figura 4.10: Sistema gerador da Ãrvore de ExecuÃ§Ã£o

Figura 4.11: Esquema de Ãrvore de ExecuÃ§Ã£o

Vale ressaltar trÃªs pontos importantes:

33
4.3 | PROCESSO VISUAL

âˆ™ A conexÃ£o entre a Entrada e o primeiro espaÃ§o de aÃ§Ã£o Ã© apenas simbÃ³lica, pois a
Entrada nÃ£o possui variÃ¡veis right_child e left_child. Foi escolhida esta representaÃ§Ã£o de imagem para facilitar o entendimento do leitor que a Ã¡rvore de execuÃ§Ã£o
representa o sistema do jogo, embora dentro do cÃ³digo nÃ£o exista a conexÃ£o entre a
Entrada e o primeiro espaÃ§o de aÃ§Ã£o.
âˆ™ Os filhos da esquerda, conhecidos como left_child, que nÃ£o foram representados no
esquema, para melhorar a apresentaÃ§Ã£o e deixÃ¡-lo mais fÃ¡cil de entender, existem e
possuem o valor null.
âˆ™ A numeraÃ§Ã£o do sistema refere-se a ordem que os comandos serÃ£o executados, jÃ¡ a
numeraÃ§Ã£o do esquema enumera apenas a quantidade de espaÃ§os de aÃ§Ã£o que foram
utilizados, portanto as numeraÃ§Ãµes podem diferir.
Agora serÃ¡ dada a exlicaÃ§Ã£o sobre a cena ActionSpace, parte fixa do espaÃ§o de aÃ§Ã£o
mostrada na figura 4.9, que Ã© composta pelos seguintes nÃ³s:
âˆ™ ActionShape - Delimita, com um retÃ¢ngulo preto, o espaÃ§o ocupado pelo espaÃ§o de
aÃ§Ã£o.
âˆ™ Name - Coloca o nome "EspaÃ§o de AÃ§Ã£o"dentro do retÃ¢ngulo preto.(O tutorial dentro
do jogo faz referÃªncias a este item.)
âˆ™ ArgumentButton - BotÃ£o que permite ao jogador abrir a Ã¡rea de preenchimento
dos argumentos que serÃ£o passados para um comando.
âˆ™ Argument - Ãrea de preenchimento dos argumentos, o que for escrito nesta Ã¡rea
serÃ¡ passado como argumento para o comando posicionado.
âˆ™ ArgumentOk - Quando pressionado fecha a Ã¡rea de preenchimento dos argumentos.
Novamente, vale lembrar que os detalhes de implementaÃ§Ã£o nÃ£o sÃ£o relevantes, basta
saber que esta cena Ã© considerada um recipiente (container) para o inventÃ¡rio e caso um comando esteja posicionado nesta regiÃ£o nÃ£o serÃ¡ possÃ­vel movimentar o MovableActionSpace
pela tela.
Uma consideraÃ§Ã£o a ser feita a respeito dos argumentos serem preenchidos utilizando o
teclado Ã© que um menu de seleÃ§Ã£o com o mouse limitaria as opÃ§Ãµes do jogador, sendo assim
ele poderia testar todas as opÃ§Ãµes disponÃ­veis atÃ© que uma delas funcionasse, indo contra
o objetivo do jogo que Ã© ensinar e nÃ£o apenas terminÃ¡-lo. ForÃ§ar o usuÃ¡rio a escrever o
argumento com o formato pedido faz com que ele se acostume a ler o menu de ajuda ou as
mensagens de erro e seguir os padrÃµes que a computaÃ§Ã£o exige, forÃ§ando-o a estar ciente
do que estÃ¡ fazendo e concluindo o objetivo principal que Ã© facilitar o aprendizado.

4.3

Processo Visual

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pasta VisualProcess. Este processo visual trata da animaÃ§Ã£o que auxilia o jogador a entender o que estÃ¡
acontecendo com os valores do programa durante a execuÃ§Ã£o.

34
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Figura 4.12: Cena Visual Process

âˆ™ Path - NÃ³ que contÃ©m a curva de pontos a ser seguida pela parte visual que aparece
na tela.
âˆ™ PathFollow2D - Trata dos pontos da curva a ser seguida.
âˆ™ Title - Texto de identificaÃ§Ã£o de qual variÃ¡vel a parte visual estÃ¡ mostrando na tela.
(neste projeto apenas Ã© mostrado o valor do Input)
âˆ™ Value - Valor corrente da variÃ¡vel mostrada pelo processo visual que Ã© identificada
pelo Title.
âˆ™ VisualProcessArea - Ãrea definida para se efetuar a mudanÃ§a dos valores em Value,
administra alguns parÃ¢metros da colisÃ£o.
âˆ™ VisualProcessCollision - Ãrea de colisÃ£o (utilizada pela Godot) definida para identificar o momento de se efetuar a mudanÃ§a dos valores em Value.
âˆ™ VisualSpeed - Menu que controla a velocidade que a animaÃ§Ã£o do processo visual
serÃ¡ mostrada.
Para entender melhor o processo visual deve-se compreender o bÃ¡sico sobre o funcionamento dos nÃ³s Path 1 e PathFollow2D2 na Godot. O nÃ³ Path espera receber uma curva de
pontos, jÃ¡ PathFollow2D pega seu Path pai e devolve as coordenadas de um ponto dentro
dele, dada a distÃ¢ncia do primeiro vÃ©rtice, sendo Ãºtil para fazer outros nÃ³s seguirem um
caminho, sem codificar o padrÃ£o de movimento. Para isso, os nÃ³s devem ser descendentes
desse nÃ³. Em seguida, ao definir um deslocamento neste nÃ³, os nÃ³s descendentes se moverÃ£o
de acordo.
Seguindo o funcionamento de Path e PathFollow2D ao instanciar Title, Value e VisualProcessArea como filhos de PathFollow2D todos eles irÃ£o seguir o caminho da curva
1 https://docs.godotengine.org/en/3.1/classes/class_path.html
2 https://docs.godotengine.org/en/3.1/classes/

class_pathfollow.html#class-pathfollow

35
4.3 | PROCESSO VISUAL

definida, o que permite movimentar o valor do Input pela tela de jogo. Veja abaixo algumas
variÃ¡veis que sÃ£o utilizadas no controle deste processo:

Figura 4.13: VariÃ¡veis Visual Process

âˆ™ starting_pos e finish_pos - demarcam onde o processo visual inicia e onde ele
termina, respectivamente.
âˆ™ start_input - recebe o valor inicial da entrada.
âˆ™ curve - guarda a curva de pontos, que serÃ¡ preenchida conforme a execuÃ§Ã£o do
programa.
âˆ™ total_inputs - guarda a quantidade de valores que foi fornecido na entrada do
programa
âˆ™ current_start_input - guarda qual valor da entrada que serÃ¡ processado.
âˆ™ processed_input - armazena os valores que se alteram durante a execuÃ§Ã£o e que
sÃ£o exibidos na animaÃ§Ã£o.
âˆ™ CurrentActionNode - guarda qual espaÃ§o de aÃ§Ã£o que serÃ¡ executado
âˆ™ is_exit_sucess - sinaliza se houve algum erro durante a execuÃ§Ã£o.
A funÃ§Ã£o que possibilita o processo visual executar as modificaÃ§Ãµes no input e seguir
um caminho na tela Ã© a _on_MovableActionSpace_change_area_entered definida no script do
nÃ³ VisualProcess. Esta funÃ§Ã£o Ã© chamada sempre que hÃ¡ colisÃ£o entre VisualProcessCollision
e ChangeArea, que estÃ¡ definido no espaÃ§o de aÃ§Ã£o.
Veja abaixo o cÃ³digo:

36
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Figura 4.14: FunÃ§Ã£o _on_MoveableActionSpace_change_area_entered

Note que a funÃ§Ã£o _on_MovableActionSpace_change_area_entered Ã© chamada sempre
que Ã© detectada uma colisÃ£o entre um espaÃ§o de aÃ§Ã£o e o input, portanto a variÃ¡vel CurrentActionNode estÃ¡ armazenando uma referÃªncia para o espaÃ§o de aÃ§Ã£o que colidiu.
Iniciando a funÃ§Ã£o, na linha 64, Ã© executado o cÃ³digo do comando que estÃ¡ posicionado
dentro do espaÃ§o de aÃ§Ã£o e o novo input que foi processado bem como qual o caminho a
seguir, serÃ£o armazenados na lista processed_input.
A lista processed_input guarda, na primeira posiÃ§Ã£o (0), o valor resultante da operaÃ§Ã£o
do comando posicionado e terÃ¡ null caso algo tenha dado errado, por exemplo um erro
na passagem do argumento. O if, na linha 66, verifica se algo deu errado na execuÃ§Ã£o
do comando. Caso nada de errado tenha acontecido Ã© executado o else, na linha 70, que
identificarÃ¡ qual serÃ¡ o caminho que o processo visual deverÃ¡ tomar.
A lista processed_input guarda, na segunda posiÃ§Ã£o (1), qual o caminho que deverÃ¡ ser
seguido, caso a posiÃ§Ã£o esteja marcada com true, entÃ£o serÃ¡ seguido o caminho do filho da
direita, se o valor for false, entÃ£o serÃ¡ seguido o caminho do filho da esquerda. Para entender
esta parte talvez seja necessÃ¡rio relembrar o que significam estes "caminhos"observando
novamente a figura 4.11: Esquema de Ãrvore de ExecuÃ§Ã£o, definida na seÃ§Ã£o "EspaÃ§o de
AÃ§Ã£o".
Depois hÃ¡ a verificaÃ§Ã£o se o processo visual chegou ao fim, na linha 75, ou se hÃ¡ mais
algum ponto a seguir, na linha 77-78. Por fim, na linha 79, atualiza-se o texto que aparece
na tela para o jogador visualizar.
Note que a execuÃ§Ã£o dos comandos acontece enquanto o processo visual Ã© mostrado
na tela, assim o jogador pode acompanhar o andamento do seu programa atÃ© que algo
de errado aconteÃ§a, facilitando o entendimento de cada comando individualmente e a
correÃ§ao dos erros que aparecerem.

37
4.4 | AMBIENTE DE EXECUÃ‡ÃƒO

4.4

Ambiente de ExecuÃ§Ã£o

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pasta RunEnvironment. Este ambiente trata de construir o arcabouÃ§o para executar o sistema.
As imagens abaixo ilustram os nÃ³s que compÃµem a cena principal, chamada RunEnvironment.tscn e as funÃ§Ãµes que estÃ£o definidas no script RunEnvironment.gd atrelado ao nÃ³
principal.

Figura 4.15: Ãrvore da cena RunEnvironment

Figura 4.16: FunÃ§Ãµes de RunEnvironment.gd

âˆ™ RunButton - BotÃ£o que, ao ser pressionado, faz com que inicie uma tenteativa de
executar o sistema.
âˆ™ RunScript - Carrega o script RunScript.gd, neste script estÃ£o as funÃ§Ãµes de comportamento dos comandos.
âˆ™ ErrorMessages - EspaÃ§o definido para a mensagem de erro.
âˆ™ ColorRect - DÃ¡ cor ao espaÃ§o destinado as mensagens de erro.
âˆ™ Message - Texto da mensagem de erro.
âˆ™ Understood - BotÃ£o que permite fechar a mensagem de erro e dar sequÃªncia ao
jogo.
âˆ™ VariablesMap - Carrega o script VariablesMap.gd, neste script estÃ£o as funÃ§Ãµes que

38
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

dÃ£o comportamento ao mapa de variÃ¡veis.
âˆ™ VariablesMapTitle - TÃ­tulo do mapa de variÃ¡veis.
âˆ™ VariablesMapBox - Textura destinada ao mapa de variÃ¡veis.
âˆ™ VariablesMapTextA - Texto da valoraÃ§Ã£o da variÃ¡vel A.
âˆ™ VariablesMapTextB - Texto da valoraÃ§Ã£o da variÃ¡vel B.
Depois de definir algumas variÃ¡veis como o texto do mapa de variÃ¡veis e qual a
saÃ­da esperada, esta cena estarÃ¡ pronta para exercer seu papel mais importante: Iniciar a
tentativa de execuÃ§Ã£o do sistema.
Inicialmente serÃ¡ apenas uma tentativa, pois o sistema pode nÃ£o estar devidamente
conectado, impedindo o inÃ­cio da execuÃ§Ã£o ou algum comando pode resultar em erro,
interrompendo a execuÃ§Ã£o. A ocorrÃªncia de ambas as opÃ§Ãµes serÃ¡ explicada a seguir.
Note a funÃ§Ã£o que Ã© chamada assim que o botÃ£o Rodar!, definido pelo nÃ³ RunButton,
Ã© pressionado.

Figura 4.17: FunÃ§Ã£o do botÃ£o Rodar!

O sinal emitido na linha 109 serve para armazenar a pontuaÃ§Ã£o no momento em que
o botÃ£o Ã© pressionado, assim o jogador ganha os pontos independentemente de quanto
tempo a animaÃ§Ã£o durou. As linhas 110 a 112 limpam o que estava escrito anteriormente
na saÃ­da do jogador e no mapa de variÃ¡veis, para iniciar a nova execuÃ§Ã£o.
A verificaÃ§Ã£o se o sistema estÃ¡ conectado Ã© feita pela funÃ§Ã£o _is_system_connected que
recebe a raÃ­z da Ã¡rvore de execuÃ§Ã£o e verifica se para todos os espaÃ§os de aÃ§Ã£o que fazem
parte do sistema existe um caminho que o liga com a saÃ­da, sendo que nÃ£o Ã© vÃ¡lido passar
mais de uma vez pela mesma conexÃ£o.
Veja as figuras abaixo que ilustram um sistema nÃ£o conectado.

39
4.4 | AMBIENTE DE EXECUÃ‡ÃƒO

Figura 4.18: Sistema gerador da Ãrvore de ExecuÃ§Ã£o nÃ£o Conectada

Figura 4.19: Esquema de Ãrvore de ExecuÃ§Ã£o nÃ£o Conectada

Note que o espaÃ§o de aÃ§Ã£o 4 faz parte do sistema, pois existe a conexÃ£o (caminho) entre
a entrada e ele, porÃ©m nÃ£o estÃ¡ conectado com a saÃ­da, pois nÃ£o existe um caminho que o
ligue com a saÃ­da sem repetir uma conexÃ£o. Note tambÃ©m que o espaÃ§o de aÃ§Ã£o 6 nÃ£o faz
parte do sistema, uma vez que nÃ£o existe conexÃ£o entre ele e a entrada, portanto nÃ£o Ã©
necessÃ¡rio que ele esteja conectado com a saÃ­da.
Caso seja possÃ­vel executar o sistema a funÃ§Ã£o que faz o processamento do input serÃ¡
chamada. Veja abaixo:

Figura 4.20: FunÃ§Ã£o _process_input

Primeiro deve-se encontrar em qual espaÃ§o de aÃ§Ã£o a Ã¡rvore de execuÃ§Ã£o se inicia (linha 72), depois monta-se a Ã¡rvore de execuÃ§Ã£o completa (linha 73), por fim a
funÃ§Ã£o irÃ¡ repetir os comandos das linhas 75 a 78 para cada valor definido no input.

40
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Para processÃ¡-los a linha 75 emite o sinal visual_process_arguments para o processo
visual, no script do processo visual a funÃ§Ã£o chamada por este sinal recÃ©m enviado,
_on_RunEnvironment_visual_process_arguments, preenche os pontos na curva referentes
aos espaÃ§os de aÃ§Ã£o que estÃ£o na Ã¡rvore de execuÃ§Ã£o e inicia a animaÃ§Ã£o que aparece na
tela.
Depois de iniciada a animaÃ§Ã£o o processo visual irÃ¡ tratar de executar os scripts
referentes aos comandos que foram posicionados. Enquanto isso a funÃ§Ã£o _process_input
estarÃ¡ esperando que o processo visual envie o sinal end_path, marcando o fim do processo
visual, para prosseguir sua execuÃ§Ã£o.
Depois de receber o sinal, a funÃ§Ã£o _process_input irÃ¡ verificar se o sistema foi executado
sem erros ou nÃ£o e devolver true caso o sistema tenha sido executado com sucesso ou false
caso contrÃ¡rio.
Este valor devolvido por _process_input serÃ¡ armazenado na variÃ¡vel was_sucessfull,
localizada na linha 114 da funÃ§Ã£o _on_RunButton_pressed, servindo como verificaÃ§Ã£o se
o sistema foi executado com sucesso ou nÃ£o. Caso o sistema tenha sido executado com
sucesso a rotina _sucess_routine serÃ¡ chamada, adicionando os pontos para o jogador,
fazendo o retÃ¢ngulo de saÃ­da piscar em verde e mostrando o botÃ£o que permite ao jogador
ir para o prÃ³ximo nÃ­vel. Caso o sistema nÃ£o tenha sido executado com sucesso a rotina
_failure_routine serÃ¡ executada, piscando o retÃ¢ngulo de saÃ­da em vermelho.
Portanto, sempre que o botÃ£o Rodar! Ã© pressionado estas subrotinas serÃ£o chamadas e
tentarÃ£o executar o sistema.

4.5

Comandos do Jogo

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) a declaraÃ§Ã£o de quais comandos
serÃ£o disponÃ­veis Ã© encontrada na pasta GenericGameScenes no script ItemDB.gd, jÃ¡ os
comportamentos de cada comando estÃ£o no script RunScript.gd localizado dentro da pasta
RunEnvironment.
Para entender como foi estruturado o gerenciamento dos comandos do jogo Ã© importante saber que o script ItemDB.gd Ã© um singleton e Ã© carregado antes mesmo que a cena
atual se inicie, portanto todas as cenas do jogo podem acessar o conteÃºdo definido nele.
AlÃ©m disso a declaraÃ§Ã£o de cada comando, feita em ItemDB.gd, deve conter informaÃ§Ãµes
importantes a respeito dele, estas informaÃ§Ãµes sÃ£o:
âˆ™ Caminho do Ã­cone referente ao comando, para que as cenas o renderizem na tela.
âˆ™ Texto de ajuda para ser exibido na tela, caso o jogador solicite.
âˆ™ Nome da funÃ§Ã£o que implementa o comportamento do comando.
Abaixo estÃ¡ ilustrado uma parte das declaraÃ§Ãµes dos comandos. Note que cada comando
possui todas as informaÃ§Ãµes importantes citadas acima.

41
4.5 | COMANDOS DO JOGO

Figura 4.21: Parte do Script de DeclaraÃ§Ã£o dos Comandos

Para o melhor entendimento desta parte Ã© importante saber um pouco sobre o que Ã©
um dicionÃ¡rio. Basicamente um dicionÃ¡rio Ã© uma forma de estruturar os dados em que
um elemento Ã© chamado de chave e o outro elemento Ã© chamado de valor. Nele as chaves
sÃ£o Ãºnicas e os valores podem se repetir, estes dois elementos formam um par e ficam
atrelados, sendo assim Ã© fÃ¡cil obter o valor associado a uma chave apenas utilizando o
elemento chave. O necessÃ¡rio para esta seÃ§Ã£o Ã© entender que, em um dicionÃ¡rio, podemos
utilizar o elemento chave para obter facilmente o elemento valor associado.
Na imagem acima a variÃ¡vel ITEMS declarada na linha 4 Ã© um dicionÃ¡rio e irÃ¡ armazenar
todos os nomes dos comandos, portanto a chave no dicionÃ¡rio ITEMS serÃ¡ a string que
identifica o comando e o valor desta chave serÃ¡ outro dicionÃ¡rio que armazena as informaÃ§Ãµes referentes ao comando em questÃ£o. Desta forma Ã© possÃ­vel acessar facilmente todas
as informaÃ§Ãµes importantes de um comando apenas sabendo a string de seu nome.
Para recuperar as informaÃ§Ãµes importantes de um comando especÃ­fico Ã© utilizado o
mesmo conceito de chave e valor, porÃ©m as chaves serÃ£o: icon, help e funcName.
A Ãºnica funÃ§Ã£o que estÃ¡ declarada neste script chama get_item, ela recebe o identificador
do comando, que no caso serÃ¡ o nome dele, e devolverÃ¡ o dicionÃ¡rio que contÃ©m as
informaÃ§Ãµes importantes dele. Foi criado um comando chamado "error"que serÃ¡ devolvido
pela funÃ§Ã£o get_item caso o elemento procurado nÃ£o exista, evitando assim que o programa
quebre em situaÃ§Ãµes que algo deu errado.

42
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Figura 4.22: FunÃ§Ã£o get_item

Agora que os conceitos sobre como os comandos sÃ£o declarados foram explicados Ã©
possÃ­vel entender como o resto do programa utiliza o que foi definido.
Todos os nÃ­veis possuem um script atrelado ao nÃ³ principal da cena, neste script exite
uma variÃ¡vel chamada pickup_item_list que serve para armazenar quais os comandos que
serÃ£o disponÃ­veis em tal nÃ­vel. No exemplo abaixo estarÃ£o disponÃ­veis os comandos de
subtraÃ§Ã£o e de print.

Figura 4.23: Exemplo de pickup_item_list

Esta lista de itens Ã© passada para o script do nÃ³ Inventory que utilizarÃ¡ a funÃ§Ã£o
pickup_item para colocar cada comando na Ã¡rea de comandos e fazÃª-lo aparecer na tela,
note que foi utilizado a chave icon.

Figura 4.24: FunÃ§Ã£o pickup_item

Depois disso o comando estarÃ¡ disponÃ­vel para ser utilizado, sua mensagem de ajuda,
chamada help, serÃ¡ exibida sempre que o jogador clicar, com o botÃ£o direito do mouse,
sobre ele ou quando houver algum erro durante a execuÃ§Ã£o do programa devido a sua mÃ¡
utilizaÃ§Ã£o.

43
4.6 | AJUDA AO USUÃRIO

A Ãºltima informaÃ§Ã£o importante de um comando Ã© chamada funcName e guarda o nome
da funÃ§Ã£o que implementa o comportamento dele. Os comportamentos dos comandos
estÃ£o definidos em RunScript.gd e sÃ£o utilizados durante a execuÃ§Ã£o do programa que foi
criado.
Quando o jogador tenta executar o programa que foi criado a funÃ§Ã£o _process_input
chama _build_function_tree que cria uma Ã¡rvore com referÃªncias para os mÃ©todos que
definem o comportamento de cada item, nesta parte Ã© utilizado o valor em funcName. ConstruÃ­da a Ã¡rvore, ela serÃ¡ utilizada pelo visual_process enquanto a animaÃ§Ã£o for mostrada
na tela. Desta forma Ã© possÃ­vel executar a funÃ§Ã£o correspondente ao comando durante o
processo de execuÃ§Ã£o.
Um usuÃ¡rio que queira criar um novo comando sÃ³ precisarÃ¡ preencher corretamente o
arquivo ItemDB.gd seguindo o modelo e implementar o comportamento do comando em
RunScript.gd.

4.6

Ajuda ao UsuÃ¡rio

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pastas UsersGuide e em GenericGameScenes.
Estas cenas formam o conjunto de ajuda ao usuÃ¡rio. Nelas estÃ¡ definido a caixa de
diÃ¡logo, utilizada para guiar o usuÃ¡rio nos primeiros nÃ­veis e o painel de ajuda que aparece
na tela quando o jogador solicita mais informaÃ§Ãµes sobre um determinado comando.
A caixa de diÃ¡logo exibe mensagens no inÃ­cio do nÃ­vel dando uma sequÃªncia de instruÃ§Ãµes para que o jogador consiga completar o nÃ­vel mais facilmente. Ã‰ claro que nem
sempre essas mensagens irÃ£o guiar totalmente o jogador, deixando o desafio totalmente
nas mÃ£os dele.
Abaixo estÃ¡ um exemplo de mensagem da caixa de diÃ¡logo. Esta Ã© uma mensagem
que aparece bem no inÃ­cio do jogo e estÃ¡ ensinando o jogador como fazer para que seja
possÃ­vel rodar o programa criado.

Figura 4.25: Exemplo de mensagem da caixa de diÃ¡logo

O painel de ajuda aparece ao clicar, com o botÃ£o direito, sobre o comando que deseja
obter as informaÃ§Ãµes de ajuda. Nele o jogador pode conferir o que o comando faz, quais
argumentos que ele deve receber e seu modo de utilizaÃ§Ã£o.

44
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Figura 4.26: Exemplo de painel de ajuda

Como as mensagens da caixa de diÃ¡logo devem ser personalizadas para cada desafio,
existe uma cena no diretÃ³rio UsersGuide chamada UsersGuide.tscn que pode ser instanciada
em cada nÃ­vel. Neste mesmo diretÃ³rio existe um script chamado UsersGuide.gd que Ã© um
modelo para criar as mensagens de guia. Portanto, para personalizar as mensagens basta
instanciar a cena UsersGuide.tscn no nÃ­vel desejado e atrelar a ela um novo script, seguindo
o modelo em UsersGuide.gd. Por padrÃ£o o nome do novo script Ã© sempre o nome do nÃ­vel
concatenado com a palavra "Guide", ou seja, se o nÃ­vel chama "NivelX"o nome do script
serÃ¡ NivelXGuide.gd.
A personalizaÃ§Ã£o do painel de ajuda para cada comando Ã© feita preenchendo o campo
help ao criÃ¡-lo no ItemDB.gd.

4.7

Gamification

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pasta Gamification. Essa pasta contÃ©m as cenas e scripts que gerenciam a transformaÃ§Ã£o da plataforma
de ensino em um jogo, ou seja, gerenciam o processo de gamificaÃ§Ã£o.
Cada nÃ­vel possui um nÃ³ Gamification que irÃ¡ gerenciar o sistema de pontuaÃ§Ã£o do
jogador alÃ©m de controlar se o jogador jÃ¡ terminou aquele nÃ­vel alguma vez durante a
sessÃ£o de jogo.
Foi implementado apenas a gamificaÃ§Ã£o bÃ¡sica, isto Ã©, em Phoenix Rising existe apenas
o sistema de pontuaÃ§Ã£o. Entretanto melhorias podem ser feitas como bÃ´nus por nÃºmero
total de tentativas, troca de pontos por dicas em nÃ­veis difÃ­ceis, entre outros chamativos
que um jogo pode proporcionar. Adicionar novas caracterÃ­sticas de jogo seria um inÃ­cio
interessante para quem gostaria de aprender programaÃ§Ã£o alterando cÃ³digo, pois alÃ©m da
criatividade, Ã© necessÃ¡rio dominar certas estruturas de dados.

45
4.8 | NÃVEL BASE

4.8

NÃ­vel Base

Dentro dos arquivos do jogo (diretÃ³rio Phoenix Rising) Ã© encontrado na pasta BaseLevel.
Dentro dessa pasta estÃ¡ um modelo de nÃ­vel para ajudar alguÃ©m que queira construir seu
prÃ³prio desafio.
A imagem abaixo ilustra os nÃ³s que compÃµem o nÃ­vel base, nela Ã© possÃ­vel entender
sobre a organizaÃ§Ã£o dos nÃ³s na criaÃ§Ã£o de um novo desafio.

Figura 4.27: Exemplo de nÃ­vel base

Para os interessados em criar um novo nÃ­vel essa cena Ã© muito Ãºtil, pois ao abri-la
utilizando a Godot Engine Ã© possÃ­vel clicar em cada nÃ³ para ver o destino de cada sinal que
Ã© emitido por ele e qual a funÃ§Ã£o que trata o recebimento de tal sinal.

46
4 | IMPLEMENTAÃ‡ÃƒO DO PROJETO

Como as cenas mais importantes do jogo jÃ¡ foram explicadas , neste ponto basta
entender como os sinais se conectam no nÃ­vel base, copiar o diretÃ³rio BaseLevel e renomeÃ¡lo (incluindo os arquivos dentro dele) seguindo o padrÃ£o "LevelX", depois pode-se editar o
desafio a vontade.
Para conectar o novo nÃ­vel Ã  sequÃªncia de jogo deve-se utilizar a funÃ§Ã£o
_on_NextLevel_next_level definida em cada script atrelado ao nÃ³ principal do nÃ­vel.
Se quiser adicionar o nÃ­vel na tela de seleÃ§Ã£o Ã© sÃ³ checar o diretÃ³rio LevelSelection e seguir
os modelos.

47

CapÃ­tulo 5
ConsideraÃ§Ãµes Finais
Neste capÃ­tulo estarÃ£o descritas as dificuldades enfrentadas durante a criaÃ§Ã£o do projeto
e algumas ideias para futuras implementaÃ§Ãµes.

5.1

UsuÃ¡rios e o Tutorial

Inicialmente o jogo contava com apenas um nÃ­vel de tutorial, os demais nÃ­veis eram
desafios em que o jogador estaria sozinho. Neste Ãºnico nÃ­vel inicial eram exibidas todas
as informaÃ§Ãµes que o jogador precisaria para jogar, desde como montar o sistema atÃ© a
forma de funcionamento dos comandos. Para evitar um tutorial demasiado longo e que
dificultasse a memorizaÃ§Ã£o foi utilizada uma linguagem tÃ©cnica e concisa.
A primeira experiÃªncia com um jogador leigo foi desastrosa. A linguagem tÃ©cnica
dificultou muito o entendimento, apenas quem jÃ¡ conhecia programaÃ§Ã£o hÃ¡ algum tempo
entendia a ideia do jogo. O tamanho do tutorial tambÃ©m dificultou o entendimento, pois
era passada muita informaÃ§Ã£o de uma sÃ³ vez.
Houve a primeira refatoraÃ§Ã£o do tutorial, tentando fazer analogia entre a ideia do
jogo e a confecÃ§Ã£o de um bolo. Os comandos de ajuda de cada comando faziam referÃªncia
ao processo de criaÃ§Ã£o de um bolo, por exemplo, a soma era comparada a adicionar
ingredientes, os dados de entrada eram os ingredientes iniciais e a saÃ­da esperada era o
sabor de bolo a ser feito.
Apesar de ter melhorado um pouco do entendimento por parte de um leigo, a quantidade
de informaÃ§Ã£o em apenas um nÃ­vel de tutorial atrapalhava o entendimento e impossibilitou
que a curva de aprendizado fosse satisfatÃ³ria, para completar o Ãºnico nÃ­vel de tutorial
foram necessÃ¡rios aproximadamente 20 minutos, lendo o menu de ajuda e entendendo as
mensagens de erro.
Surgiram algumas sugestÃµes de melhorias que eram focadas em modificar as imagens
dos comando, por exemplo, mudar os nÃºmeros de entrada para imagens de ingredientes
e modificar a saÃ­da esperada para a imagem de um bolo. Apesar de parecer interessante,
jÃ¡ existem diversos jogos com esse estilo e muito difÃ­cilmente um jogador consegue

48
5 | CONSIDERAÃ‡Ã•ES FINAIS

compreender a relaÃ§Ã£o que existe entre a montagem de um sistema que confecciona um
bolo utilizando imagens e uma sequÃªncia de instruÃ§Ãµes em um cÃ³digo de computador sem
ser induzido a isso.
Como Phoenix Rising tem o objetivo de ensinar conceitos de programaÃ§Ã£o foi decidido
manter os comandos o mais prÃ³ximo do que Ã© utilizado em linguagens de alto nÃ­vel e
dados de entrada e saÃ­da que fossem compatÃ­veis com os que sÃ£o utilizados em tutoriais
que introduzem as ideias bÃ¡sicas de programaÃ§Ã£o, facilitando a relaÃ§Ã£o entre o jogo e um
script que automatiza alguma tarefa.
A segunda refatoraÃ§Ã£o, portanto, dividiu o tutorial em vÃ¡rios nÃ­veis, tentando ensinar
ao jogador uma ideia de cada vez, ou seja, o primeiro tutorial ensina a conectar o sistema,
o segundo a mudar as conexÃµes, o terceiro a utilizar o primeiro comando e assim por
diante. Foi abolida a analogia com o bolo e a linguagem, apesar de nÃ£o ser muito tÃ©cnica,
tentou nÃ£o se distanciar do que Ã© utilizado no dia a dia de quem jÃ¡ tem certa experiÃªncia
com programaÃ§Ã£o, pois conhecer os termos tÃ©cnicos e o modo matemÃ¡tico de se expressar
tambÃ©m Ã© importante no aprendizado de computaÃ§Ã£o.
ApÃ³s a segunda refatoraÃ§Ã£o o tutorial foi muito mais efetivo para um leigo (cada
indivÃ­duo leigo jogou o jogo sem nenhuma informaÃ§Ã£o prÃ©via e apenas uma vez, portanto
o aprendizado foi exclusivamente pela experiÃªncia com o tutorial), as imagens que ilustram
o que Ã© pra ser feito ajudaram bastante e tornaram Phoenix Rising jogÃ¡vel.

5.2

RefatoraÃ§Ãµes do CÃ³digo

Fazer a refatoraÃ§Ã£o Ã© muito importante para manter a qualidade do cÃ³digo e esse
processo foi repetido em diversos momentos durante a criaÃ§Ã£o do jogo. Todavia essa seÃ§Ã£o
irÃ¡ tratar de uma refatoraÃ§Ã£o especÃ­fica que mudou a estrutura do projeto e permitiu que a
animaÃ§Ã£o mostrada na tela aconteÃ§a em tempo de execuÃ§Ã£o.
No inÃ­cio da implementaÃ§Ã£o havia apenas os comandos sequenciais, ou seja, apenas
as operaÃ§Ãµes que nÃ£o geram desvio. Para tratÃ¡-las primeiro era armazenado em uma lista
todos os comandos do programa criado pelo jogador e, antes da animaÃ§Ã£o ocorrer, os dados
de entrada eram processados por cada um deles. Em outra lista era armazenado o resultado
depois da operaÃ§Ã£o de cada comando e essa lista era passada para o processo visual exibir
na tela.
Da forma que estava o jogador nÃ£o conseguia ver o momento exato do erro, jÃ¡ que
todo o programa criado era verificado antes mesmo da animaÃ§Ã£o iniciar, o que acabava
dificultando muito o aprendizado. Ao tentar criar o comando condicional a idea de criar
uma Ã¡rvore de execuÃ§Ã£o surgiu, afinal havia a necessidade de utilizar uma estrutura de
dados que permitisse mapear com facilidade as bifurcaÃ§Ãµes.
Criar a Ã¡rvore de execuÃ§Ã£o envolveu mudanÃ§as em vÃ¡rios arquivos, alÃ©m de mudanÃ§as
nos argumentos recebidos por funÃ§Ãµes. Entretando essas mudanÃ§as fizeram com que o
comando condicional pudesse existir, abriram possibilidade para inserir mais comandos
que fazem operaÃ§Ãµes nÃ£o sequenciais e facilitaram o trabalho do processo visual para
exibir a animaÃ§Ã£o durante a execuÃ§Ã£o do programa.

49
5.3 | TRABALHOS FUTUROS

Mesmo sem entrar em detalhes de como foram feitas essas modificaÃ§Ãµes para criar a
Ã¡rvore de execuÃ§Ã£o Ã© vÃ¡lido notar a importÃ¢ncia de dispor tempo para refatoraÃ§Ã£o e pensar
em melhorias para o projeto, pois sem esse momento o cÃ³digo ficaria ruim e tornaria muito
difÃ­cil a contribuiÃ§Ã£o de terceiros, alÃ©m de atrasar o prÃ³prio desenvolvimento.

5.3

Trabalhos Futuros

Phoenix Rising possui o arcabouÃ§o que permite a inserÃ§Ã£o de vÃ¡rias melhorias, como
novos comandos, novas conexÃµes e o aperfeiÃ§oamento dos aspectos de jogo (gamification).
Pelo que jÃ¡ foi explicado em capÃ­tulos anteriores a inserÃ§Ã£o de novas conexÃµes Ã© trivial,
entretanto alguns comandos seriam interessantes, as ideias gerais sobre eles sÃ£o:
âˆ™ AlocaÃ§Ã£o de memÃ³ria - Um comando como esse poderia contar com alguma imagem
que mostrasse para o jogador qual espaÃ§o que foi alocado e poderia ser feito com
base no comando "variÃ¡vel"trocando a variÃ¡vel simples por uma lista.
âˆ™ Repeat - Um comando de loop poderia ser feito utilizando o filho esquerdo do espaÃ§o
de aÃ§Ã£o e um contador de repetiÃ§Ãµes.
âˆ™ FunÃ§Ãµes - Criar um comando que permite definir uma funÃ§Ã£o Ã© mais sofisticado, mas
permitira ao jogador aprender sobre escopo.
Para criÃ¡-lo talvez seja preciso definir um novo comando em itemDB.gd, chamado
Func, que funcione como apelido para uma sequÃªncia de comandos. EntÃ£o deve-se
definir uma forma do jogador criar a sequÃªncia de comandos que corresponderÃ¡ a
Func, talvez atÃ© uma janela extra na tela de jogo (popup).
Estas ideias apenas ilustram o potencial de crescimento do jogo e os possÃ­veis caminhos
para implementar tais ideias mostram que seria factÃ­vel.
Outro ponto a ser explorado Ã© a gamificaÃ§Ã£o. No momento o jogo conta apenas com o
sistema de pontos simples, porÃ©m poderia ser implementado um sistema que permitisse
ao jogador comprar dicas para cada nÃ­vel com os pontos obtidos, melhorar a funÃ§Ã£o que
calcula a pontuaÃ§Ã£o (no momento Ã© uma funÃ§Ã£o linear) ou atÃ© mesmo criar um sistema
que permitisse compartilhar soluÃ§Ãµes entre amigos em troca de pontos, parecendo um
sistema de ajuda entre a comunidade.
O design do jogo tambÃ©m pode ser melhorado, desde a paleta de cores atÃ© o leve design,1
jÃ¡ que os quebra cabeÃ§as estÃ£o muito simples e os desafios criados nÃ£o necessitam que o
jogador utilize muitos comandos para terminÃ¡-los.

1 Level

design Ã© uma parte do desenvolvimento de jogos eletrÃ´nicos. Envolve a criaÃ§Ã£o de um nÃ­vel,
campanhas e missÃµes. Level design Ã© tambÃ©m um processo artÃ­stico e tÃ©cnico

51

CapÃ­tulo 6
ConclusÃ£o
No ponto atual, Phoenix Rising conseguiu unir uma plataforma de ensino com elementos
de jogo, tornando-se mais atrativo para pessoas que queiram encaixar o aprendizado da
programaÃ§Ã£o no dia a dia.
O jogo nÃ£o sÃ³ auxilia iniciantes em computaÃ§Ã£o a entender melhor o que estÃ¡ acontecendo com a entrada a cada comando, facilitando o aprendizado nos primeiros meses,
como tambÃ©m Ã© uma boa forma do estudante intermediÃ¡rio se familiarizar com certas
estruturas que foram utilizadas no cÃ³digo, por exemplo, Ã¡rvores, listas, dicionÃ¡rios, bem
como alguns algoritmos como busca em largura em uma Ã¡rvore.
Ã‰ importante ressaltar tambÃ©m que a continuaÃ§Ã£o do projeto foi facilitada, jÃ¡ que o
cÃ³digo foi pensado com esse propÃ³sito. Sendo assim Ã© possÃ­vel afirmar que o jogo Phoenix
Rising alcanÃ§ou o objetivo para o qual foi desenvolvido.

53

Bibliografia
https://docs.godotengine.org/en/3.1/
Lewis, M., & Jacobson, J. (2002). Game engines. Communications of the ACM, 45(1),
27.
Moratori, P. B. (2003). Por que utilizar jogos educativos no processo de ensino
aprendizagem. UFRJ. Rio de Janeiro.
Dicheva, D., Dichev, C., Agre, G., & Angelova, G. (2015). Gamification in education:
a systematic mapping study. Educational Technology & Society
Oliveira, M. D., Souza, A. D., Ferreira, A., & Barbosa, E. F. S. B. (2014). Ensino de
lÃ³gica de programaÃ§Ã£o no ensino fundamental utilizando o Scratch: um relato de
experiÃªncia. In XXXIV Congresso da SBC-XXII Workshop de Ensino de ComputaÃ§Ã£o,
BrasÄ±lia. sn
FranÃ§a, R. D., Silva, W. D., & Amaral, H. D. (2012). Ensino de ciÃªncia da computaÃ§ao
na educaÃ§ao bÃ¡sica: ExperiÃªncias, desafios e possibilidades. In XX Workshop sobre
EducaÃ§Ã£o em ComputaÃ§Ã£o (p. 4).

