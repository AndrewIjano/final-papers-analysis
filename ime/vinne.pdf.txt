Universidade de SÃ£o Paulo
Instituto de MatemÃ¡tica e EstatÃ­stica
Bacharelado em CiÃªncia da ComputaÃ§Ã£o

O Problema do Ancestral de NÃ­vel:
Uma comparaÃ§Ã£o entre implementaÃ§Ãµes

Vinicius Perche de Toledo Agostini

Monografia Final
mac 0499 â€” Trabalho de
Formatura Supervisionado

Supervisor: Prof. Dr. Carlos Eduardo Ferreira

SÃ£o Paulo
5 de dezembro de 2019

Resumo
Vinicius Perche de Toledo Agostini. O Problema do Ancestral de NÃ­vel: Uma comparaÃ§Ã£o
entre implementaÃ§Ãµes. Monografia (Bacharelado). Instituto de MatemÃ¡tica e EstatÃ­stica,
Universidade de SÃ£o Paulo, SÃ£o Paulo, 2019.

O problema do Ancestral de NÃ­vel consiste em preprocessar uma Ã¡rvore enraizada ğ‘‡ para entÃ£o
responder consultas AN(ğ‘¢, ğ‘‘), que pedem o ancestral do nÃ³ ğ‘¢ com profundidade ğ‘‘. VÃ¡rios
algoritmos com diferentes complexidades jÃ¡ foram propostos, porÃ©m existem poucos estudos
comparativos e implementaÃ§Ãµes disponÃ­veis, principalmente em portuguÃªs. Neste trabalho,
foram implementados e comparados quatro algoritmos, levando em consideraÃ§Ã£o Ã¡rvores com
diferentes formatos para analisar na prÃ¡tica o comportamento de cada um conforme o fator de
ramificaÃ§Ã£o varia, indo alÃ©m da anÃ¡lise tradicional de complexidade de tempo e espaÃ§o no pior
caso. Os resultados obtidos estÃ£o de acordo com o que era esperado pela anÃ¡lise teÃ³rica. AlÃ©m
disso, foi possÃ­vel observar que algoritmos simples podem ser implementados de maneiras que,
dependendo das caracterÃ­sticas da Ã¡rvore de entrada, pode-se obter performances suficientes,
o que leva a reforÃ§ar o quÃ£o importante Ã© conhecer a aplicaÃ§Ã£o em questÃ£o para poder tomar
a melhor decisÃ£o quanto a qual algoritmo implementar, balanceando questÃµes como uso de
memÃ³ria, dificuldade de implementaÃ§Ã£o e manutenÃ§Ã£o do cÃ³digo e eficiÃªncia.
Palavras-chave: Ancestral de NÃ­vel. Ãrvores. ImplementaÃ§Ã£o.

Abstract
Vinicius Perche de Toledo Agostini. The Level Ancestor Problem: A comparison
between implementations. Undergraduate Thesis (Bachelor). Institute of Mathematics
and Statistics, University of SÃ£o Paulo, SÃ£o Paulo, 2019.

The Level Ancestor problem consists of preprocessing a rooted tree ğ‘‡ to answer queries
AN(ğ‘¢, ğ‘‘) which request the ancestor of node ğ‘¢ with depth ğ‘‘. There have been several algorithms with different complexities proposed, however, there are few comparative studies
and implementations available, especially in portuguese. In this study, four algorithms were
implemented and tested with trees of varied shape to analyse, in practice, each algorithmâ€™s
behaviour as the branching factor changes, going beyond the traditional worst-case time and
space complexity analysis. The obtained results were consistent with what was expected from
theoretical analysis, but it allowed to observe that simple algorithms can be implemented in
such ways that, depending on the characteristics of the input tree, it can achieve sufficient
performance, reinforcing how important it is to know the actual application so that an
informed decision is made about which algorithm to implement, balancing questions such as
memory use, difficulty of code implementation and maintainability and its efficiency.

Keywords:

Level Ancestor. Trees. Implementation.

v

Lista de Figuras
1.1
1.2
1.3
1.4
1.5
1.6

A cidade de KÃ¶nigsberg e suas sete pontes . . . . . . . . .
Exemplos de grafos. . . . . . . . . . . . . . . . . . . . . . .
Exemplo de Ã¡rvore. . . . . . . . . . . . . . . . . . . . . . .
Exemplos de Ã¡rvores com fatores de ramificaÃ§Ã£o diferentes.
Exemplos de Ã¡rvores completas ou nÃ£o. . . . . . . . . . . .
Ordem de visita aos nÃ³s da Ã¡rvore durante as travessias. . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

1
2
3
4
4
5

2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9

Exemplo de consulta de Ancestral de NÃ­vel . . . . . . . . . . . .
Exemplo de consulta de Ancestral de NÃ­vel . . . . . . . . . . . .
Exemplo de consulta do Algoritmo Trivial. . . . . . . . . . . . .
Exemplo de consulta do Algoritmo Trivial. . . . . . . . . . . . .
Ãrvore exemplo. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exemplo de consulta do Algoritmo dos Ponteiros. . . . . . . . .
Exemplo de consulta do Algoritmo dos Ponteiros. . . . . . . . .
AssociaÃ§Ã£o entre os Ã­ndices originais e os Ã­ndices da prÃ©-ordem.
Exemplo de consulta do Algoritmo da PrÃ©-ordem. . . . . . . . .

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

7
7
9
9
10
12
12
13
14

3.1

Resultados para o preprocessamento de Ã¡rvores lineares com uma versÃ£o
reduzida dos testes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Resultados para o preprocessamento de Ã¡rvores lineares com os testes padrÃ£o.
Resultados para o preprocessamento de Ã¡rvores binÃ¡rias. . . . . . . . . .
Resultados para o preprocessamento de Ã¡rvores quaternÃ¡rias. . . . . . . .
Resultados para o teste reduzido de consultas em Ã¡rvores lineares. . . . .
Resultados para as consultas em Ã¡rvores binÃ¡rias. . . . . . . . . . . . . .
Resultados para as consultas em Ã¡rvores quaternÃ¡rias. . . . . . . . . . . .

3.2
3.3
3.4
3.5
3.6
3.7

.
.
.
.
.
.

.
.
.
.
.
.

18
19
20
21
22
23
24

vi

Lista de Tabelas
2.1
2.2
2.3
2.4

Tabela de resultados das consultas da Ã¡rvore da figura 2.5.
Vetores contendo os nÃ³s processados em cada nÃ­vel. . . . .
ComparaÃ§Ã£o da complexidade de tempo dos algoritmos. . .
ComparaÃ§Ã£o da complexidade de espaÃ§o dos algoritmos. .

3.1

Uso de memÃ³ria
lineares. . . . .
Uso de memÃ³ria
binÃ¡rias. . . . .
Uso de memÃ³ria
quaternÃ¡rias. . .

3.2
3.3

(em GB) de
. . . . . . .
(em GB) de
. . . . . . .
(em GB) de
. . . . . . .

cada
. . .
cada
. . .
cada
. . .

.
.
.
.

.
.
.
.

.
.
.
.

algoritmo para preprocessar
. . . . . . . . . . . . . . . . .
algoritmo para preprocessar
. . . . . . . . . . . . . . . . .
algoritmo para preprocessar
. . . . . . . . . . . . . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

Ã¡rvores
. . . . .
Ã¡rvores
. . . . .
Ã¡rvores
. . . . .

10
14
15
15

25
25
26

Lista de Programas
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
A.1

CriaÃ§Ã£o da Ã¡rvore. . . . . . . . . . . . . . . . .
Consulta do Algoritmo Trivial. . . . . . . . . .
Preprocessamento do Algoritmo da Tabela. . .
Consulta do Algoritmo da Tabela. . . . . . . .
Preprocessamento do Algoritmo dos Ponteiros.
Consulta do Algoritmo dos Ponteiros. . . . . .
Preprocessamento do Algoritmo da PrÃ©-ordem.
Consulta do Algoritmo da PrÃ©-ordem. . . . . .
Parte dos testes para o Algoritmo da Tabela. .

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

8
10
10
11
11
12
13
14
30

vii

SumÃ¡rio

1 Uma introduÃ§Ã£o Ã  Teoria dos Grafos
1.1 As Pontes de KÃ¶nigsberg . . . . . . . . . . . .
1.2 Grafos . . . . . . . . . . . . . . . . . . . . . .
1.3 Ãrvores . . . . . . . . . . . . . . . . . . . . . .
1.3.1 Fator de ramificaÃ§Ã£o e Ã¡rvores k-Ã¡rias
1.3.2 Ãrvores completas . . . . . . . . . . .
1.3.3 Busca em profundidade e travessias . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

2 O Problema do Ancestral de NÃ­vel e ImplementaÃ§Ãµes
2.1 DefiniÃ§Ã£o do problema . . . . . . . . . . . . . . . . .
2.2 ImplementaÃ§Ãµes . . . . . . . . . . . . . . . . . . . . .
2.2.1 Algoritmo Trivial . . . . . . . . . . . . . . . .
2.2.2 Algoritmo da Tabela . . . . . . . . . . . . . .
2.2.3 Algoritmo dos Ponteiros . . . . . . . . . . . .
2.2.4 Algoritmo da PrÃ©-ordem . . . . . . . . . . . .
2.3 Resumo das implementaÃ§Ãµes . . . . . . . . . . . . . .
3 Benchmarks
3.1 Metodologia . . . . . . . . .
3.2 AnÃ¡lise dos resultados . . . .
3.2.1 Preprocessamento .
3.2.2 Consultas . . . . . .
3.3 Uso de memÃ³ria . . . . . . .
3.3.1 Ãrvores lineares . .
3.3.2 Ãrvores binÃ¡rias . .
3.3.3 Ãrvores quaternÃ¡rias
3.4 ConclusÃµes e trabalho futuro

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.

1
1
2
3
3
4
4

.
.
.
.
.
.
.

7
7
8
9
10
11
13
14

.
.
.
.
.
.
.
.
.

17
17
18
18
21
24
24
25
26
26

viii

ApÃªndices
A Testes de unidade com a biblioteca Catch2

29

ReferÃªncias

31

1

CapÃ­tulo 1
Uma introduÃ§Ã£o Ã  Teoria dos
Grafos

1.1

As Pontes de KÃ¶nigsberg

No sÃ©culo XVIII, a cidade de KÃ¶nigsberg, na PrÃºssia (hoje Kaliningrado, na atual RÃºssia)
era um importante centro comercial devido Ã  sua localizaÃ§Ã£o prÃ³xima ao rio, que dividia a
cidade em quatro regiÃµes, interligadas por sete pontes.

Fonte: MacTutor History of Mathematics archive
Figura 1.1: A cidade de KÃ¶nigsberg e suas sete pontes

Segundo histÃ³rias, um passatempo de domingo dos cidadÃ£os de KÃ¶nigsberg consistia
em passear por sua cidade, atÃ© que um dia surgiu um desafio: encontrar uma forma de
andar por todas as regiÃµes passando por cada ponte apenas uma vez.
Nenhum habitante de KÃ¶nigsberg conseguiu encontrar a soluÃ§Ã£o para este problema,
porÃ©m, o desafio chegou atÃ© um homem chamado Leonhard Euler, que apesar de julgar o

2
1 | UMA INTRODUÃ‡ÃƒO Ã€ TEORIA DOS GRAFOS

problema trivial, ficou intrigado, como citado em Hopkins e Wilson (2004):
â€œThis question is so banal, but seemed to me worthy of attention in that
[neither] geometry, nor algebra, nor even the art of counting was sufficient to
solve it.â€
Euler provou que nÃ£o era possÃ­vel passar por toda a cidade de KÃ¶nigsberg sem passar
duas vezes pela mesma ponte, mas tambÃ©m resolveu o caso geral em Euler (1741), para
qualquer nÃºmero de regiÃµes e qualquer nÃºmero de pontes, dando assim origem a um ramo
da matemÃ¡tica que hoje chamamos de Teoria dos Grafos.

1.2

Grafos

Podemos definir um Grafo informalmente como um conjunto de entidades conectadas
entre si. Mais formalmente, podemos definir um grafo ğº como um par (ğ‘‰ , ğ¸) onde ğ‘‰ Ã© um
conjunto de vÃ©rtices e ğ¸ um conjunto de arestas entre os vÃ©rtices tal que ğ¸ âŠ† {(ğ‘¢, ğ‘£) âˆ£
ğ‘¢, ğ‘£ âˆˆ ğ‘‰ }.
As arestas de um grafo podem ter propriedades como direÃ§Ã£o e/ou algum valor associado dependendo do contexto em que estÃ¡ sendo utilizado, frequentemente possibilitando
soluÃ§Ãµes elegantes e eficientes para os mais diversos problemas.
0

1

0

1

3

2

3

2

(a) Um grafo nÃ£o dirigido.

0

2

(b) Um grafo dirigido.

0

1

3
10

5

1

3

7

3

2

2

(c) Um grafo com valores nas arestas.

7

10

3

5

2

(d) Um grafo dirigido com valores nas
arestas.

Figura 1.2: Exemplos de grafos.

3
1.3 | ÃRVORES

1.3

Ãrvores

Ãrvores sÃ£o um subconjunto dos grafos de incrÃ­vel importÃ¢ncia para a CiÃªncia da
ComputaÃ§Ã£o, sendo usadas nas mais diversas aplicaÃ§Ãµes, desde a estrutura de pastas de
um sistema operacional atÃ© bancos de dados e processamento de linguagem natural.
Diferente de outras estruturas como vetores, as Ã¡rvores se organizam de forma nÃ£o
linear, hierÃ¡rquica. Os elementos de uma Ã¡rvore sÃ£o chamados de nÃ³s e comumente um
nÃ³ especÃ­fico Ã© elegido para ser a sua raiz. Cada nÃ³ pode ter ligaÃ§Ãµes com outros nÃ³s
denominados filhos, que por sua vez podem ter seus prÃ³prios filhos e assim sucessivamente
atÃ© chegar em nÃ³s que nÃ£o possuem ligaÃ§Ã£o com nenhum outro elemento. Chamamos
estes nÃ³s de folhas.
TambÃ©m Ã© definida a profundidade de um nÃ³ como a quantidade de arestas no caminho
da raiz atÃ© ele, ou seja, a raiz tem profundidade zero, seus filhos profundidade um e assim
sucessivamente. Cada nÃ­vel da Ã¡rvore corresponde a uma â€œfatia horizontalâ€ que contÃ©m
os nÃ³s de uma certa profundidade; por definiÃ§Ã£o, o nÃ­vel de um nÃ³ ğ‘¢ Ã© profundidade(u) +
1.

0
1
3

2
4

5

6

Figura 1.3: Exemplo de Ã¡rvore. O nÃ³ 0 Ã© a raiz e tem como filhos os nÃ³s 1 e 2, cujos filhos sÃ£o
as folhas 3, 4 e 5, 6, respectivamente. O primeiro nÃ­vel contÃ©m o nÃ³ 0 e tem profundidade zero, o
segundo os nÃ³s 1 e 2 com profundidade um e o terceiro os nÃ³s 3, 4, 5 e 6 com profundidade dois.

1.3.1

Fator de ramificaÃ§Ã£o e Ã¡rvores k-Ã¡rias

O fator de ramificaÃ§Ã£o de uma Ã¡rvore Ã© definido como a quantidade mÃ©dia de filhos
que cada um de seus nÃ³s tem e pode ser obtido ao dividir o nÃºmero de arestas pelo nÃºmero
de nÃ³s com pelo menos um filho. Uma Ã¡rvore cujos nÃ³s tÃªm nÃ£o mais que ğ‘˜ filhos Ã©
chamada de Ã¡rvore k-Ã¡ria; em particular, quando ğ‘˜ = 2 estas Ã¡rvores sÃ£o apelidadas de
Ã¡rvores binÃ¡rias e quando ğ‘˜ = 4, Ã¡rvores quaternÃ¡rias. Outro caso especial Ã© quando
ğ‘˜ = 1, criando uma Ã¡rvore linear, essencialmente uma lista ligada de seus nÃ³s.

4
1 | UMA INTRODUÃ‡ÃƒO Ã€ TEORIA DOS GRAFOS

0
0

1
2

1

3

3

(a) Ãrvore linear.

0

2
4

5

3

2

(b) Ãrvore binÃ¡ria.

4

5

(c) Ãrvore quaternÃ¡ria.

Figura 1.4: Exemplos de Ã¡rvores com fatores de ramificaÃ§Ã£o diferentes.

1.3.2

Ãrvores completas

Ã‰ dito que um nÃ­vel ğ‘– de uma Ã¡rvore k-Ã¡ria Ã© completo se este possui todos os nÃ³s
possÃ­veis, isto Ã©, ğ‘˜ ğ‘–âˆ’1 . Uma Ã¡rvore k-Ã¡ria completa Ã© uma em que todos os nÃ­veis exceto
possivelmente o Ãºltimo sÃ£o completos e caso este nÃ£o seja, seus nÃ³s devem estar o mais Ã 
esquerda possÃ­vel.
0
0

1

1

2

3

2
3

6

4

(a) NÃ³s 3 e 4 nÃ£o estÃ£o o mais Ã 
esquerda possÃ­vel.

7

(b) O terceiro nÃ­vel nÃ£o estÃ¡ completo (o
nÃ³ 1 tem apenas um filho).

0

0

1
3

2
4

5

4

5

1
6

(c) Ãrvore binÃ¡ria completa.

3

2
4

(d) Ãrvore binÃ¡ria completa.

Figura 1.5: Exemplos de Ã¡rvores completas ou nÃ£o.

1.3.3

Busca em profundidade e travessias

Ãrvores podem ser percorridas de diferentes maneiras partindo de sua raiz, podendo
â€œconhecerâ€ seus nÃ³s em ordens diferentes a depender de algum critÃ©rio definido para

5
1.3 | ÃRVORES

escolher o prÃ³ximo nÃ³ a ser examinado. Em particular duas maneiras bastante conhecidas
para realizar a travessia de uma Ã¡rvore sÃ£o a busca em profundidade e a busca em
largura, onde a primeira tenta se aprofundar na Ã¡rvore o mÃ¡ximo possÃ­vel antes de
explorar outros caminhos e a segunda explora a Ã¡rvore nÃ­vel a nÃ­vel, conhecendo todos os
nÃ³s de determinada profundidade antes de conhecer nÃ³s mais profundos.
Uma busca em profundidade tambÃ©m pode ser realizada de mÃºltiplos jeitos, variando a
ordem em que o nÃ³ e seus filhos sÃ£o processados. Uma travessia em prÃ©-ordem significa
que o nÃ³ serÃ¡ processado primeiro e entÃ£o seus filhos serÃ£o colocados numa pilha de
execuÃ§Ã£o da esquerda para a direita, enquanto numa travessia em pÃ³s-ordem empilha
os filhos do nÃ³ antes de processÃ¡-lo, como ilustrado na Figura 1.6.
6

0
5

2
0

1

3

0

1
4

(a) Busca em profundidade
em pÃ³s-ordem.

2

4
3

5

1
6

(b) Busca em profundidade
em prÃ©-ordem.

3

2
4

5

6

(c) Busca em largura.

Figura 1.6: Ordem de visita aos nÃ³s da Ã¡rvore durante as travessias. O nÃºmero do nÃ³
representa a ordem em que ele foi processado.

Para o escopo desta monografia Ã© particularmente interessante a travessia em prÃ©ordem, que traz consigo algumas propriedades Ãºteis a serem exploradas mais a frente no
texto, quando a implementaÃ§Ã£o dos algoritmos for discutida.

7

CapÃ­tulo 2
O Problema do Ancestral de NÃ­vel
e ImplementaÃ§Ãµes

2.1

DefiniÃ§Ã£o do problema

O problema do Ancestral de NÃ­vel Ã© um problema fundamental de Ã¡rvores que pode
ser definido da seguinte forma: Dada uma Ã¡rvore enraizada ğ‘‡ com ğ‘› nÃ³s, para consultas
AN(ğ‘¢, ğ‘‘) onde ğ‘¢ Ã© um nÃ³ de ğ‘‡ e ğ‘‘ um nÃºmero inteiro, encontre o ancestral de profundidade ğ‘‘ de ğ‘¢ otimizando tanto o tempo de preprocessamento quanto o de resposta Ã s
consultas.
0
1

2

3
7

5

4
8

9

AN(13, 1) = 2

10

11

6
12

14

13

Figura 2.1: Exemplo de consulta de Ancestral de NÃ­vel.

0
1

2

3
7

5

4
8

9

AN(9, 2) = 4

10

11

6
12

13

14

Figura 2.2: Exemplo de consulta de Ancestral de NÃ­vel.

8
2 | O PROBLEMA DO ANCESTRAL DE NÃVEL E IMPLEMENTAÃ‡Ã•ES

Existem diversas soluÃ§Ãµes para tal problema, de diferentes nÃ­veis de complexidade e com
performances teoricamente diferentes. Em particular, por exemplo, Ã© possÃ­vel realizar as
consultas de forma trivial sem qualquer tipo de preprocessamento ou tambÃ©m preprocessar
todas as possÃ­veis consultas para que possam entÃ£o ser respondidas rapidamente.
Em Bender e Farach-Colton (2002), Papamichail et al. (2014) e Menghani e Matani
(2019) sÃ£o discutidas algumas soluÃ§Ãµes, incluindo as que serÃ£o implementadas e testadas
neste trabalho. Em particular, serÃ£o testadas soluÃ§Ãµes razoavelmente simples de serem
implementadas, atÃ© mesmo para mostrar que estas muitas vezes podem ter performance
melhor do que imagina-se se formos alÃ©m de uma simples anÃ¡lise de pior caso.
Como motivaÃ§Ã£o para o estudo deste problema, vale lembrar que o Ancestral de NÃ­vel
aparece como parte de problemas mais complexos como Ã¡rvores ordinais espaÃ§o-eficientes
como descrito em Geary et al. (2006) que podem ser usadas na representaÃ§Ã£o de documentos
XML que suportam consultas XPath. AlÃ©m disso, sÃ£o usadas em Sadakane e Grossi (2006)
para implementar estruturas de dados comprimidas e tambÃ©m em Yuan e Atallah (2009)
para consultas agregadas em Ã¡rvores. Por Ãºltimo, vemos aplicaÃ§Ãµes atÃ© mesmo no campo
de hashing em strings, como dito em Farach e Muthukrishnan (1996).

2.2

ImplementaÃ§Ãµes

Todas as implementaÃ§Ãµes assumem a mesma implementaÃ§Ã£o de Ã¡rvore onde Ã© guardada
apenas sua raiz e cada nÃ³ contÃ©m um vetor de ponteiros para seus filhos. Para facilitar as
implementaÃ§Ãµes, ao construir a Ã¡rvore Ã© feita uma busca em profundidade para preencher
vetores que servirÃ£o como funÃ§Ãµes globais pai() e profundidade(); nos cÃ³digos abaixo, N
Ã© o tamanho da Ã¡rvore.
Programa 2.1 CriaÃ§Ã£o da Ã¡rvore.
1
2
3
4
5
6
7
8
9
10
11
12
13
14

funcao cria_arvore(N, nÃ³)
raiz â† nÃ³
pai â† vetor de tamanho N
profundidade â† vetor de tamanho N
travessia(raiz, 0)
fim
rotina travessia(nÃ³, prof)
profundidade[nÃ³] = prof
para filho em nÃ³.filhos() faca
pai[filho] = nÃ³
travessia(filho, prof+1)
fim
fim

SerÃ¡ analisado, para cada algoritmo, tanto sua complexidade de tempo de execuÃ§Ã£o
quanto a de espaÃ§o adicional, tambÃ©m levando em consideraÃ§Ã£o quÃ£o simples Ã© sua im-

9
2.2 | IMPLEMENTAÃ‡Ã•ES

plementaÃ§Ã£o. Para tornar a discussÃ£o da complexidade de tempo mais clara, serÃ¡ dito
que um algoritmo tem complexidade de tempo âŸ¨ğ‘“ (ğ‘¥), ğ‘”(ğ‘¥)âŸ© se a complexidade de seu
preprocessamento Ã© ğ‘“ (ğ‘¥) e a de suas consultas Ã© ğ‘”(ğ‘¥).

2.2.1

Algoritmo Trivial

O primeiro algoritmo a ser estudado Ã© um em que simplesmente nÃ£o hÃ¡ nenhum preprocessamento e, para cada consulta, apenas subimos pelos pais a partir do nÃ³ em questÃ£o
atÃ© encontrarmos seu ancestral com profundidade igual Ã  profundidade requisitada.
Para esta implementaÃ§Ã£o, o tempo de execuÃ§Ã£o de seu preprocessamento nÃ£o depende
do tamanho da Ã¡rvore e tambÃ©m nÃ£o utiliza nenhuma memÃ³ria adicional, portanto o
preprocessamento do Algoritmo Trivial tem complexidade O(1) tanto para tempo quanto
espaÃ§o.

0
1

2

3
7

5

4
8

9

AN(7, 0) = 0

10

11

6
12

13

14

Figura 2.3: Exemplo de consulta do Algoritmo Trivial.

AN(7, 0) = 0
0

1

2

3

4

5

6

7

Figura 2.4: Exemplo de consulta do Algoritmo Trivial.

No que diz respeito a cada consulta, precisamos chamar a funÃ§Ã£o ğ‘ğ‘ğ‘–() partindo do nÃ³
inicial atÃ© chegar no nÃ³ com a profundidade desejada. Essa quantidade Ã© exatamente a
diferenÃ§a entre esta profundidade e a profundidade do nÃ³ inicial.
A consulta mais lenta para uma Ã¡rvore qualquer Ã© uma que parte do nÃ³ mais profundo
e precisa subir atÃ© a raiz, levando tempo O(ğ‘‘), onde ğ‘‘ Ã© a profundidade da Ã¡rvore. No pior
caso isso Ã© equivalente a O(ğ‘›) onde ğ‘› Ã© a quantidade de nÃ³s e para uma Ã¡rvore balanceada
cujos nÃ³s tÃªm ğ‘˜ filhos, Ã© equivalente a O(logğ‘˜ ğ‘›), fazendo com que a performance da
consulta seja muito dependente da forma da Ã¡rvore.
ApÃ³s essa anÃ¡lise, podemos concluir que o Algoritmo Trivial tem complexidade de
tempo âŸ¨O(1), O(ğ‘‘)âŸ© e O(1) de espaÃ§o adicional, sendo particularmente eficiente para Ã¡rvores
balanceadas e com fator de ramificaÃ§Ã£o maior.

10
2 | O PROBLEMA DO ANCESTRAL DE NÃVEL E IMPLEMENTAÃ‡Ã•ES

Programa 2.2 Consulta do Algoritmo Trivial.
1
2
3
4
5
6
7

funcao consulta(nÃ³, prof)
x â† nÃ³
enquanto profundidade(x) â‰  prof
x â† pai(x)
fim
devolva x
fim

2.2.2

Algoritmo da Tabela

Ao contrÃ¡rio do algoritmo trivial, a ideia Ã© precalcular o resultado de todas as consultas
possÃ­veis durante a fase de preprocessamento para otimizar o desempenho da fase de
consultas.
Cada nÃ³ ğ‘¢ tem associado a si profundidade(u) + 1 possÃ­veis consultas. Assim, para
uma Ã¡rvore com ğ‘› nÃ³s, existem ğ‘› + âˆ‘ğ‘›âˆ’1
ğ‘–=0 profundidade(i) = O(ğ‘›ğ‘‘) consultas, onde ğ‘‘ Ã© a
profundidade da Ã¡rvore. O preprocessamento se dÃ¡ de maneira simples, preenchendo uma
tabela de tamanho O(ğ‘›ğ‘‘) com dois laÃ§os encadeados, utilizando a funÃ§Ã£o ğ‘ğ‘ğ‘–() para subir
a partir de cada nÃ³ atÃ© a raiz e salvar a resposta para cada profundidade.
Programa 2.3 Preprocessamento do Algoritmo da Tabela.
1
2
3
4
5
6
7
8
9
10

rotina preprocessa(Ã¡rvore)
para u de 0 ate Nâˆ’1 faca
v â†u
tabela[u][profundidade(u)] = u
para w de profundidade(u)âˆ’1 ate 0 faca
tabela[u][w] = pai(v)
v = pai(v)
fim
fim
fim

0
1
3

2
4

5

6

Figura 2.5: Ãrvore exemplo.

0:
1:
2:
3:
4:
5:
6:

p=0
0
0
0
0
0
0
0

p=1

p=2

1
2
1
1
2
2

3
4
5
6

(ğ‘–, ğ‘—) = AN(ğ‘–, ğ‘—)

Tabela 2.1: Tabela de resultados das consultas
da Ã¡rvore da figura 2.5.

Com a tabela devidamente preenchida, as consultas se tornam tÃ£o simples quanto

11
2.2 | IMPLEMENTAÃ‡Ã•ES

acessar a sua entrada correspondente, ou seja, a resposta da consulta que pede pelo
ancestral do nÃ³ ğ‘¢ com profundidade ğ‘ Ã© dada por ğ‘¡ğ‘ğ‘ğ‘’ğ‘™ğ‘[ğ‘¢][ğ‘].
Programa 2.4 Consulta do Algoritmo da Tabela.
1
2
3

funcao consulta(nÃ³, prof)
devolva tabela[nÃ³][prof]
fim

A complexidade de espaÃ§o e de tempo do preprocessamento dependem fortemente da
forma da Ã¡rvore, podendo ser O(ğ‘›2 ) no caso de uma Ã¡rvore linear e para o caso de uma
Ã¡rvore ğ‘˜-Ã¡ria balanceada Ã© O(ğ‘› logğ‘˜ ğ‘›), muito mais eficiente. JÃ¡ a consulta Ã© feita em tempo
O(1), usando apenas a tabela previamente calculada. Assim, o Algoritmo da Tabela tem
complexidade de tempo âŸ¨O(ğ‘›ğ‘‘), O(1)âŸ© e O(ğ‘›ğ‘‘) de espaÃ§o, sendo uma boa opÃ§Ã£o para casos
de Ã¡rvores balanceadas em que o preprocessamento se torna barato frente Ã  quantidade de
consultas que serÃ£o feitas e o espaÃ§o utilizado nÃ£o Ã© uma restriÃ§Ã£o.

2.2.3

Algoritmo dos Ponteiros

Aqui a ideia Ã© subir do nÃ³ inicial atÃ© a resposta em cada consulta de forma mais
inteligente; para isso, a cada nÃ³ ğ‘¢ da Ã¡rvore Ã© associado um vetor com ponteiros onde o
elemento na posiÃ§Ã£o ğ‘— aponta para o 2ğ‘— -Ã©simo ancestral de ğ‘¢. Para preencher estes vetores,
note que o 20 -Ã©simo ancestral de um nÃ³ Ã© seu pai e que 2ğ‘—âˆ’1 + 2ğ‘—âˆ’1 = 2ğ‘— , ou seja, o 2ğ‘—âˆ’1 -Ã©simo
ancestral do 2ğ‘—âˆ’1 -Ã©simo ancestral de um nÃ³ Ã© seu 2ğ‘— -Ã©simo ancestral:
Programa 2.5 Preprocessamento do Algoritmo dos Ponteiros.
1
2
3
4
5
6
7
8
9
10
11
12
13

rotina preprocessa(Ã¡rvore)
M â† âŒˆlog2 ğ‘‘ âŒ‰ âŠ³ d Ã© a profundidade da Ã¡rvore
ponteiros â† matriz N x (M+1)
para i de 0 ate Nâˆ’1 faca
ponteiros[i][0] â† pai(i)
fim
para j de 1 ate M faca
para i de 0 ate Nâˆ’1 faca
x â† ponteiros[i][jâˆ’1]
ponteiros[i][j] â† ponteiros[x][jâˆ’1]
fim
fim
fim

Uma vez que a tabela de ponteiros estÃ¡ preenchida a consulta se dÃ¡, de forma bastante
elegante, atravÃ©s da representaÃ§Ã£o binÃ¡ria dos nÃºmeros. Para um nÃºmero de ğ‘š bits ğ‘‹ , este
ğ‘–
nÃºmero pode ser escrito como uma sequÃªncia ğ‘ ğ‘šâˆ’1 ğ‘ ğ‘šâˆ’2 â€¦ ğ‘ 1 ğ‘ 0 e âˆ‘ğ‘šâˆ’1
ğ‘–=0 ğ‘ ğ‘– â‹… 2 = ğ‘‹ . Seja ğ‘‹ a
diferenÃ§a entre a profundidade do nÃ³ inicial da consulta e a profundidade da resposta, os
pulos necessÃ¡rios sÃ£o dados exatamente pelos bits ligados em ğ‘‹ .

12
2 | O PROBLEMA DO ANCESTRAL DE NÃVEL E IMPLEMENTAÃ‡Ã•ES

Exemplo: seja ğ‘‹ = 85 = 010101012 a distÃ¢ncia do nÃ³ inicial para a resposta, pode-se
pular 26 = 64 nÃ³s, depois 24 = 16, 22 = 4 e finalmente apenas 20 = 1 para terminar a
consulta.
20 -Ã©simo ancestral

0

1

2 -Ã©simo ancestral

2

AN(7, 0) = 0

1

3
7

5

4
8

9

10

11

6
12

13

14

Figura 2.6: Exemplo de consulta do Algoritmo dos Ponteiros. A diferenÃ§a de profundidade Ã© 3
= 0112 = 21 + 20 .

22 -Ã©simo ancestral

AN(7, 0) = 0

2 -Ã©simo ancestral
0

0

1

2

3

4

5

6

7

21 -Ã©simo ancestral
Figura 2.7: Exemplo de consulta do Algoritmo dos Ponteiros. A diferenÃ§a de profundidade Ã© 7
= 01112 = 22 + 21 + 20 .

Programa 2.6 Consulta do Algoritmo dos Ponteiros.
1
2
3
4
5
6
7
8
9

funcao consulta(nÃ³, prof)
x â† nÃ³
enquanto profundidade(x) â‰  prof faca
d = profundidade(x) âˆ’ prof
pulo â† âŒŠlog2 ğ‘‘ âŒ‹ âŠ³ seleciona o bit mais significante
x â† ponteiros[x][pulo]
fim
devolva x
fim

Como a quantidade de passos da consulta Ã© exatamente o nÃºmero de bits ligados em ğ‘‹ ,
sÃ£o necessÃ¡rios O(log ğ‘‘) passos, onde ğ‘‘ Ã© a profundidade da Ã¡rvore. Portanto, a complexidade do Algoritmo dos Ponteiros Ã© âŸ¨O(ğ‘› log ğ‘‘), O(log ğ‘‘)âŸ© de tempo e O(ğ‘› log ğ‘‘) de espaÃ§o,
que no caso de uma Ã¡rvore ğ‘˜-Ã¡ria balanceada se tornam âŸ¨O(ğ‘› logğ‘˜ (logğ‘˜ ğ‘›)), O(logğ‘˜ (logğ‘˜ ğ‘›))âŸ©
e O(ğ‘› logğ‘˜ (logğ‘˜ ğ‘›)), respectivamente.

13
2.2 | IMPLEMENTAÃ‡Ã•ES

2.2.4

Algoritmo da PrÃ©-ordem

O Ãºltimo algoritmo considerado neste texto faz uso das propriedades da prÃ©-ordem de
uma Ã¡rvore para trazer um preprocessamento mais eficiente. Enquanto Ã© feita a travessia
da Ã¡rvore, cada nÃ³ Ã© associado ao seu Ã­ndice na prÃ©-ordem, que Ã© inserido numa lista de
nÃ³s de sua respectiva profundidade.

Figura 2.8: AssociaÃ§Ã£o entre os Ã­ndices originais e os Ã­ndices da prÃ©-ordem.

Para tal, a ideia Ã© guardar a ordem em que os nÃ³s de cada nÃ­vel foram visitados durante
a travessia em prÃ©-ordem em vetores e entÃ£o uma consulta se resume a procurar o ancestral
do nÃ³ inicial que estÃ¡ no vetor correspondente Ã  profundidade buscada, tendo performance
proporcional Ã  quantidade de elementos por nÃ­vel da Ã¡rvore.
Programa 2.7 Preprocessamento do Algoritmo da PrÃ©-ordem.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

global id = 0
rotina preprocessa(Ã¡rvore)
dfs(Ã¡rvore.raiz, prof = 0)
fim
rotina dfs(nÃ³, prof)
preordem[nÃ³] = id
nome[id] = nÃ³
travessia[prof].insere(id)
id â† id + 1
para u em nÃ³.filhos() faca
dfs(u, prof + 1)
fim
fim

Para entendermos o funcionamento do algoritmo para as consultas, primeiro precisamos nos convencer de que, se um nÃ³ ğ‘£ Ã© ancestral de ğ‘¢, entÃ£o preordem(v) â‰¤ preordem(u),
onde preordem(x) Ã© o Ã­ndice associado Ã  posiÃ§Ã£o de ğ‘¥ na travessia em prÃ©-ordem. Isso Ã©
verdade jÃ¡ que sempre descobrimos os filhos de um nÃ³ depois dele prÃ³prio, fazendo com
que um nÃ³ com Ã­ndice maior que outro nÃ£o possa ser seu ancestral. AlÃ©m disso, no caso em
que existam vÃ¡rios nÃ³s em determinada profundidade, o ancestral que buscamos Ã© aquele
cujo Ã­ndice na prÃ©-ordem Ã© o mais prÃ³ximo do Ã­ndice do nÃ³ inicial, porÃ©m ainda menor

14
2 | O PROBLEMA DO ANCESTRAL DE NÃVEL E IMPLEMENTAÃ‡Ã•ES

profundidade 0:

0

profundidade 1:

1

4

profundidade 2:

2

3

5

6

Tabela 2.2: Vetores contendo os nÃ³s processados em cada nÃ­vel. Os Ã­ndices guardados nos
vetores sÃ£o referentes Ã  prÃ©-ordem e nÃ£o os da Ã¡rvore original.

que tal. Para realizar esta consulta de forma eficiente e obter complexidade logarÃ­tmica,
pode-se usar a tÃ©cnica de busca binÃ¡ria para encontrar o Ãºltimo elemento de um vetor
menor ou igual ao parÃ¢metro passado em O(log ğ‘š) passos, onde ğ‘š Ã© o tamanho desse
vetor, lembrando que a busca deve ser feita com base nos Ã­ndices da prÃ©-ordem e depois
esse Ã­ndice deve ser convertido para a resposta.
Programa 2.8 Consulta do Algoritmo da PrÃ©-ordem.
1
2
3
4

funcao consulta(nÃ³, prof)
idx â† travessia[prof].busca_binaria(preordem[nÃ³])
devolva nome[idx]
fim

profundidade 1:

1

4

Figura 2.9: Exemplo de consulta do Algoritmo da PrÃ©-ordem. Para uma consulta AN(5, 1) na
Ã¡rvore da figura 2.8, a resposta seria o nÃ³ com Ã­ndice de prÃ©-ordem igual a 4, ou seja, o nÃ³ 2.

Finalmente, podemos entÃ£o concluir que a complexidade de tempo do Algoritmo da
PrÃ©-ordem Ã© âŸ¨O(ğ‘›), O(log ğ‘˜ ğ‘‘ )âŸ© jÃ¡ que a quantidade de nÃ³s por nÃ­vel de uma Ã¡rvore ğ‘˜-Ã¡ria Ã©
O(ğ‘˜ ğ‘‘ ) e a de espaÃ§o Ã© O(ğ‘›).

2.3

Resumo das implementaÃ§Ãµes

No prÃ³ximo capÃ­tulo estaremos interessados em avaliar a performance de cada algoritmo para alguns casos de teste, levando em consideraÃ§Ã£o o preprocessamento necessÃ¡rio,
a realizaÃ§Ã£o de consultas e a quantidade de memÃ³ria utilizada.
Entretanto, analisando as tabelas 2.3, 2.4 pode-se perceber de imediato que restringir
a entrada para Ã¡rvores balanceadas permite atÃ© mesmo que os algoritmos mais simples
apresentem complexidades boas, o que espera-se que seja refletido nos resultados dos
testes. Vale lembrar que dizer que um algoritmo tem complexidade de tempo âŸ¨ğ‘“ (ğ‘¥), ğ‘”(ğ‘¥)âŸ©
quer dizer que a complexidade de seu preprocessamento Ã© ğ‘“ (ğ‘¥) e a de suas consultas Ã©
ğ‘”(ğ‘¥).

15
2.3 | RESUMO DAS IMPLEMENTAÃ‡Ã•ES

Trivial
Tabela
Ponteiros
PrÃ©-ordem

Linear
âŸ¨O(1), O(ğ‘›)âŸ©
âŸ¨O(ğ‘›2 ), O(1)âŸ©
âŸ¨O(ğ‘› log2 ğ‘›), O(log2 ğ‘›)âŸ©
âŸ¨O(ğ‘›), O(1)âŸ©

k-Ã¡ria
âŸ¨O(1), O(logğ‘˜ ğ‘›)âŸ©
âŸ¨O(ğ‘› logğ‘˜ ğ‘›), O(1)âŸ©
âŸ¨O(ğ‘› logğ‘˜ (logğ‘˜ ğ‘›)), O(logğ‘˜ (logğ‘˜ ğ‘›))âŸ©
âŸ¨O(ğ‘›), O(logğ‘˜ ğ‘›)âŸ©

Tabela 2.3: ComparaÃ§Ã£o da complexidade de tempo dos algoritmos.

Trivial
Tabela
Ponteiros
PrÃ©-ordem

Linear
O(1)
O(ğ‘›2 )
O(ğ‘› log2 ğ‘›)
O(ğ‘›)

k-Ã¡ria
O(1)
O(ğ‘› logğ‘˜ ğ‘›)
O(ğ‘› logğ‘˜ (logğ‘˜ ğ‘›))
O(ğ‘›)

Tabela 2.4: ComparaÃ§Ã£o da complexidade de espaÃ§o dos algoritmos.

17

CapÃ­tulo 3
Benchmarks

3.1

Metodologia

Os algoritmos foram implementados na linguagem C++ usando apenas as bibliotecas
padrÃ£o e a STL. Todos os programas foram compilados com a versÃ£o 7.4.0 do compilador
g++, num computador que possui um processador Intel Core i5-8250U com clock base de
1.60GHz e turbo boost atÃ© 3.40GHz em uma Ãºnica thread. As mediÃ§Ãµes de tempo foram feitas
com o steady_clock da biblioteca <chrono>, utilizando uma precisÃ£o de nanosegundos,
tomando o devido cuidado de cronometrar apenas as partes relevantes do cÃ³digo. Todos
os programas foram compilados com a flag -O2 para permitir otimizaÃ§Ãµes por parte do
compilador.
Para cada algoritmo apresentado neste trabalho, foram medidos os tempos de execuÃ§Ã£o
tanto da parte de preprocessamento quanto da parte de consultas, separadamente. Cada
teste tambÃ©m foi realizado com Ã¡rvores lineares, binÃ¡rias e quaternÃ¡rias para evidenciar
possÃ­veis diferenÃ§as de performance de acordo com o formato da Ã¡rvore.
O nÃºmero de nÃ³s das Ã¡rvores testadas variou entre 150K e 21.6M e as Ã¡rvores binÃ¡rias
e quaternÃ¡rias geradas para fins destes testes sÃ£o completas (portanto balanceadas). Tanto
os testes de preprocessamento quanto os de consultas foram executados dez vezes com
cada tamanho de Ã¡rvore para tomar entÃ£o suas mÃ©dias como resultado.
Os testes de preprocessamento consistem em um programa que cria uma Ã¡rvore completa com a quantidade de nÃ³s e o fator de ramificaÃ§Ã£o desejados e entÃ£o cria um objeto
da classe associada ao algoritmo a ser testado, o que equivale Ã  fase de preprocessar a
Ã¡rvore de entrada. JÃ¡ os testes de consultas consistem em um programa que cria tambÃ©m
uma Ã¡rvore completa com os mesmos parÃ¢metros e entÃ£o executam um conjunto de 10M
de consultas gerado previamente. Estes arquivos foram gerados aleatoriamente de forma
que toda consulta seja composta por um nÃ³ vÃ¡lido (entre 0 e ğ‘ âˆ’ 1) onde ğ‘ Ã© o tamanho
do experimento e uma profundidade vÃ¡lida (entre 0 e profundidade(u), onde ğ‘¢ Ã© o nÃ³ da
consulta.

18
3 | BENCHMARKS

3.2

AnÃ¡lise dos resultados

As Ã¡rvores que surgiriam em aplicaÃ§Ãµes reais possivelmente nÃ£o seriam exatamente
como as Ã¡rvores aqui testadas, que sÃ£o todas completas, porÃ©m ainda podemos ter uma
boa noÃ§Ã£o de como as diferentes implementaÃ§Ãµes se comportam no pior caso possÃ­vel e
em casos mais favorÃ¡veis.

3.2.1

Preprocessamento

Ãrvores lineares
A primeira coisa a ser notada Ã© que, para Ã¡rvores lineares, o Algoritmo da Tabela mal
pode ser comparado com os outros, jÃ¡ que para este caso sua complexidade de espaÃ§o de
preprocessamento Ã© O(ğ‘›2 ), se tornando impossÃ­vel manter o programa na memÃ³ria atÃ©
mesmo para o menor tamanho de Ã¡rvore dos testes padrÃ£o, 150K. Apesar disso, o tamanho
das Ã¡rvores foi mantido para que os testes nÃ£o se tornassem facilmente influenciÃ¡veis por
fatores do sistema como trocas de contexto, por exemplo. Como evidenciado na figura 3.1,
o Algoritmo da Tabela tem desempenho muito pior do que todos os outros atÃ© mesmo
para os testes reduzidos, o que nos dÃ¡ seguranÃ§a para afirmar, juntamente com sua anÃ¡lise
de complexidade, que ele tambÃ©m levaria muito mais tempo para completar os testes
padrÃ£o.

Trivial
Preordem
Tabela
Ponteiros

tempo de execuÃ§Ã£o (segundos)

7
6
5
4
3
2
1
0
0

10000

20000
30000
quantidade de nÃ³s

40000

50000

Figura 3.1: Resultados para o preprocessamento de Ã¡rvores lineares com uma versÃ£o reduzida dos
testes.

Seguindo para a bateria normal de testes, o Algoritmo Trivial, como esperado, Ã© definitivamente o mais rÃ¡pido, se mantendo essencialmente constante a menos de pequenas

19
3.2 | ANÃLISE DOS RESULTADOS

variaÃ§Ãµes, seguido pelo Algoritmo da PrÃ©-ordem que leva uma vantagem grande sobre Algoritmo dos Ponteiros jÃ¡ que este Ã© O(ğ‘› log ğ‘›) enquanto o primeiro Ã© O(ğ‘›).

tempo de execuÃ§Ã£o (segundos)

10

Trivial
Preordem
Ponteiros

8
6
4
2
0
0.0

0.5

1.0
1.5
quantidade de nÃ³s

2.0

1e7

Figura 3.2: Resultados para o preprocessamento de Ã¡rvores lineares com os testes padrÃ£o.

20
3 | BENCHMARKS

Ãrvores binÃ¡rias

Para estes testes estamos considerando Ã¡rvores binÃ¡rias completas com profundidade
esperada log2 ğ‘› onde ğ‘› Ã© o tamanho do teste, o que torna possÃ­vel por exemplo rodar
o Algoritmo da Tabela para todos os tamanhos jÃ¡ que sua complexidade de espaÃ§o se torna
O(ğ‘› log ğ‘›), sendo comparÃ¡vel com o Algoritmo dos Ponteiros, que ainda se mostra mais
eficiente pela constante menor. O Algoritmo da PrÃ©-ordem se tornou ainda mais rÃ¡pido
se comparado aos testes com Ã¡rvores lineares apesar de sua complexidade nÃ£o depender
da profundidade da Ã¡rvore, provavelmente por serem necessÃ¡rias menos alocaÃ§Ãµes de
memÃ³ria.

Trivial
Preordem
Tabela
Ponteiros

tempo de execuÃ§Ã£o (segundos)

3.5
3.0
2.5
2.0
1.5
1.0
0.5
0.0
0.0

0.5

1.0
1.5
quantidade de nÃ³s

2.0

1e7

Figura 3.3: Resultados para o preprocessamento de Ã¡rvores binÃ¡rias.

Ãrvores quaternÃ¡rias

Para estas Ã¡rvores Ã© interessante notar que o desempenho do Algoritmo da Tabela e
do Algoritmo dos Ponteiros foram melhores do que para Ã¡rvores binÃ¡rias e isso se deve Ã 
relaÃ§Ã£o entre suas complexidades de tempo e o fator de ramificaÃ§Ã£o da Ã¡rvore. O Algoritmo
dos Ponteiros se manteve estÃ¡vel jÃ¡ que sua complexidade nÃ£o depende da forma da Ã¡rvore,
o que o torna pouco adaptÃ¡vel ao formato da entrada.

21
3.2 | ANÃLISE DOS RESULTADOS

Trivial
Preordem
Tabela
Ponteiros

tempo de execuÃ§Ã£o (segundos)

2.0
1.5
1.0
0.5
0.0
0.0

0.5

1.0
1.5
quantidade de nÃ³s

2.0

1e7

Figura 3.4: Resultados para o preprocessamento de Ã¡rvores quaternÃ¡rias.

3.2.2

Consultas

Ãrvores lineares

Aqui, assim como no caso dos testes de preprocessamento, nÃ£o sÃ£o todos os algoritmos
que conseguiram passar pela bateria de testes padrÃ£o. O Algoritmo da Tabela segue com sua
limitaÃ§Ã£o de memÃ³ria, porÃ©m agora o Algoritmo Trivial fica bastante lento, chegando perto
dos 20 segundos para 1K consultas no maior tamanho de Ã¡rvore e a metodologia escolhida
para os testes de consulta fez com que o Algoritmo dos Ponteiros tambÃ©m nÃ£o conseguisse
ter memÃ³ria suficiente jÃ¡ que o arquivo de teste era carregado simultaneamente na memÃ³ria
do computador. Todavia, como espera-se que o tempo necessÃ¡rio para responder uma
quantidade ğ‘š de consultas seja uma funÃ§Ã£o linear em ğ‘š, Ã© possÃ­vel obter resultados ainda
significativos a partir do teste reduzido.

22
3 | BENCHMARKS

Preordem
Tabela
Ponteiros

tempo de execuÃ§Ã£o (segundos)

1.2
1.0
0.8
0.6
0.4
0.2
0

10000

20000
30000
quantidade de nÃ³s

40000

50000

Figura 3.5: Resultados para o teste reduzido de consultas em Ã¡rvores lineares. Para efeito
de comparaÃ§Ã£o, o tempo esperado para o Algoritmo Trivial executar 10M consultas para o maior
tamanho de Ã¡rvore deste teste Ã© de aproximadamente 7 minutos e por isso nem estÃ¡ no grÃ¡fico.

Ãrvores binÃ¡rias

Os testes de consultas em Ã¡rvores binÃ¡rias evidenciaram a grande melhora que o
Algoritmo Trivial consegue obter, jÃ¡ que, ao limitar a profundidade das Ã¡rvores testadas
em O(log2 ğ‘›), cada uma de suas consultas tambÃ©m Ã© realizada em tempo logarÃ­tmico. JÃ¡
o Algoritmo da PrÃ©-ordem e o Algoritmo dos Ponteiros tÃªm performances semelhantes,
porÃ©m, o segundo leva a melhor. O Algoritmo da Tabela, como esperado, se mantÃ©m
constante e extremamente rÃ¡pido.

Vale lembrar tambÃ©m que esses resultados correspondem Ã  realizaÃ§Ã£o de 10 milhÃµes de
consultas, ou seja, atÃ© mesmo o Algoritmo Trivial Ã© capaz de realizar uma Ãºnica consulta
em tempos quase insignificantes (na ordem de 9.25eâˆ’07 segundos).

23
3.2 | ANÃLISE DOS RESULTADOS

Trivial
Preordem
Tabela
Ponteiros

tempo de execuÃ§Ã£o (segundos)

8
6
4
2
0
0.0

0.5

1.0
1.5
quantidade de nÃ³s

2.0

1e7

Figura 3.6: Resultados para as consultas em Ã¡rvores binÃ¡rias.

Ãrvores quaternÃ¡rias

Aqui, o Algoritmo Trivial se torna ainda mais eficiente devido Ã  limitaÃ§Ã£o da profundidade das Ã¡rvores em O(log4 ğ‘›), ficando muito mais prÃ³ximo dos seus concorrentes e
ficando abaixo de de 5 segundos para 10 milhÃµes de consultas no maior tamanho de Ã¡rvore
testado. Tanto o Algoritmo da PrÃ©-ordem e o Algoritmo dos Ponteiros se mantiveram
praticamente iguais ao teste anterior, provavelmente devido Ã s suas constantes jÃ¡ serem
suficientemente pequenas para Ã¡rvores binÃ¡rias.

24

tempo de execuÃ§Ã£o (segundos)

3 | BENCHMARKS

Trivial
Preordem
Tabela
Ponteiros

4
3
2
1
0.0

0.5

1.0
1.5
quantidade de nÃ³s

2.0

1e7

Figura 3.7: Resultados para as consultas em Ã¡rvores quaternÃ¡rias.

3.3

Uso de memÃ³ria

Uma parte muito importante da comparaÃ§Ã£o dos algoritmos implementados Ã© analisar
seu consumo de memÃ³ria, jÃ¡ que alÃ©m de ser um fator proibitivo para muitos computadores
pessoais tambÃ©m pode influenciar a performance de um algoritmo caso fique no limite
da memÃ³ria disponÃ­vel. Os valores presentes nas tabelas abaixo foram obtidos atravÃ©s
do programa /usr/bin/time -v do Linux, exceto para o Algoritmo da Tabela no caso das
Ã¡rvores lineares.

3.3.1

Ãrvores lineares

Observando a quantidade necessÃ¡ria de memÃ³ria para preprocessar Ã¡rvores lineares
com cada um dos algoritmos pode-se ver porque o Algoritmo da Tabela Ã© inviÃ¡vel para
este caso do problema, jÃ¡ que atingiria quantidades absurdas devido Ã  sua complexidade
quadrÃ¡tica. O Algoritmo dos Ponteiros apresenta uma quantidade de memÃ³ria utilizada
maior que o Algoritmo da PrÃ©-ordem, como esperado, jÃ¡ que o primeiro tem uma constante
que multiplica sua complexidade.

25
3.3 | USO DE MEMÃ“RIA

NÃ³s
150K
300K
600K
1.2M
2.4M
4.8M
7.2M
9.6M
10.8M
14.4M
19.2M
21.6M

Trivial
0.017
0.031
0.059
0.11
0.22
0.45
0.67
0.90
1.01
1.35
1.80
2.02

Tabela *
44
176
704
2816
11264
45056
101376
228096
513216
1154736
2598156
3259126

Ponteiros
0.034
0.066
0.129
0.256
0.546
1.09
1.63
2.17
2.44
3.26
4.35
4.89

PrÃ©-ordem
0.028
0.053
0.104
0.206
0.410
0.818
1.12
1.63
1.75
2.25
3.26
3.50

Tabela 3.1: Uso de memÃ³ria (em GB) de cada algoritmo para preprocessar Ã¡rvores lineares.
Os valores do Algoritmo da Tabela foram estimados, jÃ¡ que nÃ£o Ã© possÃ­vel rodÃ¡-lo para estes
tamanhos. AlÃ©m disso, Ã© importante notar que estÃ¡ incluso nestes valores a Ã¡rvore em si, jÃ¡ que
mesmo o Algoritmo Trivial, que nÃ£o realiza preprocessamento nenhum, ainda precisa acessar a
estrutura da Ã¡rvore.

3.3.2

Ãrvores binÃ¡rias

Com os testes restringidos a Ã¡rvores binÃ¡rias, o Algoritmo da Tabela consegue realizar
o preprocessamento sem estourar a memÃ³ria da mÃ¡quina utilizada, mas ainda apresenta
uma quantidade significativamente maior que os outros algoritmos, o que pode se tornar
um problema eventualmente para casos extremos. AlÃ©m disso, todos os outros algoritmos
tambÃ©m apresentaram um uso reduzido de memÃ³ria, como esperado.
NÃ³s
150K
300K
600K
1.2M
2.4M
4.8M
7.2M
9.6M
10.8M
14.4M
19.2M
21.6M

Trivial
0.014
0.026
0.050
0.096
0.190
0.377
0.565
0.753
0.846
1.12
1.50
1.69

Tabela
0.029
0.057
0.115
0.232
0.467
0.945
1.45
1.95
2.21
2.97
3.98
4.48

Ponteiros
0.029
0.042
0.082
0.162
0.322
0.640
0.959
1.27
1.43
1.91
2.55
2.87

PrÃ©-ordem
0.016
0.030
0.057
0.112
0.221
0.439
0.670
0.877
0.989
1.33
1.75
1.97

Tabela 3.2: Uso de memÃ³ria (em GB) de cada algoritmo para preprocessar Ã¡rvores binÃ¡rias. Note que estÃ¡ incluso nestes valores a Ã¡rvore em si, jÃ¡ que mesmo o Algoritmo Trivial, que nÃ£o
realiza preprocessamento nenhum, ainda precisa acessar a estrutura da Ã¡rvore.

26
3 | BENCHMARKS

3.3.3

Ãrvores quaternÃ¡rias

Nestes testes, Ã© possÃ­vel observar uma pequena reduÃ§Ã£o da memÃ³ria utilizada pelo Algoritmo Trivial e pelo Algoritmo da PrÃ©-ordem, apesar de seu preprocessamento nÃ£o depender
do fator de ramificaÃ§Ã£o da Ã¡rvore e o Algoritmo dos Ponteiros viu um ganho tambÃ©m
pequeno, jÃ¡ que a mudanÃ§a de ğ‘› log2 (log2 ğ‘›) para ğ‘› log4 (log4 ğ‘›) nÃ£o Ã© tÃ£o expressiva. Isto
indica que, para fatores de ramificaÃ§Ã£o maiores ainda, a quantidade de memÃ³ria utilizada
pelos algoritmos deve se estabilizar nÃ£o muito longe dos valores desta tabela.
NÃ³s
150K
300K
600K
1.2M
2.4M
4.8M
7.2M
9.6M
10.8M
14.4M
19.2M
21.6M

Trivial
0.014
0.025
0.047
0.092
0.181
0.354
0.537
0.715
0.804
1.07
1.42
1.60

Tabela
0.024
0.046
0.093
0.189
0.381
0.766
1.15
1.53
1.72
2.30
3.07
3.45

Ponteiros
0.022
0.041
0.080
0.157
0.312
0.622
0.931
1.24
1.39
1.85
2.47
2.78

PrÃ©-ordem
0.016
0.029
0.055
0.109
0.214
0.429
0.632
0.847
0.966
1.31
1.69
1.87

Tabela 3.3: Uso de memÃ³ria (em GB) de cada algoritmo para preprocessar Ã¡rvores quaternÃ¡rias. Note que estÃ¡ incluso nestes valores a Ã¡rvore em si, jÃ¡ que mesmo o Algoritmo Trivial, que
nÃ£o realiza preprocessamento nenhum, ainda precisa acessar a estrutura da Ã¡rvore.

3.4

ConclusÃµes e trabalho futuro

Analisando os resultados fica evidente o quÃ£o importante Ã© conhecer tanto a aplicaÃ§Ã£o
em questÃ£o quanto os recursos disponÃ­veis, jÃ¡ que cada algoritmo tem mÃ©ritos e defeitos
que dependem do formato das Ã¡rvores. O Algoritmo da Tabela Ã© uma Ã³tima escolha para
aplicaÃ§Ãµes em que a quantidade de consultas pesa muito mais do que o tempo de preprocessamento, jÃ¡ que este abre mÃ£o de performance a priori para responder as consultas o mais
rÃ¡pido possÃ­vel; entretanto, tambÃ©m possui um custo proibitivo de memÃ³ria conforme o
fator de ramificaÃ§Ã£o diminui, que pode tornÃ¡-lo inviÃ¡vel atÃ© mesmo para workstations com
grandes quantidades de memÃ³ria. O Algoritmo Trivial se torna mais viÃ¡vel conforme o
fator de ramificaÃ§Ã£o aumenta e tem custo zero de memÃ³ria e tempo de preprocessamento,
porÃ©m nÃ£o lida muito bem com seu pior caso de Ã¡rvores lineares, levando tempos que
tornariam qualquer aplicaÃ§Ã£o ineficaz conforme o tamanho das Ã¡rvores aumentam. Tanto
o Algoritmo dos Ponteiros quanto o Algoritmo da PrÃ©-ordem trazem soluÃ§Ãµes elegantes
com boas complexidades tanto para o preprocessamento quanto para as consultas, porÃ©m
de mais difÃ­cil compreensÃ£o; o primeiro leva a melhor nas consultas (exceto no caso de
Ã¡rvores lineares) ao passo que o segundo conta com o melhor preprocessamento de todos
(a menos do Trivial, que nÃ£o faz nada).

27
3.4 | CONCLUSÃ•ES E TRABALHO FUTURO

Numa continuaÃ§Ã£o deste trabalho, seria interessante expandir o estudo para o caso
do Problema do Ancestral de NÃ­vel dinÃ¢mico, no qual a Ã¡rvore do problema pode ser
modificada em tempo de execuÃ§Ã£o. Logo de cara Ã© fÃ¡cil perceber que o Algoritmo Trivial
funcionaria sem nenhuma adaptaÃ§Ã£o, enquanto os outros teriam que gastar algum tempo
reprocessando a Ã¡rvore, o que leva a mais discussÃµes interessantes. AlÃ©m disso, seria
bom testar os algoritmos com Ã¡rvores nÃ£o completas, talvez obtendo comparaÃ§Ãµes mais
condizentes com casos reais das aplicaÃ§Ãµes do problema.

29

ApÃªndice A

Testes de unidade com a biblioteca
Catch2

Para garantir a corretude dos algoritmos implementados neste trabalho, jÃ¡ estava
decidido desde o inÃ­cio a utilizar alguma ferramenta para realizar testes que pudessem
facilmente identificar erros nas implementaÃ§Ãµes ao longo do ano. Depois de pesquisar
bastante a biblioteca escolhida foi a Catch2 por ser header-only e facilitar o processo de
rodar em outras mÃ¡quinas sem precisar instalar nada. A sintaxe do framework fornecido
pela biblioteca Ã© bem organizada e foi de fÃ¡cil utilizaÃ§Ã£o. No programa A.1 consta uma
parte do cÃ³digo real dos testes do Algoritmo da Tabela, exemplificando quÃ£o simples Ã©
escrever testes de unidade bem separados por classe e tipo de teste, podendo criar diversos
casos de teste, cada um com um setup diferente de variÃ¡veis e objetos.

Para este estudo, cada algoritmo teve seus testes encapsulados dentro de casos de teste
(TEST_CASE) enquanto cada tipo de teste dentro de cada algoritmo (Ã¡rvores lineares, binÃ¡rias
e quaternÃ¡rias) foram colocados dentro de suas prÃ³prias seÃ§Ãµes (SECTION). As asserÃ§Ãµes,
que fazem o papel de garantir que algo realmente vale Ã© feito atravÃ©s das macros REQUIRE,
que checa igualdade entre dois valores e REQUIRE_THROW_AS, que verifica se uma funÃ§Ã£o
levantou a exceÃ§Ã£o que era esperada.

30
APÃŠNDICE A

Programa A.1 Parte dos testes para o Algoritmo da Tabela.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

#include "../include/catch.hpp"
#include "../../generators/generators.hpp"
#include "../include/TestUtils.hpp"
#include "../../code/include/TableAlgorithm.hpp"
TEST_CASE ("Table algorithm", "[table]") {
SECTION ("Binary Tree") {
int n = 2178;
vector<Nodeâˆ—> nodes;
build_balanced_kary_tree(n, 2, nodes);
Tree âˆ—tree = new Tree(nodes.size(), nodes[0]);
TableAlgorithm âˆ—table = new TableAlgorithm(tree);
SECTION ("Has a query function") {
for (int node = 0; node < n; node++) {
for (int depth = 0; depth <= treeâˆ’>depth(node); depth++) {
REQUIRE(tableâˆ’>query(node, depth) == naive_check(tree, node, depth
));
}
}
SECTION ("Query function returns âˆ’1 if there is no answer") {
REQUIRE(tableâˆ’>query(1, treeâˆ’>size()) == âˆ’1);
REQUIRE(tableâˆ’>query(1, treeâˆ’>size()) == âˆ’1);
}

18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35

SECTION ("Query function throws if negative depth") {
REQUIRE_THROWS_AS(tableâˆ’>query(1, âˆ’1), std::invalid_argument);
}

}

}

}

SECTION ("Query function throws if invalid node") {
REQUIRE_THROWS_AS(tableâˆ’>query(âˆ’1, 0), std::invalid_argument);
REQUIRE_THROWS_AS(tableâˆ’>query(treeâˆ’>size(), 0), std::invalid_argument)
;
}

31

ReferÃªncias
[Catch2 s.d.] Catch2. url: https://github.com/catchorg/Catch2.
[Bender e Farach-Colton 2002] Michael A. Bender e Martin Farach-Colton. â€œThe
level ancestor problem simplifiedâ€. Em: LATIN. 2002 (citado na pg. 8).
[Euler 1741] Leonhard Euler. â€œSolutio problematis ad geometriam situs pertinentisâ€. Em: Commentarii Academiae Scientiarum Imperialis Petropolitanae 8 (1741),
pgs. 128â€“140 (citado na pg. 2).
[Farach e Muthukrishnan 1996] Martin Farach e S. Muthukrishnan. â€œPerfect
hashing for strings: formalization and algorithmsâ€. Em: Combinatorial Pattern
Matching. Ed. por Dan Hirschberg e Gene Myers. Berlin, Heidelberg: Springer
Berlin Heidelberg, 1996, pgs. 130â€“140. isbn: 978-3-540-68390-2 (citado na pg. 8).
[Geary et al. 2006] Richard F. Geary, Rajeev Raman e Venkatesh Raman. â€œSuccinct
ordinal trees with level-ancestor queriesâ€. Em: ACM Trans. Algorithms 2.4 (out. de
2006), pgs. 510â€“534. issn: 1549-6325. doi: 10.1145/1198513.1198516. url: http:
//doi.acm.org/10.1145/1198513.1198516 (citado na pg. 8).
[Hopkins e Wilson 2004] Brian Hopkins e Robin J. Wilson. â€œThe truth about kÃ¶nigsbergâ€. Em: The College Mathematics Journal 35.3 (2004), pgs. 198â€“207. doi: 10.1080/
07468342.2004.11922073. eprint: https://doi.org/10.1080/07468342.2004.11922073.
url: https://doi.org/10.1080/07468342.2004.11922073 (citado na pg. 2).
[Menghani e Matani 2019] Gaurav Menghani e Dhruv Matani. A Simple Solution to
the Level-Ancestor Problem. 2019. arXiv: 1903.01387 [cs.DS] (citado na pg. 8).
[Papamichail et al. 2014] Dimitris Papamichail, Thomas Caputi e Georgios Papamichail. â€œThe level ancestor problem in practiceâ€. Em: (fev. de 2014) (citado na
pg. 8).
[Sadakane e Grossi 2006] Kunihiko Sadakane e Roberto Grossi. â€œSqueezing succinct
data structures into entropy boundsâ€. Em: Proceedings of the Seventeenth Annual
ACM-SIAM Symposium on Discrete Algorithm. SODA â€™06. Miami, Florida: Society
for Industrial e Applied Mathematics, 2006, pgs. 1230â€“1239. isbn: 0-89871-605-5.
url: http://dl.acm.org/citation.cfm?id=1109557.1109693 (citado na pg. 8).

32
REFERÃŠNCIAS

[Yuan e Atallah 2009] Hao Yuan e Mikhail J. Atallah. â€œEfficient data structures
for range-aggregate queries on treesâ€. Em: Proceedings of the 12th International
Conference on Database Theory. ICDT â€™09. St. Petersburg, Russia: ACM, 2009,
pgs. 111â€“120. isbn: 978-1-60558-423-2. doi: 10.1145/1514894.1514908. url: http:
//doi.acm.org/10.1145/1514894.1514908 (citado na pg. 8).

